# -*- coding: utf-8 -*-
# *** Spyder Python Console History Log ***

## ---(Tue Jan 28 09:37:30 2020)---
runfile('C:/Users/wtjang/.spyder-py3/temp.py', wdir='C:/Users/wtjang/.spyder-py3')
df.head(5)
df_1 = df.loc[:,'Recipe_Step_Number':'S2_VAT_Position'].apply(pd.to_numeric, errors = 'coerce')

#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경

df_1.Time = pd.to_datetime(df.Time) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]
df_1.head(5)
df_1.loc[1,1]
df_1.loc(1,1)
df_1(1,1)
df_1[3,3]
df_1(3,3)

df_1[Recipe_Step_Number]
df_1
df_1[Time]
df_1['Recipe_Step_Number' == 6]
df.loc[:4]
df.loc[2:10]
df_1.S2_N2_FLOW.type()
df_1.S2_N2_FLOW.type
df_1.S2_N2_FLOW
df_1.S2_N2_FLOW[:2]
df_1.S2_N2_FLOW[:1]
df_1.S2_N2_FLOW[:1] +1
df_1['Recipe_Step_Number'] == 6
df_2 = df.loc[df_1['Recipe_Step_Number'] == 6]
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]
Gas_Input = ['S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position' ]   
df_2[Gas_Input]
df_3 = df_2[Gas_Input]
Gas_Input = ['S1_SiH4_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position' ]   
df_3 = df_2[Gas_Input]
Gas_Input = ['S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position' ]   
df_3 = df_2[Gas_Input]
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position' ]   
df_3 = df_2[Gas_Input]
df_3.mean()
df_3.var()
df_3.median()
df_3.std()
master = pd.DataFrame(index=range(0,10), columns=['칼럼이름1', '칼럼이름2'])
temp = df_3.std()
temp.loc[2]
temp.loc[1,1]
temp.name
temp.name()
temp.index
temp
temp[1,2]
temp(1,2)
temp.loc[[2, 3]]
df.loc[:4]
temp.loc[:4]
temp
temp[,2]
temp[:,2]
temp.index
answer = temp.index
answer
master.columns = [answer]
answer[1]
master.columns = [answer[1]
]
answer[1]
answer[2]
answer
master.columns = answer
master = pd.DataFrame(index=range(0,10), columns=[answer])
temp_1 = answer(1) + '_sdv'
answer(1).type
answer(1).type()
answer(1)
answer[1]
answer[1].type
answer[1].type()
answer[1] + '_sdv'
answer + '_sdv'
answer_2 = answer + '_sdv'
answer_2[1]
answer_mean = answer + '_mean'
answer_median = answer + '_median'
answer_sdv = answer + '_sdv'
answer_mean
answer_median
answer_sdv
master = pd.DataFrame(index=range(0,10), columns=[answer_mean, answer_median, answer_sdv])
master = pd.DataFrame(index=range(0,10), columns=[[answer_mean, answer_median, answer_sdv]])
temp.mean()
df_3.mean()
temp
answer_mean = answer + '_mean'
value_mean = df_3.mean()

answer_median = answer + '_median'
value_median = df_3.median()

answer_sdv = answer + '_sdv'
value_sdv = df_3.sdv()
answer_mean = answer + '_mean'
value_median = df_3.median()
value_sdv = df_3.sdv()
value_sdv = df_3.std()
answer_std = answer + '_std'
value_std = df_3.std()
answer_mean
master = pd.DataFrame(index=range(0,10), columns=[answer_mean])
master.columns
master.columns[1]
answer_mean
answer_mean[1]
value_mean
vaule_mean(1)
vaule_mean[1]
value_mean[1]
value_mean.type
value_mean.type()
value_mean.values
temp_100 = master.transpose
master.transpose
master.transpose()
temp_100 = master.transpose()
master.loc[1]
master.loc[1] = value_mean.values
master.loc[0] = value_mean.values
temp_mean = pd.DataFrame(index=range(0,10), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,10), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,10), columns=[answer_std])
temp_std.loc[0] = value_std.values
master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
master
%clear
f = open(r'C:\Users\wtjang\Documents\work\201903080435_754_No_He_SiN__2500.log')
lines = f.readlines()
labels = lines[11].split() # line 11 : Factor
import pandas as pd
df = pd.DataFrame(columns = labels)
for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp

df_1 = df.loc[:,'Recipe_Step_Number':end].apply(pd.to_numeric, errors = 'coerce')
df_1 = df.loc[:,'Recipe_Step_Number':df.iloc[:,-1]].apply(pd.to_numeric, errors = 'coerce')
df.iloc[:,-1]
df.iloc[:,-1].Name
(df.iloc[:,-1]).name
df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_1.Time = pd.to_datetime(df.Time) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
cols = df_1.columns.tolist()
df_1 = df_1[cols]
df_1.Time = pd.to_datetime(df.Time) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]


#뽑을 Factor들을 이미 정의
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position' ]   


df_3 = df_2[Gas_Input]
df_3.index
kk = df_3.std()
kk
df_3.std().index
answer_mean = answer + '_mean'
value_mean = df_3.mean()

answer_median = answer + '_median'
value_median = df_3.median()

answer_std = answer + '_std'
value_std = df_3.std()
answer = df_3.std().index # Factor들 이름만 가져옴
answer_mean = answer + '_mean'
value_mean = df_3.mean()

answer_median = answer + '_median'
value_median = df_3.median()

answer_std = answer + '_std'
value_std = df_3.std()
value_mean.values
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values

temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values

temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values


master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
master = pd.concat([master, master])
%clear
import os
path_dir = 'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()
file_list[0]
path_dir + file_list[0]
f = open(path_dir + file_list[0])
path_dir + '\' +  file_list[0]
file_list[0]
'\' + file_list[0]
"\" + file_list[0]
"\" + file_list[0];
file_list[1]
path_dir
path_dir + file_list[1]
path_dir +  '\\' +  file_list[1]
f = open(path_dir +  '\\' +  file_list[0])
lines = f.readlines()
file.list.size
file_list.size
file_list.size()
file_list.index
file_list.count
size(file_list)
len(file_list)
path_dir +  '\\' +  file_list[0]
%clear
import os
path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()
len(file_list)-1
for k in range(0, len(file_list)-1):
k=0
path_dir +  '\\' +  file_list[k]
f = open(path_dir +  '\\' +  file_list[k])
lines = f.readlines()
labels = lines[11].split() # line 11 : Factor

import pandas as pd

df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp


df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_1.Time = pd.to_datetime(df.Time) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]

#df_1에서 모든 log 분할 완성 

# 2. 특정 Step 값만 가져오기

# 6Step만 선택
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 이미 정의
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position' ]   
df_3 = df_2[Gas_Input]

# Factor들 이름만 가져옴
answer = df_3.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_3.mean()
answer_median = answer + '_median'
value_median = df_3.median()
answer_std = answer + '_std'
value_std = df_3.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
master = pd.concat([master, temp_master])
master = temp_master
master = pd.concat([master, temp_master])
k=1
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor

import pandas as pd

df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp


df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_1.Time = pd.to_datetime(df.Time) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]

#df_1에서 모든 log 분할 완성 

# 2. 특정 Step 값만 가져오기

# 6Step만 선택
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 이미 정의
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position' ]   
df_3 = df_2[Gas_Input]

# Factor들 이름만 가져옴
answer = df_3.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_3.mean()
answer_median = answer + '_median'
value_median = df_3.median()
answer_std = answer + '_std'
value_std = df_3.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
master = pd.concat([master, temp_master])
%clear
runfile('C:/Users/wtjang/.spyder-py3/temp.py', wdir='C:/Users/wtjang/.spyder-py3')
%clear
import os

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()


for k in range(0, len(file_list)):



# 1. log파일 분할시키기

#f = open(r'C:\Users\wtjang\Documents\work\L_MOLD_GAS\201903080435_754_No_He_SiN__2500.log')
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    import pandas as pd
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_1.Time = pd.to_datetime(df.Time) # 타입 변환
    df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_1.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_1 = df_1[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 2. 특정 Step 값만 가져오기
    
    # 6Step만 선택
    df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 이미 정의
    Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position' ]   
    df_3 = df_2[Gas_Input]
    
    # Factor들 이름만 가져옴
    answer = df_3.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_3.mean()
    answer_median = answer + '_median'
    value_median = df_3.median()
    answer_std = answer + '_std'
    value_std = df_3.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master = pd.concat([master, temp_master])






















file_list[k]
file_list[49]
file_list[48]
file_list[50]
f.close()
%clear
import os

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()


for k in range(0, len(file_list)-1):



# 1. log파일 분할시키기

#f = open(r'C:\Users\wtjang\Documents\work\L_MOLD_GAS\201903080435_754_No_He_SiN__2500.log')
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    import pandas as pd
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_1.Time = pd.to_datetime(df.Time) # 타입 변환
    df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_1.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_1 = df_1[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 2. 특정 Step 값만 가져오기
    
    # 6Step만 선택
    df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 이미 정의
    Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position' ]   
    df_3 = df_2[Gas_Input]
    
    # Factor들 이름만 가져옴
    answer = df_3.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_3.mean()
    answer_median = answer + '_median'
    value_median = df_3.median()
    answer_std = answer + '_std'
    value_std = df_3.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master = pd.concat([master, temp_master])






















len(file_list)-1
%clear
runfile('C:/Users/wtjang/.spyder-py3/temp.py', wdir='C:/Users/wtjang/.spyder-py3')
len(file_list)
f.close()
%clear
runfile('C:/Users/wtjang/.spyder-py3/temp.py', wdir='C:/Users/wtjang/.spyder-py3')

## ---(Wed Jan 29 08:47:22 2020)---
runfile('C:/Users/wtjang/.spyder-py3/L_MOLD.py', wdir='C:/Users/wtjang/.spyder-py3')
df_1.loc[2298,1]
df_1.loc(2298,1)
df_1.loc[2298,3]
df_1.loc[3]
df_1.loc[3,1]
df_1.loc[3,2]
df_1.loc[2]
df_1[2,1]
df_1(2,1)

df_1.iloc[2,2]
df_1.iloc[2,1]
df_1.iloc[1,2]
df_1.iloc[1,1]
df_1.iloc[1,2]
df_1.iloc[1,3]
df_1.iloc[1,4]
df_1.iloc[1,5]
df_1.iloc[3]
df_1.iloc[3,1]
df_1.iloc[2298]
df_1.iloc[2297]
df_1.loc[2297, 'Time']
df_1.loc[2297, 'Time'] - df_1.loc[0, 'Time']
df_1.loc[2297, 'Time'] - df_1.loc[1, 'Time']
df_2.loc[2068, 'Time'] - df_2.loc[1269, 'Time']
result = pd.read_excel(r'C:\Users\wtjang\Documents\work\L_MOLD_result.xlsx')
master = pd.concat([master, result['D_R', 'stress']])
master['D_R'] = result['D_R']
result['D_R']
master['D_R'] = result['D_R']
result['D_R', 'stress']
result[['D_R', 'stress']]
master = pd.concat([master, result[['D_R', 'stress']]])
master = pd.concat(master, result[['D_R', 'stress']])
master = pd.concat(master, result[['D_R', 'stress']], axis = 1)
master = pd.concat([master, result[['D_R', 'stress']]], axis = 1)
result[['D_R', 'stress']].type
result[['D_R', 'stress']].type()
result[['D_R', 'stress']]
master = pd.concat([master, result[['D_R', 'stress']],] axis=1)
master = pd.concat([master, result[['D_R', 'stress']]], axis=1)
temp_1 = pd.concat([master, [resutlt['D_R', 'stress']])
)
result['D_R', 'stress']
result('D_R', 'stress')
result[['D_R', 'stress']]
temp_1 = result[['D_R', 'stress']]
master.append(result[['D_R', 'stress']])
pd.concat([master, result[['D_R', 'stress']]],axis=1)
pd.concat([master, temp_1],axis=1)
master
temp_1
master
master.loc[3]
master[3]
master(3)
master.index
master = master.reset_index(drop=True)
master.loc[]3
master.loc[3]
pd.concat([master, result['D_R', 'stress']],axis=1)
pd.concat([master, result('D_R', 'stress')],axis=1)
result[['D_R','stress']]
pd.concat([master, result[['D_R','stress']]],axis = 1)
del master['D_R']
temp_1 = temp_1.reset_index(drop = True)
(result[['D_R', 'stress']]).reset.index
result[['D_R', 'stress']]
result = result.reset_index(drop=True)
pd.concat([master, result[['D_R','stress']]],axis = 1)
master = pd.concat([master, result[['D_R','stress']]],axis = 1)
result = result.reset_index(drop=True)  
result = pd.read_excel(r'C:\Users\wtjang\Documents\work\L_MOLD_result.xlsx')
result = result.reset_index(drop=True)  
master = pd.concat([master, result[['D_R','stress']]],axis = 1)
del master['D_R', 'stress']
del master[['D_R', 'stress']]
del master['D_R']
del master['stress']
master = pd.concat([master, result[['D_R','stress']]],axis = 1)
result = pd.read_excel(r'C:\Users\wtjang\Documents\work\L_MOLD_result.xlsx')
result = result.reset_index(drop=True)  
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
train_data, test_data = train_test_split(master, test_size = 0.2, random_state = 123)
print('Shape of trainign data : ', train_data.shape)
del master['stress']
train_data, test_data = train_test_split(master, test_size = 0.2, random_state = 123)
train_x = train_data.drop(columns=['D_R'], axis=1)
train_y = train_data['D_R']
test_x = test_data.drop(columns=['D_R'], axis=1)
test_y = test_data['D_R']
model = KneighborsClassifier()
model = KNeighborsClassifier()
model.fit(train_x, train_y)
rmse_val = []

for K in range(20):
    K = K+1
    model = neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)






from sklearn.neighbors import KNeighborsClassifier
rmse_val = []

for K in range(20):
    K = K+1
    model = neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)







from sklearn.neighbors import KNeighborsRegressor
rmse_val = []

for K in range(20):
    K = K+1
    model = neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)




rmse_val = []

for K in range(20):
    K = K+1
    model = KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)





sqrt(2)
from sklearn import neighbors
import matplotlib.pyplot as plt
%matplotlib inline
rmse_val = []

for K in range(20):
    K = K+1
    model = KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)





from math import sqrt
rmse_val = []

for K in range(20):
    K = K+1
    model = KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)


from sklearn.metrics import mean_squared_error 
rmse_val = []

for K in range(20):
    K = K+1
    model = KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)




from sklearn.model_selection import train_test_split

from sklearn import neighbors
from sklearn.metrics import mean_squared_error 
from math import sqrt
import matplotlib.pyplot as plt
%matplotlib inline
rmse_val = []

for K in range(20):
    K = K+1
    model = KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

curve = pd.DataFrame(rmse_val)
curve.plot()
pred
test_y
plot(pred, test_y)
test_y.plot
test_y.plot()
pred
test_y
curve.plot()
import matplotlib.pyplot as plt 
plt.plot(test_y)
plt.plot(test_y.sort_index)
pred
plt.plot(pred)
plt.plot(test_y['D_R'])
test_y['D_R']
test_y
test_y.values
plt.plot(test_y.values)
plt.plot(test_y.values, color='r')
plt.plot(pred, color='b')
plt.plot(test_y.values, color='r')
plt.plot(pred, color='b')
plt.plot(pred, 'pred' ,color = 'b')
plt.plot(test_y.values, color='r')
plt.plot(pred, color='b')
plt.plot(pred, marker = pred,color='b')
plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')
test_y.index
xs = 1:10
xs = [1:10]
xs = [1,2,3,4,5,6,7,8,9,10]
xs
ys = test_y.values
for x, y in zip(xs, ys):
    label = y
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",))

for x, y in zip(xs, ys):
    label = y
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points")

xs = np.arange(0,10,1)
import np from numpy
from np import numpy
import numpy as np
xs = np.arange(0,10,1)
ys
xs
for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center')

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center')

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center')   

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'left')    

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'left')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'left') 

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,5),
                 ha = 'left') 

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,3),
                 ha = 'center')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,3),
                 ha = 'left') 

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,3),
                 ha = 'center')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,-5),
                 ha = 'left') 

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,5),
                 ha = 'center')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,-10),
                 ha = 'center')    

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,5),
                 ha = 'center')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,-10),
                 ha = 'center')   

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,5),
                 ha = 'center',
                 col = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,-10),
                 ha = 'center')  

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,5),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,-10),
                 ha = 'center') 

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,5),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,-10),
                 ha = 'center'
                 color = 'b')    

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,5),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,-10),
                 ha = 'center',
                 color = 'b')    

plt.plot(test_y.values, color='r')
plt.plot(pred,color='b')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,5),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,-20),
                 ha = 'center',
                 color = 'b')  

plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,5),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,-20),
                 ha = 'center',
                 color = 'b')    

plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')    

ys
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range(0,1))
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0, 1))
train_x_scaled = scaler.fit_transform(train_x)
train_x = pd.DataFrame(train_x_scaled)
test_x_scaled = scaler.fit_transform(test_x)
test_x = pd.DataFrame(test_x_scaled)
rmse_val = []

for K in range(20):
    K = K+1
    model = KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

curve = pd.DataFrame(rmse_val)
curve.plot()
plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')    

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()
path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):



# 1. log파일 분할시키기

#f = open(r'C:\Users\wtjang\Documents\work\L_MOLD_GAS\201903080435_754_No_He_SiN__2500.log')
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_4.Time = pd.to_datetime(df.Time) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 2. 특정 Step 값만 가져오기
    
    # 6Step만 선택
    df_5 = df_4.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 이미 정의
    Temp_Input = ['Time', 'CHUCK POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])
k=1
f = open(path_dir +  '\\' +  file_list[k])
f
lines = f.readlines()
labels = lines[11].split() # line 11 : Factor
df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp

df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
f.close()
path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):



# 1. log파일 분할시키기

#f = open(r'C:\Users\wtjang\Documents\work\L_MOLD_GAS\201903080435_754_No_He_SiN__2500.log')
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_4.Time = pd.to_datetime(df.Time) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 2. 특정 Step 값만 가져오기
    
    # 6Step만 선택
    df_5 = df_4.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 이미 정의
    Temp_Input = ['Time', 'CHUCK POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])
path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):



# 1. log파일 분할시키기

#f = open(r'C:\Users\wtjang\Documents\work\L_MOLD_GAS\201903080435_754_No_He_SiN__2500.log')
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_4.Time = pd.to_datetime(df.Time) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 2. 특정 Step 값만 가져오기
    
    # 6Step만 선택
    df_5 = df_4.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 이미 정의
    Temp_Input = ['Time', 'S1_CHUCK POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])
path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):



# 1. log파일 분할시키기

#f = open(r'C:\Users\wtjang\Documents\work\L_MOLD_GAS\201903080435_754_No_He_SiN__2500.log')
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_4.Time = pd.to_datetime(df.Time) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 2. 특정 Step 값만 가져오기
    
    # 6Step만 선택
    df_5 = df_4.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 이미 정의
    Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])
K=0
(path_dir +  '\\' +  file_list[k])
k=0
(path_dir +  '\\' +  file_list[k])
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor



df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp

df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_4.Time = pd.to_datetime(df.Time) # 타입 변환
df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
cols = df_4.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_4 = df_4[cols]
df_5 = df_4.loc[df_1['Recipe_Step_Number'] == 6]
Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
df_6 = df_5[Temp_Input]
answer = df_6.std().index 
answer
answer_mean = answer + '_mean'
value_mean = df_6.mean()
answer_median = answer + '_median'
value_median = df_6.median()
answer_std = answer + '_std'
value_std = df_6.std()
value_mean
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values
temp_std
temp_master
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
k
if k ==0:
    master_2 = temp_master # 제일 처음에만    

# log 50개를 누적해서 50row로 만드는게 목적
#조건문으로 들어가게 해줘야함
else:
    master_2 = pd.concat([master_2, temp_master])
k=1
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor



df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp

df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_4.Time = pd.to_datetime(df.Time) # 타입 변환
df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_4.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_4 = df_4[cols]

#df_1에서 모든 log 분할 완성 

# 2. 특정 Step 값만 가져오기

# 6Step만 선택
df_5 = df_4.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 이미 정의
Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
df_6 = df_5[Temp_Input]

# Factor들 이름만 가져옴
answer = df_6.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_6.mean()
answer_median = answer + '_median'
value_median = df_6.median()
answer_std = answer + '_std'
value_std = df_6.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values
df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_4.Time = pd.to_datetime(df.Time) # 타입 변환
df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
cols = df_4.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_4 = df_4[cols]
df_5 = df_4.loc[df_1['Recipe_Step_Number'] == 6]
df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]
Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
df_6 = df_5[Temp_Input]

# Factor들 이름만 가져옴
answer = df_6.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_6.mean()
answer_median = answer + '_median'
value_median = df_6.median()
answer_std = answer + '_std'
value_std = df_6.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
if k ==0:
    master_2 = temp_master # 제일 처음에만    

# log 50개를 누적해서 50row로 만드는게 목적
#조건문으로 들어가게 해줘야함
else:
    master_2 = pd.concat([master_2, temp_master])
k
k=2
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor



df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp


df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_4.Time = pd.to_datetime(df.Time) # 타입 변환
df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_4.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_4 = df_4[cols]

#df_1에서 모든 log 분할 완성 

# 2. 특정 Step 값만 가져오기

# 6Step만 선택
df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 이미 정의
Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
df_6 = df_5[Temp_Input]

# Factor들 이름만 가져옴
answer = df_6.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_6.mean()
answer_median = answer + '_median'
value_median = df_6.median()
answer_std = answer + '_std'
value_std = df_6.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)


if k ==0:
    master_2 = temp_master # 제일 처음에만    

# log 50개를 누적해서 50row로 만드는게 목적
#조건문으로 들어가게 해줘야함
else:
    master_2 = pd.concat([master_2, temp_master])
k=0
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor



df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp


df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_4.Time = pd.to_datetime(df.Time) # 타입 변환
df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_4.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_4 = df_4[cols]

#df_1에서 모든 log 분할 완성 

# 2. 특정 Step 값만 가져오기

# 6Step만 선택
df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 이미 정의
Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
df_6 = df_5[Temp_Input]
df_6['Impedence'] = sqrt(df['HF_R_A'] * df['HF_R_A'] + df['HF_X_A'] * df['HF_X_A'])
df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A'])
df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A'])
df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']
27.397*27.397
sqrt(27.397*27.397)
sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A'])
sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A'])df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']
df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A'
]
sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A'])
(sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A'])).astype(float)
df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A'])
df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']
df_6['Impedence'] = df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']
sqrt(df_6['Impedence'])
df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)
sqrt(3.17*3.17 + 27.397*27.5798)
sqrt(3.17*3.17 + 27.397*27.397)
answer_mean = answer + '_mean'
value_mean = df_6.mean()
answer_median = answer + '_median'
value_median = df_6.median()
answer_std = answer + '_std'
value_std = df_6.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
del df_6['HF_R_A']
del df_6['HF_X_A']
answer = df_6.std().index
answer
answer_mean = answer + '_mean'
value_mean = df_6.mean()
answer_median = answer + '_median'
value_median = df_6.median()
answer_std = answer + '_std'
value_std = df_6.std()
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
k=0
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor



df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp


df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_4.Time = pd.to_datetime(df.Time) # 타입 변환
df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_4.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_4 = df_4[cols]

#df_1에서 모든 log 분할 완성 

# 2. 특정 Step 값만 가져오기

# 6Step만 선택
df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 이미 정의
Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
df_6 = df_5[Temp_Input]

# Impedence 계산
# df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) 
# sqrt 쓰면 cannot convert the series to <class 'float'> 오류남

df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)

del df_6['HF_R_A']
del df_6['HF_X_A']


# Factor들 이름만 가져옴
answer = df_6.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_6.mean()
answer_median = answer + '_median'
value_median = df_6.median()
answer_std = answer + '_std'
value_std = df_6.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
if k ==0:
    master_2 = temp_master # 제일 처음에만    

# log 50개를 누적해서 50row로 만드는게 목적
#조건문으로 들어가게 해줘야함
else:
    master_2 = pd.concat([master_2, temp_master])
k=1
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor



df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp


df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_4.Time = pd.to_datetime(df.Time) # 타입 변환
df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_4.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_4 = df_4[cols]

#df_1에서 모든 log 분할 완성 

# 2. 특정 Step 값만 가져오기

# 6Step만 선택
df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 이미 정의
Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
df_6 = df_5[Temp_Input]

# Impedence 계산
# df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) 
# sqrt 쓰면 cannot convert the series to <class 'float'> 오류남

df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)

del df_6['HF_R_A']
del df_6['HF_X_A']


# Factor들 이름만 가져옴
answer = df_6.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_6.mean()
answer_median = answer + '_median'
value_median = df_6.median()
answer_std = answer + '_std'
value_std = df_6.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)


if k ==0:
    master_2 = temp_master # 제일 처음에만    

# log 50개를 누적해서 50row로 만드는게 목적
#조건문으로 들어가게 해줘야함
else:
    master_2 = pd.concat([master_2, temp_master])
path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):



# 1. log파일 분할시키기

#f = open(r'C:\Users\wtjang\Documents\work\L_MOLD_GAS\201903080435_754_No_He_SiN__2500.log')
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_4 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_4.Time = pd.to_datetime(df.Time) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 2. 특정 Step 값만 가져오기
    
    # 6Step만 선택
    df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 이미 정의
    Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Impedence 계산
    # df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) 
    # sqrt 쓰면 cannot convert the series to <class 'float'> 오류남
    
    df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)
    
    del df_6['HF_R_A']
    del df_6['HF_X_A']
    
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])
master_2.reset_index
%clear
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):



# 1. log파일 분할시키기

#f = open(r'C:\Users\wtjang\Documents\work\L_MOLD_GAS\201903080435_754_No_He_SiN__2500.log')
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor  
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_1.Time = pd.to_datetime(df.Time) # 타입 변환
    df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_1.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_1 = df_1[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 2. 특정 Step 값만 가져오기
    
    # 6Step만 선택
    df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 이미 정의
    Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
                 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']   
    df_3 = df_2[Gas_Input]
    
    df_3['Delivery_Power'] = df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']
    
    del df_3['HF_FORWARD_A']
    del df_3['HF_REFLECT_A']
    
    # Factor들 이름만 가져옴
    answer = df_3.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_3.mean()
    answer_median = answer + '_median'
    value_median = df_3.median()
    answer_std = answer + '_std'
    value_std = df_3.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master = pd.concat([master, temp_master])


path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):


# 1. log파일 분할시키기

#f = open(r'C:\Users\wtjang\Documents\work\L_MOLD_GAS\201903080435_754_No_He_SiN__2500.log')
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    df_temp = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df_temp.loc[i-12] = temp
    
    df_4 = df_temp.loc[:,'Recipe_Step_Number':(df_temp.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_4.Time = pd.to_datetime(df_4.Time) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 2. 특정 Step 값만 가져오기
    
    # 6Step만 선택
    df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 이미 정의
    Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Impedence 계산
    # df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) 
    # sqrt 쓰면 cannot convert the series to <class 'float'> 오류남
    
    df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)
    
    del df_6['HF_R_A']
    del df_6['HF_X_A']
    
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])
path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):


# 1. log파일 분할시키기

#f = open(r'C:\Users\wtjang\Documents\work\L_MOLD_GAS\201903080435_754_No_He_SiN__2500.log')
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    df_temp = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df_temp.loc[i-12] = temp
    
    df_4 = df_temp.loc[:,'Recipe_Step_Number':(df_temp.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_4.Time = pd.to_datetime(df_temp.Time) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 2. 특정 Step 값만 가져오기
    
    # 6Step만 선택
    df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 이미 정의
    Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Impedence 계산
    # df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) 
    # sqrt 쓰면 cannot convert the series to <class 'float'> 오류남
    
    df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)
    
    del df_6['HF_R_A']
    del df_6['HF_X_A']
    
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])


# 로그 Table 완성
result = pd.read_excel(r'C:\Users\wtjang\Documents\work\L_MOLD_result.xlsx')
master = master.reset_index(drop=True)  
master_2 = master_2.reset_index(drop=True)  
result = result.reset_index(drop=True)  
finial_master = pd.concat([master, master_2, result['D_R']],axis = 1)
finial_master_D_R = pd.concat([master, master_2, result['D_R']],axis = 1)
from sklearn.model_selection import train_test_split
from sklearn import neighbors
from sklearn.metrics import mean_squared_error 
from math import sqrt
import matplotlib.pyplot as plt
import matplotlib.pyplot as plt 
train_data, test_data = train_test_split(final_master_D_R, test_size = 0.2, random_state = 123)
final_master_D_R = pd.concat([master, master_2, result['D_R']],axis = 1)
train_data, test_data = train_test_split(final_master_D_R, test_size = 0.2, random_state = 123)
train_x = train_data.drop(columns=['D_R'], axis=1)
train_y = train_data['D_R']

test_x = test_data.drop(columns=['D_R'], axis=1)
test_y = test_data['D_R']
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0, 1))

train_x_scaled = scaler.fit_transform(train_x)
train_x = pd.DataFrame(train_x_scaled)

test_x_scaled = scaler.fit_transform(test_x)
test_x = pd.DataFrame(test_x_scaled)
for K in range(20):
    K = K+1
    model = KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)


from sklearn import neighbors
rmse_val = []

for K in range(20):
    K = K+1
    model = KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)


rmse_val = []

for K in range(20):
    K = K+1
    from sklearn import neighbors
    model = KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

rmse_val = []

for K in range(20):
    K = K+1
    from sklearn import neighbors
    model = sklearn.neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)


rmse_val = []

for K in range(20):
    K = K+1
    
    model = sklearn.neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

rmse_val = []

for K in range(20):
    K = K+1
    
    model = KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

import sklearn
from sklearn.model_selection import train_test_split
from sklearn import neighbors
from sklearn.metrics import mean_squared_error 
from math import sqrt
import matplotlib.pyplot as plt
rmse_val = []

for K in range(20):
    K = K+1
    
    model = KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

rmse_val = []

for K in range(20):
    K = K+1
    
    model = sklearn.neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

curve = pd.DataFrame(rmse_val)
curve.plot()
plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')    

# plt.title("sin & cos") # 제목

# git test
import xgboost
import csv as csv
from xgboost import plot_importance
from matplotlib import pyplot
from sklearn.model_selection import cross_val_score,KFold
from sklearn.cross_validation import  train_test_split
from sklearn.metrics import mean_absolute_error
import matplotlib.pyplot as plt
from sklearn.grid_search import GridSearchCV   #Perforing grid search
from scipy.stats import skew
from collections import OrderedDict
import xgboost
anaconda search -t conda xgboost
import xgboost
import csv as csv
from xgboost import plot_importance
from matplotlib import pyplot
from sklearn.model_selection import cross_val_score,KFold
from sklearn.cross_validation import  train_test_split
from sklearn.metrics import mean_absolute_error
import matplotlib.pyplot as plt
from sklearn.grid_search import GridSearchCV   #Perforing grid search
from scipy.stats import skew
from collections import OrderedDict
from matplotlib import pyplot
from sklearn.model_selection import cross_val_score,KFold
from sklearn.cross_validation import  train_test_split
from sklearn.metrics import mean_absolute_error
import matplotlib.pyplot as plt
from sklearn.grid_search import GridSearchCV   #Perforing grid search
from scipy.stats import skew
from collections import OrderedDict
import csv as csv
from xgboost import plot_importance
import xgboost
from xgboost import plot_importance
import xgboost
from xgboost import plot_importance
import xgboost
from xgboost import plot_importance
parameters_for_testing = {
    'colsample_bytree':[0.4,0.6,0.8],
    'gamma':[0,0.03,0.1,0.3],
    'min_child_weight':[1.5,6,10],
    'learning_rate':[0.1,0.07],
    'max_depth':[3,5],
    'n_estimators':[10000],
    'reg_alpha':[1e-5, 1e-2,  0.75],
    'reg_lambda':[1e-5, 1e-2, 0.45],
    'subsample':[0.6,0.95]  
}
min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, 
subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=6,iid=False, verbose=10,scoring='neg_mean_squared_error')
gsearch1.fit(train_x_scaled,train_y)
gsearch1.fit(train_x,train_y)
gsearch1.fit(train_x_scaled,train_y)
gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=1,iid=False, verbose=10,scoring='neg_mean_squared_error')
gsearch1.fit(train_x, train_y)
print (gsearch1.grid_scores_)
print('best params')
print (gsearch1.best_params_)
print('best score')
print (gsearch1.best_score_)
seed = 42)
best_xgb_model = xgboost.XGBRegressor(colsample_bytree = 0.8,
                                      gamma = 0.3,
                                      learning_rate = 0.1,
                                      max_depth =3,
                                      min_child_wright = 1.5,
                                      n_estimators = 10000,
                                      reg_alpha = 0.75,
                                      reg_lambda = 0.45,
                                      subsample = 0.6,
                                      seed = 42)
best_xgb_model.fit(train_x, train_y)
best_xgb_model.predict(test_x)
test_y
xgb_result = best_xgb_model.fit(train_x, train_y)
xgb_result
xgb_result = best_xgb_model.predict(test_x)
xgb_result
plt.plot(test_y.values, 'ro-')
plt.plot(xgb_result, 'bo-')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = xgb_result

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')  

gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=2,iid=False, verbose=10,scoring='neg_mean_squared_error')
gsearch1.fit(train_x, train_y)
gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=20,iid=False, verbose=10,scoring='neg_mean_squared_error')
gsearch1.fit(train_x, train_y)
if _name_ == '_main_':
    xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
    gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=10,iid=False, verbose=10,scoring='neg_mean_squared_error')
    gsearch1.fit(train_x, train_y)

if __name__=='__main__':
    xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
    gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=10,iid=False, verbose=10,scoring='neg_mean_squared_error')
    gsearch1.fit(train_x, train_y)

if __name__ == '__main__'
    xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
    gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=10,iid=False, verbose=10,scoring='neg_mean_squared_error')
    gsearch1.fit(train_x, train_y)

if __name__ == '__main__':
    xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
    gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=10,iid=False, verbose=10,scoring='neg_mean_squared_error')
    gsearch1.fit(train_x, train_y)

if __name__ == '__main__':
    xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
    gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=5,iid=False, verbose=10,scoring='neg_mean_squared_error')
    gsearch1.fit(train_x, train_y)

if __name__ == '__main__':
    xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
    gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=-1,iid=False, verbose=10,scoring='neg_mean_squared_error')
    gsearch1.fit(train_x, train_y)

xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=-1,iid=False, verbose=10,scoring='neg_mean_squared_error')
gsearch1.fit(train_x, train_y)
from joblib import Parallel, delayed
import multiprocessing
xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=10,iid=False, verbose=10,scoring='neg_mean_squared_error')
gsearch1.fit(train_x, train_y)
from joblib import Parallel, delayed
if __name__ == '__main__':
    xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
    gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=10,iid=False, verbose=10,scoring='neg_mean_squared_error')
    gsearch1.fit(train_x, train_y)

import multiprocessing
from joblib import Parallel, delayed
import joblib
from joblib import Parallel, delayed
import multiprocessing
from joblib import Parallel, delayed
import multiprocessing
if __name__ == '__main__':
    xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
    gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=10,iid=False, verbose=10,scoring='neg_mean_squared_error')
    gsearch1.fit(train_x, train_y)

xgb_model = xgboost.XGBRegressor(learning_rate =0.1, n_estimators=1000, max_depth=5,  min_child_weight=1, gamma=0, subsample=0.8, colsample_bytree=0.8, nthread=6, scale_pos_weight=1, seed=27)
gsearch1 = GridSearchCV(estimator = xgb_model, param_grid = parameters_for_testing, n_jobs=10,iid=False, verbose=10,scoring='neg_mean_squared_error')
gsearch1.fit(train_x, train_y)
rmse_val
curve
curve.type()
curve.type
plt.plot(test_y.values, 'ro-')
plt.plot(xgb_result, 'bo-')

import numpy as np

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = xgb_result

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')  


## ---(Mon Feb  3 14:23:15 2020)---
runfile('C:/Users/wtjang/.spyder-py3/test.py', wdir='C:/Users/wtjang/.spyder-py3')
1+1
runfile('C:/Users/wtjang/.spyder-py3/test.py', wdir='C:/Users/wtjang/.spyder-py3')
runfile('C:/Users/wtjang/.spyder-py3/test_ex.py', wdir='C:/Users/wtjang/.spyder-py3')
python example.py
runfile('C:/Users/wtjang/.spyder-py3/test_ex.py', wdir='C:/Users/wtjang/.spyder-py3')
from wafer_map import wm_app
import wm_app
%clear
import wm_app
pip list
import wafer_map
data = [(1,1, 20), 
data = [(1,1, 20), (3,3,10)]
wafer_map.wm_app.WaferMapApp(data)
wafer_map.wm_app.WaferMapApp(data,10,(0,0), 150,2,2)
wm_app.WaferMapApp(data,10,(0,0), 150,2,2)
import wm_app
import numpy
import colour
import wm_app
import wafer_map
import wafer_map.wm_app
wm_app.WaferMapApp(data,10,(0,0), 150,2,2)
import wm)app
import wm_app
from wafer_map import wm_app
data = [(1,1, 20), (3,3,10)]
wm_app.WaferMapApp(data,10,(0,0), 150,2,2)
wm_app.WaferMapApp(data)
wm_app.WaferMapApp(data, (1,1))
(-67.1751,	67.1751,	2014.9639),
data = [(0,0, 1969.493), 
        (0,95,2014.453),
        (-67.1751,	67.1751,	2014.9639),
        (-95,	0,	2015.6959),
        (-67.1751,	-67.1751,	2014.524),
        (0	,-95,	2014.9785),
        (67.1751,	-67.1751,	2041.684),
        (95,	0,	2043.2437),
        (67.1751,	67.1751,2041.6567)
        ]
%clear
from wafer_map import wm_app
data = [(0,0, 1969.493), 
        (0,95,2014.453),
        (-67.1751,	67.1751,	2014.9639),
        (-95,	0,	2015.6959),
        (-67.1751,	-67.1751,	2014.524),
        (0	,-95,	2014.9785),
        (67.1751,	-67.1751,	2041.684),
        (95,	0,	2043.2437),
        (67.1751,	67.1751,2041.6567)
        ]
wm_app.WaferMapApp(data, (1,1))
wm_app.WaferMapApp(data, (150,150))
wm_app.WaferMapApp(data, (150,150),(0,0),150)
data = [(0,0, 1969.493), 
        (0,95,2014.453),
        (-67.1751,	67.1751,	1000),
        (-95,	0,	2015.6959),
        (-67.1751,	-67.1751,	2014.524),
        (0	,-95,	2014.9785),
        (67.1751,	-67.1751,	2041.684),
        (95,	0,	2043.2437),
        (67.1751,	67.1751,2041.6567)
        ]
rMapApp(data, (150,150),(0,0),150)
data = [(0,0, 1969.493), 
        (0,95,2014.453),
        (-67.1751,	67.1751,	1000),
        (-95,	0,	2015.6959),
        (-67.1751,	-67.1751,	2014.524),
        (0	,-95,	2014.9785),
        (67.1751,	-67.1751,	2041.684),
        (95,	0,	2043.2437),
        (67.1751,	67.1751,2041.6567)
        ]
wm_app.WaferMapApp(data, (150,150),(0,0),150)
wm_app.WaferMapApp(data, (20,20),(0,0),150)
wm_app.WaferMapApp(data, (1,1),(0,0),150)
wm_app.WaferMapApp(data, (1,1),(0,0),100)
wm_app.WaferMapApp(data, (1,1),(0,0),150)

## ---(Wed Feb  5 16:35:33 2020)---
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):    


# log파일 분할시키기
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor  
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    #Step부터 end col factor까지 numeric으로 타입 
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_1.Time = pd.to_datetime(df.Time) # 타입 변환
    df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_1.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_1 = df_1[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 특정 Step 값만 가져오기
    
    # 6Step만 선택 - Depo Step
    df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 사전 정의 - based on domain knowledge
    #Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
    #             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  
    
    Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
                  'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
    df_3 = df_2[Gas_Input]
    
    df_3['Delivery_Power'] = df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']
    
    del df_3['HF_FORWARD_A']
    del df_3['HF_REFLECT_A']
    
    # Factor들 이름만 가져옴
    answer = df_3.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_3.mean()
    answer_median = answer + '_median'
    value_median = df_3.median()
    answer_std = answer + '_std'
    value_std = df_3.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master = pd.concat([master, temp_master])


# Temp 추출

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    df_temp = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df_temp.loc[i-12] = temp
    
    df_4 = df_temp.loc[:,'Recipe_Step_Number':(df_temp.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    df_4.Time = pd.to_datetime(df_temp.Time) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
    
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    # 6Step만 선택
    df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 사전 정의
    #Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Impedence 계산
    # df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) 
    # sqrt 쓰면 cannot convert the series to <class 'float'> 오류남
    
    df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)
    
    del df_6['HF_R_A']
    del df_6['HF_X_A']
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])

result = pd.read_excel(r'C:\Users\wtjang\Documents\work\L_MOLD_result.xlsx')
master = master.reset_index(drop=True)   # Gas
master_2 = master_2.reset_index(drop=True) # Temp 
result = result.reset_index(drop=True)  # Result
final_master_D_R = pd.concat([master, master_2, result['D_R']],axis = 1)
from sklearn.model_selection import train_test_split
from sklearn import neighbors
from sklearn.metrics import mean_squared_error 
from math import sqrt
import matplotlib.pyplot as plt

# train_test_split(arrays, test_size, train_size, random_state, shuffle, stratify)
train_data, test_data = train_test_split(final_master_D_R, test_size = 0.2, random_state = 123)

# seperate the independent and target variable on training data
train_x = train_data.drop(columns=['D_R'], axis=1)
train_y = train_data['D_R']

test_x = test_data.drop(columns=['D_R'], axis=1)
test_y = test_data['D_R']

# Preprocessing 전처리 한게 더 오차율 좋음 RMSE 100감소
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0, 1))

train_x_scaled = scaler.fit_transform(train_x)
train_x = pd.DataFrame(train_x_scaled)

test_x_scaled = scaler.fit_transform(test_x)
test_x = pd.DataFrame(test_x_scaled)
rmse_val = []

for K in range(20):
    K = K+1
    
    model = sklearn.neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

rmse_val = []
for K in range(20):
    K = K+1
    
    model = sklearn.neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

for K in range(20):
    K = K+1
    
    model = neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

curve = pd.DataFrame(rmse_val)
curve.plot() # k에 따른 rmse 곡선
plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')

import numpy as np
xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')  

K
K=4
model = neighbors.KNeighborsRegressor(n_neighbors = K)
model.fit(train_x, train_y)
pred = model.predict(test_x)
error = sqrt(mean_squared_error(test_y, pred))
error
plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')
plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')

import numpy as np
xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')    

rmse_val
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):    


# log파일 분할시키기
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor  
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    #Step부터 end col factor까지 numeric으로 타입 
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_1.Time = pd.to_datetime(df.Time) # 타입 변환
    df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_1.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_1 = df_1[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 특정 Step 값만 가져오기
    
    # 6Step만 선택 - Depo Step
    df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 사전 정의 - based on domain knowledge
    Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
                 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  
    
    #Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
    #              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
    df_3 = df_2[Gas_Input]
    
    df_3['Delivery_Power'] = df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']
    
    del df_3['HF_FORWARD_A']
    del df_3['HF_REFLECT_A']
    
    # Factor들 이름만 가져옴
    answer = df_3.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_3.mean()
    answer_median = answer + '_median'
    value_median = df_3.median()
    answer_std = answer + '_std'
    value_std = df_3.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master = pd.concat([master, temp_master])


# Temp 추출

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    df_temp = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df_temp.loc[i-12] = temp
    
    df_4 = df_temp.loc[:,'Recipe_Step_Number':(df_temp.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    df_4.Time = pd.to_datetime(df_temp.Time) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
    
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    # 6Step만 선택
    df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 사전 정의
    Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    #Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Impedence 계산
    # df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) 
    # sqrt 쓰면 cannot convert the series to <class 'float'> 오류남
    
    df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)
    
    del df_6['HF_R_A']
    del df_6['HF_X_A']
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])


## ---(Fri Feb  7 10:45:44 2020)---
from wafer_map import wm_app
wm_app.WaferMapApp(data, 9,(1,1),(0,0),150)
data = [(0,0, 1969.493), 
        (0,95,2014.453),
        (-67.1751,	67.1751,	1000),
        (-95,	0,	2015.6959),
        (-67.1751,	-67.1751,	2014.524),
        (0	,-95,	2014.9785),
        (67.1751,	-67.1751,	2041.684),
        (95,	0,	2043.2437),
        (67.1751,	67.1751,2041.6567)
        ]
wm_app.WaferMapApp(data, 9,(1,1),(0,0),150)
wm_app.WaferMapApp(data, (9,9),(1,1),(0,0),150)
wm_app.WaferMapApp(data, (1,1),(0,0),150)
from wafer_map import wm_app
data = [(0,0, 1969.493), 
        (0,95,2014.453),
        (-67.1751,	67.1751,	1000),
        (-95,	0,	2015.6959),
        (-67.1751,	-67.1751,	2014.524),
        (0	,-95,	2014.9785),
        (67.1751,	-67.1751,	2041.684),
        (95,	0,	2043.2437),
        (67.1751,	67.1751,2041.6567)
        ]
wm_app.WaferMapApp(data, (1,1),(0,0),150)
import numpy
data_1 = np.array([[ 0. ,  0. ,  1. ,  1. ,  0. ,  0. ],
       [ 0. ,  1. ,  1. ,  1. ,  1. ,  0. ],
       [ 1. ,  2. ,  0.1,  2. ,  2. ,  1. ],
       [ 1. ,  2. ,  2. ,  0.1,  2. ,  1. ],
       [ 0. ,  1. ,  1. ,  1. ,  1. ,  0. ],
       [ 0. ,  0. ,  1. ,  1. ,  0. ,  0. ]])
import numpy as np
data_1 = np.array([[ 0. ,  0. ,  1. ,  1. ,  0. ,  0. ],
       [ 0. ,  1. ,  1. ,  1. ,  1. ,  0. ],
       [ 1. ,  2. ,  0.1,  2. ,  2. ,  1. ],
       [ 1. ,  2. ,  2. ,  0.1,  2. ,  1. ],
       [ 0. ,  1. ,  1. ,  1. ,  1. ,  0. ],
       [ 0. ,  0. ,  1. ,  1. ,  0. ,  0. ]])
plt.figure(1)
import matplotlib
plt.figure(1)
import matplotlib as mpl
import matplotlib.pylab as plt
plt.figure(1)
plt.imshow(data_1 ,interpolation='none')
plt.colorbar()
plt.figure(1)
plt.colorbar()
plt.imshow(data_1 ,interpolation='gaussian')

## ---(Mon Feb 10 14:06:42 2020)---
from wafer_map import wm_app
data = [(0,0, 1969.493), 
        (0,95,2014.453),
        (-67.1751,	67.1751,	1000),
        (-95,	0,	2015.6959),
        (-67.1751,	-67.1751,	2014.524),
        (0	,-95,	2014.9785),
        (67.1751,	-67.1751,	2041.684),
        (95,	0,	2043.2437),
        (67.1751,	67.1751,2041.6567)
        ]
df = pd.read_excel(r'C:\Users\wtjang\Documents\work\aleries.csv')
import pandas as pd
df = pd.read_excel(r'C:\Users\wtjang\Documents\work\aleries.csv')
df = pd.read_csv(r'C:\Users\wtjang\Documents\work\aleries.csv')
df[1]
df.loc[1]
df_data = []
length(df)
size(df
)
row(df)
len(df)
df.loc[1]
df.loc[0]
for i in range(len(df)):
    df_data.append(df.loc[i])

df_1 = df.values.tolist()
wm_app.WaferMapApp(df_1, (1,1),(0,0),150)
wm_app.WaferMapApp(df_1,150, (1,1),(0,0),150)
wm_app.WaferMapApp(df_1,(150,150), (1,1),(0,0),150)
wm_app.WaferMapApp(df_1, # data
                   (150,150),  #die size
                   (0,0), # center_xy
                   (0,0),
                   150)
wm_app.WaferMapApp(df_1, # data
                   ,  #die size
                   (0,0), # center_xy
                   (0,0),
                   150)
wm_app.WaferMapApp(df_1, # data
                   0,  #die size
                   (0,0), # center_xy
                   150, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(df_1, # data
                     #die size
                   (0,0), # center_xy
                   150, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(df_1, # data
                     (0,0)#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(df_1, # data
                    0,#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(df_1, # data
                    (0,0),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(df_1, # data
                    (150,150),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(df_1, # data
                    (300,300),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   0,
                   0)
%clear
from wafer_map import wm_app
import pandas as pd
df = pd.read_csv(r'C:\Users\wtjang\Documents\work\aleries.csv')
df_1 = df.values.tolist()
data = df_1
wm_app.WaferMapApp(data, # data
                    (300,300),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (100,100),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (1,1),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    1,#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (2,2),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (2,2),#die size
                   (0,0), # center_xy
                   290, #dia : the wafer diameter
                   0,
                   0)
%clear
from wafer_map import wm_app




import pandas as pd
df = pd.read_csv(r'C:\Users\wtjang\Documents\work\aleries.csv')



# dataframe의 row를 list로 변환
data = df.values.tolist() # 49point 

wm_app.WaferMapApp(data, # data
                    (3,3),#die size
                   (0,0), # center_xy
                   290, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (3.3,3.3),#die size
                   (0,0), # center_xy
                   290, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (2.7,2.7),#die size
                   (0,0), # center_xy
                   290, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (2.95,2.95),#die size
                   (0,0), # center_xy
                   290, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (10,10),#die size
                   (0,0), # center_xy
                   290, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (50,50),#die size
                   (0,0), # center_xy
                   290, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (1,1),#die size
                   (0,0), # center_xy
                   290, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (1.2,1.2),#die size
                   (0,0), # center_xy
                   290, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (0.8,0.8),#die size
                   (0,0), # center_xy
                   290, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (1,1),#die size
                   (0,0), # center_xy
                   290, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (1,1),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   0,
                   0)
wm_app.WaferMapApp(data, # data
                    (1,1),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
data.append([0,1,3000])
wm_app.WaferMapApp(data, # data
                    (1,1),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
data.append([0,12,3000])
wm_app.WaferMapApp(data, # data
                    (1,1),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
data.append([0,11.5,2000])
wm_app.WaferMapApp(data, # data
                    (1,1),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
data.append([0,10,2000])
data.append([0,100,2000])
data.append([0,200,2000])
data.append([0,300,2000])
wm_app.WaferMapApp(data, # data
                    (1,1),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
data = df.values.tolist() # 49point 
data.append([0,10,3000])
data.append([0,100,3000])
wm_app.WaferMapApp(data, # data
                    (1,1),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
data.append([0,150,3000])
wm_app.WaferMapApp(data, # data
                    (1,1),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
wm_app.WaferMapApp(data, # data
                    (2,2),#die size
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
wm_app.WaferMapApp(data, # data
                    (1,1),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
wm_app.WaferMapApp(data, # data
                    (1,1),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
xyz = []
for i in range(150):
    for j in range(150):
        xyz.append([i,j,i])

wm_app.WaferMapApp(xyz, # data
                    (1,1),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
for i in range(150):
    for j in range(150):
        xyz.append([i,j,100])

wm_app.WaferMapApp(xyz, # data
                    (1,1),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
for i in range(1,150):
    for j in range(1,150):
        xyz.append([i,j,100])

wm_app.WaferMapApp(xyz, # data
                    (1,1),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
for i in range(1,150):
    for j in range(1,150):
        xyz.append([i,j,i])

wm_app.WaferMapApp(xyz, # data
                    (1,1),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
for i in range(-150,150):
    for j in range(-150,150):
        xyz.append([i,j,i])

wm_app.WaferMapApp(xyz, # data
                    (1,1),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
for i in range(0,150):
    for j in range(0,150):
        xyz.append([i,j,i])

for i in range(0,150):
    for j in range(0,150):
        xyz.append([i,j,i])

for i in range(0,100):
    for j in range(0,100):
        xyz.append([i,j,i])

wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
xyz = []

for i in range(0,10):
    for j in range(0,10):
        xyz.append([i,j,i])

wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
from wafer_map import wm_app




import pandas as pd
wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
for i in range(-10,10):
    for j in range(-10,10):
        xyz.append([i,j,j])

wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
for i in range(-30,30):
    for j in range(-30,30):
        xyz.append([i,j,j])

wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
for i in range(-40,40):
    for j in range(-40,40):
        xyz.append([i,j,j])

wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
for i in range(-35,35):
    for j in range(-35,35):
        xyz.append([i,j,j])

k=35
for i in range(-k,k):
    for j in range(-k,k):
        xyz.append([i,j,j])

wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
k=25

for i in range(-k,k):
    for j in range(-k,k):
        xyz.append([i,j,j])





wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
k=20

for i in range(-k,k):
    for j in range(-k,k):
        xyz.append([i,j,j])





wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
k=15

for i in range(-k,k):
    for j in range(-k,k):
        xyz.append([i,j,j])





wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)


wm_app.WaferMapApp()
k=10

for i in range(-k,k):
    for j in range(-k,k):
        xyz.append([i,j,j])





wm_app.WaferMapApp(xyz, # data
                    (3,3),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
wm_app.WaferMapApp(xyz, # data
                    (10,10),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)


wm_app.WaferMapApp()
for i in range(-5,5):
    for j in range(-5,5):
        xyz.append([i,j,j])

for i in range(-5,5):
    for j in range(-5,5):
        xyz.append([i,j,j])

xyz = []


for i in range(-5,5):
    for j in range(-5,5):
        xyz.append([i,j,j])

wm_app.WaferMapApp(xyz, # data
                    (1,1),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
xyz = []
k=10

for i in range(-k,k):
    for j in range(-k,k):
        xyz.append([i,j,j])





wm_app.WaferMapApp(xyz, # data
                    (1,1),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
xyz = []
k=20

for i in range(-k,k):
    for j in range(-k,k):
        xyz.append([i,j,j])





wm_app.WaferMapApp(xyz, # data
                    (1,1),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
xyz = []
k=20

for i in range(-k,k):
    for j in range(-k,k):
        xyz.append([i,j,j])





wm_app.WaferMapApp(xyz, # data
                    (10,10),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)


wm_app.WaferMapApp()
wm_app.WaferMapApp(xyz, # data
                    (5,5),#die size (1,1)로 해야지 반지름 150mm 인걸로 만들 수 있음
                   (0,0), # center_xy
                   300, #dia : the wafer diameter
                   edge_excl = 0,
                   flat_excl = 0)
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
data_1 = np.array([[ 0. ,  0. ,  1. ,  1. ,  0. ,  0. ],
       [ 0. ,  1. ,  1. ,  1. ,  1. ,  0. ],
       [ 1. ,  2. ,  0.1,  2. ,  2. ,  1. ],
       [ 1. ,  2. ,  2. ,  0.1,  2. ,  1. ],
       [ 0. ,  1. ,  1. ,  1. ,  1. ,  0. ],
       [ 0. ,  0. ,  1. ,  1. ,  0. ,  0. ]])
plt.figure(1)
plt.imshow(data_1 ,interpolation='gaussian')
plt.colorbar()
df = pd.DataFrame(index=range(0,10))    
df.loc[1,1
]
df.loc[0,0]
for i in range(-k,k):
    for j in range(-k,k):
        df.loc[i,j] = i+j

plt.figure(1)
plt.imshow(df ,interpolation='gaussian')
plt.colorbar()
plt.imshow(df ,interpolation='none')
plt.figure(1)
plt.imshow(df ,interpolation='gaussian')
plt.colorbar()

k=10

for i in range(-k,k):
    for j in range(-k,k):
        df.loc[i,j] = i+j





plt.figure(1)
plt.imshow(df ,interpolation='gaussian')
plt.colorbar()
df = pd.DataFrame(index=range(0,10))    
k=10

for i in range(-k,k):
    for j in range(-k,k):
        df.loc[i,j] = i+j

plt.figure(1)
plt.imshow(df ,interpolation='gaussian')
plt.colorbar()
df = pd.DataFrame(index=range(0,10))    
df = pd.DataFrame(index=range(0,0))    
k=100

for i in range(-k,k):
    for j in range(-k,k):
        df.loc[i,j] = i+j

plt.figure(1)
plt.imshow(df ,interpolation='gaussian')
plt.colorbar()
df = pd.DataFrame(index=range(0,0))    
k=300

for i in range(0,k):
    for j in range(0,k):
        df.loc[i,j] = i+j

plt.figure(1)
plt.imshow(df ,interpolation='gaussian')
plt.colorbar()
df = pd.read_csv(r'C:\Users\wtjang\Documents\work\aleries.csv')
plt.figure(1)
plt.imshow(df ,interpolation='gaussian')
plt.colorbar()
df_2 = df.loc[0:8]
df_2['X']  = df['X'] +150
df_2['Y']  = df['Y'] +150
final = pd.concat([df_2, df_2, df_2,axis = 1)
final = pd.concat([df_2, df_2, df_2],axis = 1)
plt.figure(1)
plt.imshow(final ,interpolation='gaussian')
plt.colorbar()
plt.imshow(final ,interpolation='none')
plt.imshow(final ,interpolation='hanning')
plt.figure(1)
plt.imshow(final ,interpolation='hanning')
plt.colorbar()
plt.figure(1)
plt.imshow(final ,interpolation='hanning')
plt.colorbar()
plt.figure(1)
plt.imshow(final ,interpolation='hanning')
plt.colorbar()
pylab.pcolor(v, r, z, cmap='jet')
import pylab
pylab.pcolor(v, r, z, cmap='jet')
plt.imshow(final ,interpolation='hanning')
plt.imshow(final ,interpolation='hanning',cmap=cm.jet)
plt.imshow(final ,interpolation='hanning',cmap=jet)
plt.imshow(final ,interpolation='hanning',cmap = seismic)
plt.imshow(final ,interpolation='hanning',cmap = 'seismic')
plt.imshow(final ,interpolation='hanning',cmap = 'coolwarm')
plt.imshow(final ,interpolation='hanning',cmap = 'seismic')
plt.colorbar()
plt.imshow(final ,interpolation='hanning',cmap = 'seismic')
plt.colorbar()
test = pd.DataFrame(index=range(0,0))     # 빈데이터 프레임
test = pd.DataFrame(index=range(10,10))     # 빈데이터 프레임
test = pd.DataFrame(index=range(0,10))     # 빈데이터 프레임
i=1
i^2
i=2
i**2
j=2
(i**2 + j**2)
(i**2 + j**2) < 25
for i in range(0,10):
    for j in range(0,10):
        if (i**2 + j**2) < 25:
            test.loc[i,j] = 1

test = pd.DataFrame(index=range(0,10), columns=range(0,10))     # 빈데이터 프레임
for i in range(0,10):
    for j in range(0,10):
        if ((4-i)**2 + (4-j)**2) < 25:
            test.loc[i,j] = 1

for i in range(0,11):
    for j in range(0,11):
        if ((5-i)**2 + (5-j)**2) < 25:
            test.loc[i,j] = 1

test = pd.DataFrame(index=range(0,11), columns=range(0,11))     # 빈데이터 프레임
for i in range(0,11):
    for j in range(0,11):
        if ((5-i)**2 + (5-j)**2) < 25:
            test.loc[i,j] = 1

plt.figure(1)
plt.imshow(test ,interpolation='hanning',cmap = 'seismic')
plt.colorbar()  
for i in range(0,11):
    for j in range(0,11):
        if ((5-i)**2 + (5-j)**2) < 25:
            test.loc[i,j] = 1
        else:
            test.loc[i,j] = 0

plt.figure(1)
plt.imshow(test ,interpolation='hanning',cmap = 'seismic')
plt.colorbar()       
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     # 빈데이터 프레임



for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 100:
            test.loc[i,j] = 1
        else:
            test.loc[i,j] = 0

plt.figure(1)
plt.imshow(test ,interpolation='hanning',cmap = 'seismic')
plt.colorbar()   
test = pd.DataFrame(index=range(0,301), columns=range(0,301))     # 빈데이터 프레임



for i in range(0,301):
    for j in range(0,301):
        if ((150-i)**2 + (150-j)**2) < 150**2:
            test.loc[i,j] = 1
        else:
            test.loc[i,j] = 0

plt.figure(1)
plt.imshow(test ,interpolation='hanning',cmap = 'seismic')
plt.colorbar()     
test = pd.DataFrame(index=range(0,301), columns=range(0,301))     # 빈데이터 프레임
for i in range(0,301):
    for j in range(0,301):
        if ((150-i)**2 + (150-j)**2) < 150**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

plt.figure(1)
plt.imshow(test ,interpolation='hanning',cmap = 'seismic')
plt.colorbar()       
import numpy as np
data_masked = np.ma.masked_where(data == 0, data)
data_masked = np.ma.masked_where(test == 0, data)
data_masked = np.ma.masked_where(data == 0, test)
test[test == 0] = np.nan
plt.imshow(test, interpolation = 'none', vmin = 0)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'seismic')
import numpy as np
test[test == 0] = np.nan
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'seismic')
plt.colorbar() 
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist-rainbow')
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow')
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow')
plt.colorbar() 
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
import tkinter
calc = tk.Tk()
import tkinter as tk
calc = tk.Tk()
calc.mainloop()
calc.title("Wtjang Calculator")
import tkinter as tk

calc = tk.Tk()
calc.mainloop()


calc.title("Wtjang Calculator")
calc = tk.Tk()
calc.mainloop()
calc.title("Wtjang Calculator")
calc.geometry("300*300")
calc.title("Calculator")
calc = tk.Tk()
calc.mainloop()
calc.title("Calculator")
calc = tk.Tk()
calc.mainloop()


calc.title("Calculator")
display = tk.Entry(calc, width=20)
calc = tk.Tk()
calc.mainloop()
display = tk.Entry(calc, width=20)
%clear
from tkinter import *
from tkinter import ttk
root = Tk()
root.title("wtjang")
root.geometry("200x200")
root.mainloop()
number_entry = ttk.Entry(root, width=20)
root = Tk()

root.title("wtjang")
root.geometry("200x200")

root.mainloop()
number_entry = ttk.Entry(root, width=20)
from tkinter import *
from tkinter import ttk

root = Tk()

root.title("wtjang")
root.geometry("200x200")




number_entry = ttk.Entry(root, width=20)
number_entry.grid(row=0, columnspan=1)


root.mainloop()
root = Tk()

root.title("wtjang")
root.geometry("200x200")




number_entry = ttk.Entry(root, width=20)
number_entry.grid(row=0, columnspan=1)



button1 = ttk.Button(root, text="200")
button1.grid(row=1, column=0)

root.mainloop()
from PyQt4.uic import loadUiType
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
Ui_MainWindow, QMainWindow = loadUiType('window.ui')
$ pyuic window.ui > window.py
pyuic window.ui > window.py
Ui_MainWindow, QMainWindow = loadUiType('window.ui')
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)


if __name__ == '__main__':
    import sys
    from PyQt4 import QtGui
    
    app = QtGui.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui
    
    app = QtGui.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())

rom PyQt5 import QtWidgets 
from PyQt5 import QtWidgets 
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())

%clear
from PyQt5.uic import loadUiType

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


#경로 주소 삽입
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')
from PyQt5 import QtWidgets 
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())
import numpy as np
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())
%clear
from PyQt5.uic import loadUiType

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


#경로 주소 삽입
# The loadUiType function requires a single argument, the name of a Designer UI file
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')
import numpy as np
from PyQt5 import QtWidgets 
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
%clear
from PyQt5.uic import loadUiType

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


#경로 주소 삽입
# The loadUiType function requires a single argument, the name of a Designer UI file
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')


import numpy as np
from PyQt5 import QtWidgets 
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtGui.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
from PyQt5.uic import loadUiType

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


#경로 주소 삽입
# The loadUiType function requires a single argument, the name of a Designer UI file
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')


import numpy as np
from PyQt5 import QtWidgets 
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == '__main__':
    import sys
    from PyQt5 import QtGui

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
app = QtWidgets.QApplication(sys.argv)
main = Main()
from PyQt5.uic import loadUiType

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


#경로 주소 삽입
# The loadUiType function requires a single argument, the name of a Designer UI file
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')


import numpy as np
from PyQt5 import QtWidgets 
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
%clear
from PyQt5.uic import loadUiType

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


#경로 주소 삽입
# The loadUiType function requires a single argument, the name of a Designer UI file
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')


import numpy as np
from PyQt5 import QtWidgets 
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
test = pd.DataFrame(index=range(0,301), columns=range(0,301))     # 빈데이터 프레임



for i in range(0,301):
    for j in range(0,301):
        if ((150-i)**2 + (150-j)**2) < 150**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test = pd.DataFrame(index=range(0,301), columns=range(0,301))     # 빈데이터 프레임
import pandas as pd 
test = pd.DataFrame(index=range(0,301), columns=range(0,301))     # 빈데이터 프레임
for i in range(0,301):
    for j in range(0,301):
        if ((150-i)**2 + (150-j)**2) < 150**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

plt.figure(1)
import matplotlib as mpl
import matplotlib.pylab as plt
plt.figure(1)
plt.imshow(test ,interpolation='hanning',cmap = 'seismic')
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
test[test == 0] = np.nan
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()    
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()    
fig1 = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
fig1
from PyQt5.uic import loadUiType

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')


import numpy as np
from PyQt5 import QtWidgets 


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
   
   # fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111)
    #ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     # 빈데이터 프레임

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
plt.figure(1)

fig1 = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')

plt.colorbar()    
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
plt.figure(1)

fig1 = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')

plt.colorbar()    
fig1
from PyQt5.uic import loadUiType

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


#경로 주소 삽입
# The loadUiType function requires a single argument, the name of a Designer UI file
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')


import numpy as np
from PyQt5 import QtWidgets 


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
   
   # fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111)
    #ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
   
   # fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111)
    #ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'))
    main.show()
    sys.exit(app.exec_())

import numpy as np
from PyQt5 import QtWidgets 


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

app = QtWidgets.QApplication(sys.argv)
main = Main()
main.addmpl(fig1)
main.show()
fig1 = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
plt.figure(1)

fig1 = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')

plt.colorbar()    
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     # 빈데이터 프레임

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
plt.figure(1)

plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')

plt.colorbar()  
from PyQt5.uic import loadUiType

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


#경로 주소 삽입
# The loadUiType function requires a single argument, the name of a Designer UI file
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')


import numpy as np
from PyQt5 import QtWidgets 


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

ax1f1 = fig1.add_subplot(111)
fig1 = Figure()
ax1f1 = fig1.add_subplot(111)
ax1f1
ax1f1.plot
ax1f1.plot(np.random.rand(5))
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
fig1 = Figure()
ax1f1 = fig1.add_subplot(111)
ax1f1
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
fig1 = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
fig1
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
%clear
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     # 빈데이터 프레임

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')

import numpy as np
from PyQt5 import QtWidgets 

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

fig1 = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot()
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111)
    ax1f1.plot()
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111)
    fig1.plot()
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    ax1f1 = fig1
    fig1.plot()
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    ax1f1 = fig1
    ax1f1.plot()
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    ax1f1 = fig1
    ax1f1.imshow()
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
Ui_MainWindow
import numpy as np
from PyQt5 import QtWidgets 

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

ax1f1
ax1f1.figure
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    ax1f1 = fig1
    ax1f1.figure()
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    ax1f1 = fig1
    ax1f1.figure()
fig1
fig1.imshow()
ax1f1.imshow()
ax1f1
ax1f1.hitlist
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    #ax1f1 = fig1
    #ax1f1.figure()
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(ax1f1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    ax1f1 = fig1
    #ax1f1.figure()
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(ax1f1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1
    ax1f1.figure()
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(ax1f1)
    main.show()
    sys.exit(app.exec_())

if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(ax1f1)
    main.show()
    sys.exit(app.exec_())
%clear
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     # 빈데이터 프레임

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')

import numpy as np
from PyQt5 import QtWidgets 

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(ax1f1)
    main.show()
    sys.exit(app.exec_())
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')

import numpy as np
from PyQt5 import QtWidgets 

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.plot(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())

if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.imshow(np.random.rand(5))
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     # 빈데이터 프레임

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()    

#fig1 = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')

import numpy as np
from PyQt5 import QtWidgets 

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     # 빈데이터 프레임

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()    

#fig1 = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)

#경로 주소 삽입
# The loadUiType function requires a single argument, the name of a Designer UI file
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')

import numpy as np
from PyQt5 import QtWidgets 

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    #fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    #ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
%clear
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     # 빈데이터 프레임

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()    

#fig1 = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\.spyder-py3\window.ui')

import numpy as np
from PyQt5 import QtWidgets 

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\window.ui')

import numpy as np
from PyQt5 import QtWidgets 

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     # 빈데이터 프레임

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()    

#fig1 = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\window.ui')

import numpy as np
from PyQt5 import QtWidgets 

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()


if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets

# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
# 컬러맵 cmap 속성에서 _r붙이면 reverse 효과
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
import sys
from PyQt5.QtWidgets import *  
class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 300)
        self.setWindowTitle("PyStock v0.1")
        
        self.pushButton = QPushButton("File Open")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self)
        self.label.setText(fname[0])   

 if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets
# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
# 컬러맵 cmap 속성에서 _r붙이면 reverse 효과
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
%clear
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0




import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
#plt.figure(1)
#plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
#plt.colorbar()    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

# 경로 주소 삽입
# The loadUiType function requires a single argument, the name of a Designer UI file

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\window.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 300)
        self.setWindowTitle("PyStock v0.1")
        
        self.pushButton = QPushButton("File Open")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self)
        self.label.setText(fname[0])    



 if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets
# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
# 컬러맵 cmap 속성에서 _r붙이면 reverse 효과
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())

 if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets
# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
# 컬러맵 cmap 속성에서 _r붙이면 reverse 효과
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())

 if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets
# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
# 컬러맵 cmap 속성에서 _r붙이면 reverse 효과
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())


import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0




import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
#plt.figure(1)
#plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
#plt.colorbar()    



from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\window.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()





import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 300)
        self.setWindowTitle("PyStock v0.1")
        
        self.pushButton = QPushButton("File Open")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self)
        self.label.setText(fname[0])    


 if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets
# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
# 컬러맵 cmap 속성에서 _r붙이면 reverse 효과
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())

import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 300)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self)
        self.label.setText(fname[0])    

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

 if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets
# error  name 'QtWidgets' is not defined  -> QtGui.QApplication([" "]) ->  QtWidgets.QApplication([" "]) 으로 변경
# 컬러맵 cmap 속성에서 _r붙이면 reverse 효과
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())
%clear
import sys
from PyQt5.QtWidgets import *    
class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 300)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self)
        self.label.setText(fname[0])    

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 300)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self)
        self.label.setText(fname[0])    



if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()


import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 300)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self)
        self.label.setText(fname[0])    



if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self)
        self.label.setText(fname[0])    



if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self)
        self.label.setText(fname[0])    



if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()



import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Ecel Files(*.csv)", '/home')
        self.label.setText(fname[0])    

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Ecel Files(*.csv)", '/home')
        self.label.setText(fname[0])    

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()


import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        #self.label.setText(fname[0])    
        if fname[0]:
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")






if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()


import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        #self.label.setText(fname[0])    
        if fname[0]:
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")






if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()


conda clean -tipsy
import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        #self.label.setText(fname[0])    
        if fname[0]:
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")





if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()


%clear
import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        #self.label.setText(fname[0])    
        if fname[0]:
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")





if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

flines
class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if fname[0]:
    f = open(fname[0], 'r')
    flines = f.readlines()
    
    for line in flines:
        print(line)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()


%clear
import sys
from PyQt5.QtWidgets import *    
class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        #self.label.setText(fname[0])    
        if fname[0]:
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()


import sys
from PyQt5.QtWidgets import *    


class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        #self.label.setText(fname[0])    
        if fname[0]:
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()


## ---(Thu Feb 13 13:55:52 2020)---
import sys
from PyQt5.QtWidgets import *    
import sys
from PyQt5.QtWidgets import *  
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

class MyWindow(QWidget):

class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

import sys
from PyQt5.QtWidgets import *    
class MyWindow(QWidget):

class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setupUI()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 




Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()

import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 




Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()

import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()

import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0



import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

test[test == 0] = np.nan
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt
test[test == 0] = np.nan
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()
    
    
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')

import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0



import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()
    
    
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()
    
    
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()
    
    
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())


%clear
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0



import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()
    
    
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.addmpl(fig1)
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    
    
    
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()



import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0



import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

if __name__ == "__main__":
    
    
    
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    
    
    
    
    
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()


import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0



import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    
    
    
    
    
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def setupUI(self):
        self.setGeometry(800, 200, 300, 500)
        self.setWindowTitle("test")
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        layout = QVBoxLayout()
        layout.addWidget(self.pushButton)
        layout.addWidget(self.label)
        
        self.setLayout(layout)
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()

import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()

import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    def setupUI(self):
        
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()



import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    def setupUI(self):
        
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()


import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    def setupUI(self):
        
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
    
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()


import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    def setupUI(self):
        
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
    
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()

%clear
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
Ui_MainWindow
class Main(QMainWindow, Ui_MainWindow):
   def __init__(self):
        super().__init__()
        self.setupUI()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    def setupUI(self):
        
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
    
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    def setupUI(self):
        
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
    
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()

import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUI()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    def setupUI(self):
        
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
    
    
    def pushButtonClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()


import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
Ui_MainWindow
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    def setupUI(self):
        
        self.setWindowTitle("test")
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
    
    
    
    
    def setupUI(self):
        
        
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)
        self.label = QLabel()
        
        
        
        self.setLayout(layout)

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()

import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)

app = QApplication(sys.argv)
window = Main()
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)

app = QApplication(sys.argv)
window = Main()
window.show()
app.exec_()
%clear
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    def setupUI(self):
        
        self.setWindowTitle("test")
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()

import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas) #mplvl
        self.canvas.draw()
    
    
    def setupUI(self):
        
        self.setWindowTitle("test")
        self.pushButton = QPushButton("File Open_test")
        self.pushButton.clicked.connect(self.pushButtonClicked)

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QApplication(sys.argv)
    window = Main()
    window.show()
    app.exec_()


%clear
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())




import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)







if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())


import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show(ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'))
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show(ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'))
    sys.exit(app.exec_())

import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0



import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show(ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'))
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0



import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    main.show()
    sys.exit(app.exec_())

ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0



import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0



import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    main.show()
    sys.exit(app.exec_())



import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

main = Main()

main.addmpl(fig1)

main.show()
sys.exit(app.exec_())
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()



if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan  
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    main.show()
    sys.exit(app.exec_())


fig1 = Figure()
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

%clear
import pandas as pd 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
import pandas as pd 
import numpy as np
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    main.show()
    sys.exit(app.exec_())


%clear
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     

for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    main.show()
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    main.show()
    sys.exit(app.exec_())

import matplotlib.image as img
CI_Name = r"C:\Users\wtjang\Wafer viewer"
CI_Path = r"C:\Users\wtjang\Wafer viewer"
CI = img.imread(CI_Path)
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = img.imread(CI_Path)
CI
CI.imshow()
CI.imag
CI.view
CI.imag
import PIL.Image as pilimg
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = piling.open(CI_Path)
import PIL.Image as pilimg
CI = pilimg.open(CI_Path)
CI.show()
pix = np.array(CI)
plt.imshow(pix)
plt.figure(figsize = (20,2))
plt.imshow(pix)
plt.figure(figsize = (20,20))
plt.imshow(pix)
plt.imshow(CI)
pix
plt.imshow(CI)
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl4.addWidger(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidger(self.canvas)
        self.canvas.draw()


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
plt.imshow(pix)
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidger(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
plt.imshow(pix)



"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())





import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
plt.imshow(pix)



"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

%clear
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
plt.imshow(pix)



"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
plt.imshow(pix)



"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())


%clear
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
plt.imshow(pix)



"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

%clear
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
plt.imshow(pix)



"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
plt.imshow(pix)



"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.add_subplot(111) 
    #ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        #self.mplvl_4.addWidget(self.canvas)
        #self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.add_subplot(111) 
    #ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
plt.imshow(pix)



"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        #self.mplvl_4.addWidget(self.canvas)
        #self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.add_subplot(111) 
    #ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        #self.mplvl_4.addWidget(self.canvas)
        #self.canvas.draw()


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.add_subplot(111) 
    #ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        #self.mplvl_4.addWidget(self.canvas)
        #self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.add_subplot(111) 
    #ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
plt.imshow(pix)



"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        #self.mplvl_4.addWidget(self.canvas)
        #self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.add_subplot(111) 
    #ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

%clear
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
#plt.imshow(pix)

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    #x1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    #x1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
import matplotlib.image as img
import PIL.Image as pilimg

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
CI = pilimg.open(CI_Path)

pix = np.array(CI)
#plt.imshow(pix)



"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    #x1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

plt.imshow(pix)
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

plt.imshow(pix)
plt.imshow(CI)
CI.im
CI.show
CI.width
im.show(CI)
CI.imshow()
im = Image.open(CI_Path)
from PIL import Image
im = Image.open(CI_Path)
im.show()
%clear
import matplotlib.image as mpimg
img = mpimg.imread(CI_Path)
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
img = mpimg.imread(CI_Path)
imgplot = plt.imshow(img)
import matplotlib.pylab as plt    
imgplot = plt.imshow(img)
im = Image.open(CI_Path)
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)
im.show()
plt.imag()
plt.imag(im)
im.show()
plt.imag(im)
plt.imshow(im)
plt.axis('off')
im.show()
plt.imshow(im)
plt.imshow(im, axis = 'off')
plt.imshow(im)
plt.axis('off')
plt.imshow(im)
im.show(im)
imshow(im)
plt.imshow(im)
im.show()
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)
plt.axis('off')
plt.imshow(im)
plt.axis('off')
plt.imshow(im)
test = plt.omshow(im)
test = plt.imshow(im)
test
test = plt.imshow(im); plt.axis('off')
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)
CI = plt.imshow(im); plt.axis('off')
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(CI)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

ax1f4.imshow(CI)
plt.imshow(CI, clim=(0.064, 0.068))
mod_img = ndimage.median_filter(CI,20)
CI
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)
im
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    #ax1f4 = fig4.add_subplot(111) 
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"

im = Image.open(CI_Path)










"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())


im
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.axes()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

im
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.axes()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    #ax1f4 = fig4()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        #self.canvas = FigureCanvas(fig)
        #self.mplvl_4.addWidget(self.canvas)
        #self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"

im = Image.open(CI_Path)










"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        #self.canvas = FigureCanvas(fig)
        #self.mplvl_4.addWidget(self.canvas)
        #self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"

im = Image.open(CI_Path)










"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"

im = Image.open(CI_Path)










"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    #main.addmpl(fig1)
    main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"

im = Image.open(CI_Path)










"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 



"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image

CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"

im = Image.open(CI_Path)










"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
        
        
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    #main.addmpl(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

ax1f4.imshow(im)
ㅑㅡ
im
ax1f4.imshow(im)
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

Figure(im)
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

im
fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
fig4 = Figure()
ax1f4 = fig4.gca()
ax1f4.imshow(im)
ax1f4.imshow(im)
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())


runfile('C:/Users/wtjang/Wafer viewer/wafer_viewer.py', wdir='C:/Users/wtjang/Wafer viewer')
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : grey;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #plt.colorbar()  

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #plt.colorbar()  
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    
    fig4 = Figure()
    ax1f4 = fig4.gca()
    ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

%clear
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : grey;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #plt.colorbar()  
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #plt.colorbar()  
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : grey;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #plt.colorbar()  
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())


plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()    
ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r') ; plt.colorbar()
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    ax1f1 = fig1.add_subplot2grid(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    ax1f1 = plt.add_subplot2grid(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    ax1f1 = plt.subplot2grid(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

fig1 = plt.figure(0)
ax1f1 = plt.subplot2grid(111) 
ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
ax1f1.colorbar()
%clear
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    fig1 = plt.figure(0)
    
    ax1f1 = plt.subplot2grid(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
        
        
        #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())


Figure()
plt.figure(0)
plt.figure(1)
plt.figure()
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); 
plt.colorbar()
temp = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); plt.colorbar()  
temp
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    #ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
        
        
        #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(temp)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

temp
figure, axes = plt.subplots()
axes.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
axes.colorbar()
temp
temp.imshow()
temp.colorbar
temp()
temp
temp.draw()
temp.draw
temp.figure
temp
axes.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    #ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
        
        
        #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(temp)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    #ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
        
        
        #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(temp)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    temp = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); plt.colorbar()  
    
    #ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    #ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
        
        
        #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(temp)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    temp = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); plt.colorbar()  
    
    #ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    #ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
        
        
        #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(temp)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    temp = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); plt.colorbar()  
    
    #ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    #ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
        
        
        #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(temp)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()



temp = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); plt.colorbar()  
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    
    
    #ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    #ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
        
        
        #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(temp)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

http://blog.rcnelson.com/building-a-matplotlib-gui-with-qt-designer-part-2/ 를 참고중
"""
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()



temp = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); plt.colorbar()  
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()



temp = plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); plt.colorbar()  
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    
    
    #ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    #ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); ax1f1.colorbar()  
        
        
        #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(temp)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    
    
    ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #ax1f1.colorbar()  
    
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(temp)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

"""
Created on Tue Feb 11 17:55:41 2020 ~

@author: wtjang
"""

"""
Wafer viewer를 개발 중입니다. 
PyQt5를 사용해서 User가 Interactive하게 사용할 수 있는 프로그램을 개발 중입니다.

http://blog.rcnelson.com/building-a-matplotlib-gui-with-qt-designer-part-2/ 를 참고중
"""
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    
    
    ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #ax1f1.colorbar()  
    
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(temp)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    
    
    ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #ax1f1.colorbar()  
    
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(temp)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    
    
    ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #ax1f1.colorbar()  
    
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    
    
    ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #ax1f1.colorbar()  
    
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r'); plt.colorbar()
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    
    
    ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    ax1f1.colorbar()  
    
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\SFX100.csv'
file_list = os.listdir(path_dir)
import os
import pandas as pd
%clear
import os
import pandas as pd
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\SFX100.csv'
file_list = os.listdir(path_dir)
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
filr_list
file_list
if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    
    
    ax1f1 = fig1.add_subplot(111) 
    #ax1f1 = fig1.add_subplot2grid(111) 
    
    #fig1 = plt.figure(0)
    
    
    #ax1f1 = plt.subplot2grid(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    #ax1f1.colorbar()  
    
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    
    #main.addmpl_2(fig2)
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

file_list
import os
import pandas as pd
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
file_list[3]
f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기
lines = f.readlines()
lines[0]
lines[0].split(',')
labels = lines[0].split(',') # line 11 : Factor  
labels
labels[0]
df = pd.DataFrame(columns = labels)
len(lines)
i=3
temp = lines[i]
temp
temp = temp.split(',')
temp
df.loc[0] = temp
%clear
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 11 : Factor  
df = pd.DataFrame(columns = labels)
i=2
temp = lines[i]
temp = temp.split(',')
temp
i=
i=2
i
temp = lines[i]
temp = temp.split(',')



df.loc[i-2] = temp
%clear
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 11 : Factor  

df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp

df_1 = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,]).name]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Meta.size
df_Meta.len
len(df_Meta)
df_Meta.loc[0]
df_Meta.loc[3]
df_Meta.columns
df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, 9):
    df_Meta_final.loc[k] = df_Meta[k*3]

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)

for k in range(0, 9):
    df_Meta_final.loc[k] = df_Meta.loc[k*3]

df_Meta['SLOT']
unique(df_Meta['SLOT'])
list(df_Meta['SLOT'])
df.Meta.loc[0,'SLOT']
df.Meta.loc[0]
df_Meta.loc[0,'SLOT']
df_Meta.loc[df_Meta.iloc[-1,:],'SLOT']
df_Meta.loc[len(df_Meta),'SLOT']
df_Meta.loc[len(df_Meta)-1,'SLOT']
(df_Meta.loc[len(df_Meta)-1,'SLOT']).type
temp_1 = df_Meta.loc[len(df_Meta)-1,'SLOT']
temp_1 + 1
int(df_Meta.loc[0,'SLOT'])
int(df_Meta.loc[0,'SLOT']) +1 
int(df_Meta.loc[len(df_Meta)-1,'SLOT']) - int(df_Meta.loc[0,'SLOT'])
num_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT']) - int(df_Meta.loc[0,'SLOT']) + 1
num_Wafer
num_feature = len(df_Meta) / num_Wafer
num_feature
num_feature + 1
%clear
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
num_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT']) - int(df_Meta.loc[0,'SLOT']) + 1
num_feature = len(df_Meta) / num_Wafer


df_Meta_final = pd.DataFrame(columns = df_Meta.columns)

for k in range(0, num_Wafer-1):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_feature]

num_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT']) - int(df_Meta.loc[0,'SLOT']) + 1
num_feature = len(df_Meta) / num_Wafer


df_Meta_final = pd.DataFrame(columns = df_Meta.columns)

for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_feature]

%clear
temp = df_Stat.T
num_first_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
num_last_Wafer = int(df_Meta.loc[0,'SLOT'])
num_first_Wafer
num_first_Wafer =int(df_Meta.loc[0,'SLOT']) 
num_first_Wafer
num_last_Wafer
num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
num_last_Wafer
num_first_Wafer
num_Wafer = num_first_Wafer - num_last_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer
num_Wafer
num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer
num_first_Wafer
num_last_Wafer
num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Wafer
num_Feature = len(df_Meta) / num_Wafer
num_Feature
df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

temp = df_Stat.T
temp
temp.loc[:,0]
temp.loc[:,0+1]
temp.loc[:,0:1]
temp.loc[:,21]
temp.loc[:,21:21+2]
num_random_Wafer = 19
temp.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
kkkk= temp.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
kkkk
df.Meta_final['SLOT'] == 19
df_Meta_final['SLOT'] == 19
df_Meta_final['SLOT'] == str(19)
df_Meta_final.loc[df_Meta_final['SLOT'] == str(19)]
iii = df_Meta_final.loc[df_Meta_final['SLOT'] == str(19)]
num_random_Wafer = 19
num_random_Wafer = 21
df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]
temp.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
temp = df_Point.T
df_Point_T = df_Point.T
num_random_Wafer = 12
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
oo = df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
len(oo)
df[df.iloc[:,-1]).name]
df[df.iloc[:,-1].name]
del df[df.iloc[:,-1].name]
%clear
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]



num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

num_random_Wafer = 12

df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]
df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
a = df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
df_Point_T = df_Point.T
b = df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()


if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    def setupTI(self):
        self.setGeometry(800,200,300,300)
        
        self.tableWidget = QTableWidget(self)
        self.tableWidget.resize(290,290)
        
        
        self.tableWidget.setRowCount(2)
        self.tableWidget.setColumnCount(2)
        self.setTableWidgetData()
    
    def setTableWidgetData(self):
        self.tableWidget.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.tableWidget.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.tableWidget.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.tableWidget.setItem(1, 1, QTableWidgetItem("(1,1)"))
    
    
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    def setupTI(self):
        self.setGeometry(800,200,300,300)
        
        self.tableWidget = QTableWidget(self)
        self.tableWidget.resize(290,290)
        
        
        self.tableWidget.setRowCount(2)
        self.tableWidget.setColumnCount(2)
        self.setTableWidgetData()
    
    def setTableWidgetData(self):
        self.tableWidget.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.tableWidget.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.tableWidget.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.tableWidget.setItem(1, 1, QTableWidgetItem("(1,1)"))
    
    
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    def setupTI(self):
        self.setGeometry(800,200,300,300)
        
        self.tableWidget = QTableWidget(self)
        self.tableWidget.resize(290,290)
        
        
        self.tableWidget.setRowCount(2)
        self.tableWidget.setColumnCount(2)
        self.setTableWidgetData()
    
    def setTableWidgetData(self):
        self.tableWidget.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.tableWidget.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.tableWidget.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.tableWidget.setItem(1, 1, QTableWidgetItem("(1,1)"))
    
    
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()





if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())


## ---(Mon Feb 17 15:04:09 2020)---
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_4(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_4.addWidget(self.canvas)
        self.canvas.draw()




if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    #fig4 = Figure()
    #ax1f4 = fig4.gca()
    #ax1f4.imshow(im)
    
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #main.addmpl_4(fig4)
    
    main.show()
    sys.exit(app.exec_())



fig1.colorbar(img)
ax1f2.plot(np.random.rand(5))
img
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()







if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    main.show()
    sys.exit(app.exec_())

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()







if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    main.show()
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()







if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    main.show()
    sys.exit(app.exec_())

pyuic test.ui > test.py
from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(921, 723)
        self.widget = QtWidgets.QWidget(Dialog)
        self.widget.setGeometry(QtCore.QRect(340, 250, 271, 171))
        self.widget.setObjectName("widget")
        
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
    
    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.exit(app.exec_())

from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())

from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
















from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.widget.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    Ui_MainWindow.addmpl(fig1)
    
    MainWindow.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
















from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.widget.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    Ui_MainWindow.addmpl(fig1)
    
    MainWindow.show()
    sys.exit(app.exec_())

img
fig1.colorbar(img)
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    Ui_MainWindow.addmpl(img)
    
    MainWindow.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
















from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.widget.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    Ui_MainWindow.addmpl(img)
    
    MainWindow.show()
    sys.exit(app.exec_())

fig1.colorbar(img)
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    
    
    
    
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    Ui_MainWindow.addmpl(img)
    
    MainWindow.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    



from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.widget.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    
    
    
    
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    Ui_MainWindow.addmpl(img)
    
    MainWindow.show()
    sys.exit(app.exec_())

import sys
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    
    Ui_MainWindow = Ui_MainWindow()
    
    
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    Ui_MainWindow.addmpl(img)
    
    MainWindow.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    



from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.widget.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    
    Ui_MainWindow = Ui_MainWindow()
    
    
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    Ui_MainWindow.addmpl(img)
    
    MainWindow.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    
    Ui_MainWindow = Ui_MainWindow()
    
    
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    ui.addmpl(img)
    
    MainWindow.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    



from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.widget.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    
    Ui_MainWindow = Ui_MainWindow()
    
    
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    ui.addmpl(img)
    
    MainWindow.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    
    Ui_MainWindow = Ui_MainWindow()
    
    
    #ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    Ui_MainWindow.addmpl(img)
    
    MainWindow.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    



from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.widget.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    
    Ui_MainWindow = Ui_MainWindow()
    
    
    #ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    Ui_MainWindow.addmpl(img)
    
    MainWindow.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    
    
    Ui_MainWindow = Ui_MainWindow()
    
    
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111)
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    Ui_MainWindow.addmpl(img)
    
    MainWindow.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    



from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.widget.addWidget(self.canvas)
        self.canvas.draw()

app = QtWidgets.QApplication(sys.argv)
MainWindow = QtWidgets.QMainWindow()
Ui_MainWindow = Ui_MainWindow()
ui = Ui_MainWindow()
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    



from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.widget.addWidget(self.canvas)
        self.canvas.draw()

app = QtWidgets.QApplication(sys.argv)
MainWindow = QtWidgets.QMainWindow()
ui = Ui_MainWindow()
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    



from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1236, 807)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(9, 9, 131, 51))
        self.pushButton.setObjectName("pushButton")
        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(160, 70, 581, 461))
        self.widget.setObjectName("widget")
        self.widget_2 = QtWidgets.QWidget(self.centralwidget)
        self.widget_2.setGeometry(QtCore.QRect(780, 70, 441, 461))
        self.widget_2.setObjectName("widget_2")
        self.mplvl_2 = QtWidgets.QGridLayout(self.widget_2)
        self.mplvl_2.setContentsMargins(0, 0, 0, 0)
        self.mplvl_2.setObjectName("mplvl_2")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(160, 10, 591, 51))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1236, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
    
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "PushButton"))
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.widget.addWidget(self.canvas)
        self.canvas.draw()

app = QtWidgets.QApplication(sys.argv)
MainWindow = QtWidgets.QMainWindow()
ui = Ui_MainWindow()
ui.setupUi(MainWindow)
fig1 = Figure()
ax1f1 = fig1.add_subplot(111)
img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
fig1.colorbar(img)
ui.addmpl(img)
%clear
"""
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()







if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    main.show()
    sys.exit(app.exec_())

"""
Wafer viewer를 개발 중입니다. 
PyQt5를 사용해서 User가 Interactive하게 사용할 수 있는 프로그램을 개발 중입니다.

http://blog.rcnelson.com/building-a-matplotlib-gui-with-qt-designer-part-2/ 를 참고중
"""
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()







if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    main.show()
    sys.exit(app.exec_())

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()







if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    main.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    main.show()
    sys.exit(app.exec_())

import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

num_random_Wafer = 12

df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtWidgets 

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')
class DataFrameModel(QtCore.QAbstractTableModel):
    DtypeRole = QtCore.Qt.UserRole + 1000
    ValueRole = QtCore.Qt.UserRole + 1001
    
    def __init__(self, df=pd.DataFrame(), parent=None):
        super(DataFrameModel, self).__init__(parent)
        self._dataframe = df
    
    def setDataFrame(self, dataframe):
        self.beginResetModel()
        self._dataframe = dataframe.copy()
        self.endResetModel()
    
    def dataFrame(self):
        return self._dataframe
    
    dataFrame = QtCore.pyqtProperty(pd.DataFrame, fget=dataFrame, fset=setDataFrame)
    
    @QtCore.pyqtSlot(int, QtCore.Qt.Orientation, result=str)
    def headerData(self, section: int, orientation: QtCore.Qt.Orientation, role: int = QtCore.Qt.DisplayRole):
        if role == QtCore.Qt.DisplayRole:
            if orientation == QtCore.Qt.Horizontal:
                return self._dataframe.columns[section]
            else:
                return str(self._dataframe.index[section])
        return QtCore.QVariant()
    
    def rowCount(self, parent=QtCore.QModelIndex()):
        if parent.isValid():
            return 0
        return len(self._dataframe.index)
    
    def columnCount(self, parent=QtCore.QModelIndex()):
        if parent.isValid():
            return 0
        return self._dataframe.columns.size
    
    def data(self, index, role=QtCore.Qt.DisplayRole):
        if not index.isValid() or not (0 <= index.row() < self.rowCount() \
            and 0 <= index.column() < self.columnCount()):
            return QtCore.QVariant()
        row = self._dataframe.index[index.row()]
        col = self._dataframe.columns[index.column()]
        dt = self._dataframe[col].dtype
        
        val = self._dataframe.iloc[row][col]
        if role == QtCore.Qt.DisplayRole:
            return str(val)
        elif role == DataFrameModel.ValueRole:
            return val
        if role == DataFrameModel.DtypeRole:
            return dt
        return QtCore.QVariant()
    
    def roleNames(self):
        roles = {
            QtCore.Qt.DisplayRole: b'display',
            DataFrameModel.DtypeRole: b'dtype',
            DataFrameModel.ValueRole: b'value'
        }
        return roles  

from PyQt5 import QtCore, QtGui, QtWidgets
class DataFrameModel(QtCore.QAbstractTableModel):
    DtypeRole = QtCore.Qt.UserRole + 1000
    ValueRole = QtCore.Qt.UserRole + 1001
    
    def __init__(self, df=pd.DataFrame(), parent=None):
        super(DataFrameModel, self).__init__(parent)
        self._dataframe = df
    
    def setDataFrame(self, dataframe):
        self.beginResetModel()
        self._dataframe = dataframe.copy()
        self.endResetModel()
    
    def dataFrame(self):
        return self._dataframe
    
    dataFrame = QtCore.pyqtProperty(pd.DataFrame, fget=dataFrame, fset=setDataFrame)
    
    @QtCore.pyqtSlot(int, QtCore.Qt.Orientation, result=str)
    def headerData(self, section: int, orientation: QtCore.Qt.Orientation, role: int = QtCore.Qt.DisplayRole):
        if role == QtCore.Qt.DisplayRole:
            if orientation == QtCore.Qt.Horizontal:
                return self._dataframe.columns[section]
            else:
                return str(self._dataframe.index[section])
        return QtCore.QVariant()
    
    def rowCount(self, parent=QtCore.QModelIndex()):
        if parent.isValid():
            return 0
        return len(self._dataframe.index)
    
    def columnCount(self, parent=QtCore.QModelIndex()):
        if parent.isValid():
            return 0
        return self._dataframe.columns.size
    
    def data(self, index, role=QtCore.Qt.DisplayRole):
        if not index.isValid() or not (0 <= index.row() < self.rowCount() \
            and 0 <= index.column() < self.columnCount()):
            return QtCore.QVariant()
        row = self._dataframe.index[index.row()]
        col = self._dataframe.columns[index.column()]
        dt = self._dataframe[col].dtype
        
        val = self._dataframe.iloc[row][col]
        if role == QtCore.Qt.DisplayRole:
            return str(val)
        elif role == DataFrameModel.ValueRole:
            return val
        if role == DataFrameModel.DtypeRole:
            return dt
        return QtCore.QVariant()
    
    def roleNames(self):
        roles = {
            QtCore.Qt.DisplayRole: b'display',
            DataFrameModel.DtypeRole: b'dtype',
            DataFrameModel.ValueRole: b'value'
        }
        return roles  

from PyQt5 import QtCore, QtGui, QtWidgets
import pandas as pd
class DataFrameModel(QtCore.QAbstractTableModel):
    DtypeRole = QtCore.Qt.UserRole + 1000
    ValueRole = QtCore.Qt.UserRole + 1001
    
    def __init__(self, df=pd.DataFrame(), parent=None):
        super(DataFrameModel, self).__init__(parent)
        self._dataframe = df
    
    def setDataFrame(self, dataframe):
        self.beginResetModel()
        self._dataframe = dataframe.copy()
        self.endResetModel()
    
    def dataFrame(self):
        return self._dataframe
    
    dataFrame = QtCore.pyqtProperty(pd.DataFrame, fget=dataFrame, fset=setDataFrame)
    
    @QtCore.pyqtSlot(int, QtCore.Qt.Orientation, result=str)
    def headerData(self, section: int, orientation: QtCore.Qt.Orientation, role: int = QtCore.Qt.DisplayRole):
        if role == QtCore.Qt.DisplayRole:
            if orientation == QtCore.Qt.Horizontal:
                return self._dataframe.columns[section]
            else:
                return str(self._dataframe.index[section])
        return QtCore.QVariant()
    
    def rowCount(self, parent=QtCore.QModelIndex()):
        if parent.isValid():
            return 0
        return len(self._dataframe.index)
    
    def columnCount(self, parent=QtCore.QModelIndex()):
        if parent.isValid():
            return 0
        return self._dataframe.columns.size
    
    def data(self, index, role=QtCore.Qt.DisplayRole):
        if not index.isValid() or not (0 <= index.row() < self.rowCount() \
            and 0 <= index.column() < self.columnCount()):
            return QtCore.QVariant()
        row = self._dataframe.index[index.row()]
        col = self._dataframe.columns[index.column()]
        dt = self._dataframe[col].dtype
        
        val = self._dataframe.iloc[row][col]
        if role == QtCore.Qt.DisplayRole:
            return str(val)
        elif role == DataFrameModel.ValueRole:
            return val
        if role == DataFrameModel.DtypeRole:
            return dt
        return QtCore.QVariant()
    
    def roleNames(self):
        roles = {
            QtCore.Qt.DisplayRole: b'display',
            DataFrameModel.DtypeRole: b'dtype',
            DataFrameModel.ValueRole: b'value'
        }
        return roles

def btn_clk(self):

path = self.lineEdit.text()
df = pd.read_csv(path)
model = PandasModel(df)
self.tableView.setModel(model)
import sys, csv
from PyQt5.QtWidgets import (QApplication, QWidget, 
                            QTableWidget, QTableWidgetItem, QAbstractItemView)


class UsrUI(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()
        self.show()
    
    def initUI(self):
        # 위젯의 위치 크기 설정
        self.setGeometry(100, 100, 600, 300)
        # table widget
        self.tbl = QTableWidget(self)       # widget instance
        self.tbl.resize(590, 290)           # table widget size
        self.tbl.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.tblData()
    
    def tblData(self):
        # column 설정
        col_headers = ['Title', 'Text', 'Source']
        self.tbl.setColumnCount(len(col_headers))
        self.tbl.setHorizontalHeaderLabels(col_headers)
        self.tbl.setRowCount(20)



if __name__ == "__main__":
    app = QApplication(sys.argv)
    ex = UsrUI()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def tableviewer(self):
        self.meta_table

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    main.show()
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def tableviewer(self):
        self.meta_table






if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    main.show()
    sys.exit(app.exec_())

import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
사용자가 만약에 19번 Wafer를 호출한다

num_random_Wafer = 19 # 아마도 나중에 사용자 입력받을 값

df_Meta_final['SLOT'] == str(num_random_Wafer) #이거는 그냥 인넥스 판별용이구
df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)] # 이걸로 해당하는 데이터 프레임 가져옴


통계량 데이터 프레임에서 임의의 Wafer 번호가 주어지면 그에 해당하는 데이터 프레임 가져옴

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
가져오는 형식도 Dataframe 형태임.


데이터 포인트 프레임도 마찬가지

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

'''

num_random_Wafer = 12

df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def tableviewer(self):
        self.meta_table
        self.show()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    main.tableviewer(df_Meta)
    
    
    main.show()
    sys.exit(app.exec_())

def __init__(self, ):
    super(Main, self).__init__()
    self.setupUi(self)
    self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
    self.setWindowTitle("Wafer viewer")


def addmpl(self, fig):
    self.canvas = FigureCanvas(fig)
    self.mplvl.addWidget(self.canvas)
    self.canvas.draw()


def addmpl_2(self, fig):
    self.canvas = FigureCanvas(fig)
    self.mplvl_2.addWidget(self.canvas)
    self.canvas.draw()



def tableviewer(self, df):
    self.meta_table
    self.show()

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def tableviewer(self, df):
        self.meta_table
        self.show()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    main.tableviewer(df_Meta)
    
    
    main.show()
    sys.exit(app.exec_())

import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
사용자가 만약에 19번 Wafer를 호출한다

num_random_Wafer = 19 # 아마도 나중에 사용자 입력받을 값

df_Meta_final['SLOT'] == str(num_random_Wafer) #이거는 그냥 인넥스 판별용이구
df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)] # 이걸로 해당하는 데이터 프레임 가져옴


통계량 데이터 프레임에서 임의의 Wafer 번호가 주어지면 그에 해당하는 데이터 프레임 가져옴

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
가져오는 형식도 Dataframe 형태임.


데이터 포인트 프레임도 마찬가지

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

'''

num_random_Wafer = 12

df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def tableviewer(self, df):
        self.meta_table
        self.show()

if __name__ == "__main__":
    import sys
    from PyQt5 import QtWidgets
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    app = QtWidgets.QApplication(sys.argv)
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    main.tableviewer(df_Meta)
    
    
    main.show()
    sys.exit(app.exec_())

import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.Qtcore import QAbstractTTableModel, Qt
from PyQt5.QtCore import QAbstractTTableModel, Qt
from PyQt5.QtCore import QAbstractTableModel, Qt
df_Meta_final
import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt



class pandasModel(QAbstractTableModel):
    def _init_(self, data):
        super()._init_()
        self._data = data
    
    def rowCount(self):
        return self._data.shape[0]
    
    def columnCount(self):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

if _name_ == '_main_':
    app = QApplication(sys.argv)
    
    model = pandasModel(df_Meta_final)
    
    view = QTableView()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    sys.exit(app.exec_())

import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt



class pandasModel(QAbstractTableModel):
    def _init_(self, data):
        QAbstractTableModel._init_()
        self._data = data
    
    def rowCount(self):
        return self._data.shape[0]
    
    def columnCount(self):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

if _name_ == '_main_':
    app = QApplication(sys.argv)
    
    model = pandasModel(df_Meta_final)
    
    view = QTableView()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    sys.exit(app.exec_())

import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt



class pandasModel(QAbstractTableModel):
    def _init_(self, data):
        QAbstractTableModel._init_()
        self._data = data
    
    def rowCount(self):
        return self._data.shape[0]
    
    def columnCount(self):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

if __name__ == "__main__":
    app = QApplication(sys.argv)
    
    model = pandasModel(df_Meta_final)
    
    view = QTableView()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    sys.exit(app.exec_())

import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt



class pandasModel(QAbstractTableModel):
    def _init_(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

if __name__ == "__main__":
    app = QApplication(sys.argv)
    
    model = pandasModel(df_Meta_final)
    
    view = QTableView()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    sys.exit(app.exec_())

import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt



class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

if __name__ == "__main__":
    app = QApplication(sys.argv)
    
    model = pandasModel(df_Meta_final)
    
    view = QTableView()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    sys.exit(app.exec_())

mport os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
사용자가 만약에 19번 Wafer를 호출한다

num_random_Wafer = 19 # 아마도 나중에 사용자 입력받을 값

df_Meta_final['SLOT'] == str(num_random_Wafer) #이거는 그냥 인넥스 판별용이구
df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)] # 이걸로 해당하는 데이터 프레임 가져옴


통계량 데이터 프레임에서 임의의 Wafer 번호가 주어지면 그에 해당하는 데이터 프레임 가져옴

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
가져오는 형식도 Dataframe 형태임.


데이터 포인트 프레임도 마찬가지

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

'''

num_random_Wafer = 12

df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
사용자가 만약에 19번 Wafer를 호출한다

num_random_Wafer = 19 # 아마도 나중에 사용자 입력받을 값

df_Meta_final['SLOT'] == str(num_random_Wafer) #이거는 그냥 인넥스 판별용이구
df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)] # 이걸로 해당하는 데이터 프레임 가져옴


통계량 데이터 프레임에서 임의의 Wafer 번호가 주어지면 그에 해당하는 데이터 프레임 가져옴

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
가져오는 형식도 Dataframe 형태임.


데이터 포인트 프레임도 마찬가지

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

'''

num_random_Wafer = 12

df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt



class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None


if __name__ == "__main__":
    app = QApplication(sys.argv)
    
    model = pandasModel(df_Meta_final)
    
    view = QTableView()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()




class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
사용자가 만약에 19번 Wafer를 호출한다

num_random_Wafer = 19 # 아마도 나중에 사용자 입력받을 값

df_Meta_final['SLOT'] == str(num_random_Wafer) #이거는 그냥 인넥스 판별용이구
df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)] # 이걸로 해당하는 데이터 프레임 가져옴


통계량 데이터 프레임에서 임의의 Wafer 번호가 주어지면 그에 해당하는 데이터 프레임 가져옴

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
가져오는 형식도 Dataframe 형태임.


데이터 포인트 프레임도 마찬가지

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

'''

num_random_Wafer = 12

df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
if __name__ == "__main__":
   app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    
    
    
    
    
    model = pandasModel(df_Meta_final)
    view = QTableView()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    
    
    
    
    
    model = pandasModel(df_Meta_final)
    view = QTableView()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
사용자가 만약에 19번 Wafer를 호출한다

num_random_Wafer = 19 # 아마도 나중에 사용자 입력받을 값

df_Meta_final['SLOT'] == str(num_random_Wafer) #이거는 그냥 인넥스 판별용이구
df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)] # 이걸로 해당하는 데이터 프레임 가져옴


통계량 데이터 프레임에서 임의의 Wafer 번호가 주어지면 그에 해당하는 데이터 프레임 가져옴

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
가져오는 형식도 Dataframe 형태임.


데이터 포인트 프레임도 마찬가지

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

'''

num_random_Wafer = 12

df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')


#def data_processing():



class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()




class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None








if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    
    
    
    
    
    model = pandasModel(df_Meta_final)
    view = QTableView()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

df.shape[0]
df.shape[1]
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    model = pandasModel(df_Meta_final)
    view = meta_table()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    model = pandasModel(df_Meta_final)
    
    view = QMainWindow.QTableWidget()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

"""
Created on Sun Feb 16 14:45:44 2020

@author: wtjang
"""

"""
계측 파일 전처리 함수 
"""


import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
사용자가 만약에 19번 Wafer를 호출한다

num_random_Wafer = 19 # 아마도 나중에 사용자 입력받을 값

df_Meta_final['SLOT'] == str(num_random_Wafer) #이거는 그냥 인넥스 판별용이구
df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)] # 이걸로 해당하는 데이터 프레임 가져옴


통계량 데이터 프레임에서 임의의 Wafer 번호가 주어지면 그에 해당하는 데이터 프레임 가져옴

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
가져오는 형식도 Dataframe 형태임.


데이터 포인트 프레임도 마찬가지

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

'''

num_random_Wafer = 12

df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
"""
Created on Tue Feb 11 17:55:41 2020 ~

@author: wtjang
"""

"""
Wafer viewer를 개발 중입니다. 
PyQt5를 사용해서 User가 Interactive하게 사용할 수 있는 프로그램을 개발 중입니다.

http://blog.rcnelson.com/building-a-matplotlib-gui-with-qt-designer-part-2/ 를 참고중
"""
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()




class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    model = pandasModel(df_Meta_final)
    
    view = QMainWindow.QTableWidget()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    model = pandasModel(df_Meta_final)
    
    view = QMainWindow.meta_table()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

QMainWindow
Ui_MainWindow
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    model = pandasModel(df_Meta_final)
    
    view = QTableWidget()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()

"""
Created on Sun Feb 16 14:45:44 2020

@author: wtjang
"""

"""
계측 파일 전처리 함수 
"""


import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
사용자가 만약에 19번 Wafer를 호출한다

num_random_Wafer = 19 # 아마도 나중에 사용자 입력받을 값

df_Meta_final['SLOT'] == str(num_random_Wafer) #이거는 그냥 인넥스 판별용이구
df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)] # 이걸로 해당하는 데이터 프레임 가져옴


통계량 데이터 프레임에서 임의의 Wafer 번호가 주어지면 그에 해당하는 데이터 프레임 가져옴

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
가져오는 형식도 Dataframe 형태임.


데이터 포인트 프레임도 마찬가지

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

'''

num_random_Wafer = 12

df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
"""
Created on Tue Feb 11 17:55:41 2020 ~

@author: wtjang
"""

"""
Wafer viewer를 개발 중입니다. 
PyQt5를 사용해서 User가 Interactive하게 사용할 수 있는 프로그램을 개발 중입니다.

http://blog.rcnelson.com/building-a-matplotlib-gui-with-qt-designer-part-2/ 를 참고중
"""
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()




class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    model = pandasModel(df_Meta_final)
    
    view = QTableWidget()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()




class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    model = pandasModel(df_Meta_final)
    
    view = QTableWidget()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    model = pandasModel(df_Meta_final)
    
    view = QTableWidget()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

"""
Created on Sun Feb 16 14:45:44 2020

@author: wtjang
"""

"""
계측 파일 전처리 함수 
"""


import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
사용자가 만약에 19번 Wafer를 호출한다

num_random_Wafer = 19 # 아마도 나중에 사용자 입력받을 값

df_Meta_final['SLOT'] == str(num_random_Wafer) #이거는 그냥 인넥스 판별용이구
df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)] # 이걸로 해당하는 데이터 프레임 가져옴


통계량 데이터 프레임에서 임의의 Wafer 번호가 주어지면 그에 해당하는 데이터 프레임 가져옴

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]
가져오는 형식도 Dataframe 형태임.


데이터 포인트 프레임도 마찬가지

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

'''

num_random_Wafer = 12

df_Meta_final.loc[df_Meta_final['SLOT'] == str(num_random_Wafer)]

df_Stat_T = df_Stat.T
df_Stat_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]

df_Point_T = df_Point.T
df_Point_T.loc[:,((num_random_Wafer - num_first_Wafer) * num_Feature):((num_random_Wafer - num_first_Wafer) * num_Feature)+2]




http://blog.rcnelson.com/building-a-matplotlib-gui-with-qt-designer-part-2/ 를 참고중
"""
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()




class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

"""
Created on Tue Feb 11 17:55:41 2020 ~

@author: wtjang
"""

"""
Wafer viewer를 개발 중입니다. 
PyQt5를 사용해서 User가 Interactive하게 사용할 수 있는 프로그램을 개발 중입니다.

http://blog.rcnelson.com/building-a-matplotlib-gui-with-qt-designer-part-2/ 를 참고중
"""
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()




class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    model = pandasModel(df_Meta_final)
    
    view = QTableWidget()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    model = pandasModel(df_Meta_final)
    
    view = QTableView()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

pos = 0

def forward(pos):
    return pos + 20


pos = forward(pos)

print(pos)
pos = 50

def forward(pos):
    return pos + 20


pos = forward(pos)

print(pos)

## ---(Wed Feb 19 10:39:29 2020)---
import os
import pandas as pd
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
f = open(path_dir +  '\\' +  file_list[0]) # SFX200 가져오기
lines = f.readlines()
lines
labels = lines[1].split(',') # line 0 : Factor  
labels = lines[1].split(' ') # line 0 : Factor  
labels
labels = lines[1].split('\) # line 0 : Factor  
labels = lines[1].split('\') # line 0 : Factor  
labels = lines[1].split('\n') # line 0 : Factor  
labels = lines[1].split # line 0 : Factor  
labels = lines[1].split # line 0 : Factor  
labels = lines[1].split # line 0 : Factor  
lines[1]
labels = lines[1].split('/n') # line 0 : Factor  
labels = lines[1].split('\n') # line 0 : Factor  
labels = lines[1].split('\\') # line 0 : Factor  
labels = lines[1].split() # line 0 : Factor  
df = pd.DataFrame(columns = labels)
len(lines)
i=2
temp = lines[i]
temp
i=3
temp = lines[i]
temp
temp = temp.split('\t')
df.loc[i-2] = temp
for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp

df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
labels[0]
df.MFC01_1_AI_O2
df.colmns
df.columns
df.columns[0]
df_1.Time = pd.to_datetime(df.columns[0]) # 타입 변환
df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'), inplace = True)
df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True)
df.LOG_ITEM
df_1.Time = pd.to_datetime(df.LOG_ITEM) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]
df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True)

df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_1.Time = pd.to_datetime(df.LOG_ITEM) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})

cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]
%clear
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[0]) # SFX200 가져오기

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  




df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp

df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_1.Time = pd.to_datetime(df.LOG_ITEM) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_6step = df.loc[df_1['StepNo'] == 6]
df_6step.loc[2,1]
df_6step.loc(2,1)
df_6step.loc[650,2]
df_6step[623,1]
df_6step(623,1)
df_6step[623,1]
df_6step{623,1}
df_6step.iloc[623,'StepNo']
df_6step.iloc[623,2]
df_6step.iloc[623,2] +1 
df_6step = df_1.loc[df_1['StepNo'] == 6]
df_6step.iloc[623,2] +1
df_5step = df_1.loc[df_1['StepNo'] == 5]
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
import matplotlib.pyplot as plt
import numpy as np
df_5_6step.plot.line()
df_5_6step['HFMat2_Zr'].plot.line()
df_5_6step['HFMat2_Zr'].plot.line()
plt.title('Title')
df_5_6step['HFMat2_Zr'].plot.line()
plt.xlabel('Step')
plt.ylabel('HFMat2_Zr')
plt.title('Title')
plt.legend()
df_5_6step['HFMat2_Zr'].plot.line()
plt.xlabel('Step')
plt.ylabel('HFMat2_Zr')
plt.title('Title')
plt.legend()
df_5_6step['HFMat2_Zr','HFMat2_VDC'].plot.line()
df_5_6step[['HFMat2_Zr','HFMat2_VDC']].plot.line()
plt.xlabel('Step')
plt.ylabel('HFMat2_Zr')
plt.title('Title')
plt.legend()

df_5_6step[['HFMat2_Zr','HFMat2_VDC']].plot.line()
plt.figure(figsize=(12,3))
plt.xlabel('Step')
plt.ylabel('HFMat2_Zr')
plt.title('Title')
plt.legend()
plt.figure(figsize=(12,3))
df_5_6step[['HFMat2_Zr','HFMat2_VDC']].plot.line()


plt.xlabel('Step')
plt.ylabel('HFMat2_Zr')
plt.title('Title')
plt.legend()
df_5_6step[['HFMat2_Zr','HFMat2_VDC']].plot(figsize=(10,3)).line()
df_5_6step[['HFMat2_Zr','HFMat2_VDC']].plot(figsize=(8,3)).line()
df_5_6step[['HFMat2_Zr','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['HFMat2_Zr','HFMat2_VDC']].plt
df_5_6step[['HFMat2_Zr','HFMat2_VDC']].plt.matshow()
plt.matshow(df_5_6step[['HFMat2_Zr','HFMat2_VDC']].corr())
plt.matshow(df_5_6step[['HFMat2_Zr','HFMat2_VDC']].corr())
plt.show()
df_5_6step[['HFMat2_Zr','HFMat2_VDC']].corr()
color = 'red')
plt.plot('HFMat2_Zr', 
         'HFMat2_VDC',
         data = df_5_6step,
         color = 'red')
plt.plot('HFMat2_Zr', 
         'HFMat2_VDC',
         data = df_5_6step,
         linestyle = 'none',
         marker = 'o',
         markersize = 10,
         color = 'red')
df_5_6step['HFMat2_Zr'].plot(figsize=(8,5)).line()
plt.plot('HFMat2_Zr', 
         'HFMat2_VDC',
         data = df_5_6step,
         linestyle = 'none',
         marker = 'o',
         markersize = 10,
         color = 'red')
plt.plot('HFMat2_Zr', 
         'HFMat2_VDC',
         data = df_5_6step,
         linestyle = 'none',
         marker = 'o',
         markersize = 5,
         color = 'red')
plt.plot('HFMat2_Zr', 
         'HFMat2_VDC',
         data = df_5_6step,
         linestyle = 'none',
         marker = 'o',
         markersize = 3,
         color = 'black')
plt.plot('HFMat2_Zr', 
         'HFMat2_VDC',
         data = df_5_6step,
         linestyle = 'none',
         marker = 'o',
         markersize = 3,
         color = 'black')

plt.title('Scatter Plot of Vdc by matplotlib', fontsize=20)
plt.xlabel('HFMat2_Zr', fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)
plt.plot('HFMat2_Zr', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black')
#plt.title('Scatter Plot of Vdc by matplotlib', fontsize=20)
plt.xlabel('HFMat2_Zr', fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)
del df_5_6step["N/A"]
df_5_6step.corr()
cor_table = df_5_6step.corr()
cor_table.columns
cor_table_col_name = cor_table.columns
cor_table_col_name
cor_table_col_name = cor_table.columns()
cor_table_col_name = list(cor_table.columns.values)
cor_table[['HFMat1_VDC','HFMat2_VDC']]
cor_table['HFMat2_VDC'].sort()
Vdc_cor = cor_table['HFMat2_VDC']
Vdc_cor_sort = Vdc_cor.sort_values()
Vdc_cor_sort.bar()
Vdc_cor_sort.plt()
final = pd.DataFrame({'cor' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
final.bar()
final.plot(kind='bar')
cor_table['HFMat2_VDC'] > 0.5
cor_table.loc[(cor_table['HFMat2_VDC'] > 0.5) | cor_table['HFMat2_VDC'] < -0.5 ]
cor_table.loc[(cor_table['HFMat2_VDC'] > 0.5) | (cor_table['HFMat2_VDC'] < -0.5) ]
Vdc_cor = cor_table.loc[(cor_table['HFMat2_VDC'] > 0.5) | (cor_table['HFMat2_VDC'] < -0.5) ]
Vdc_cor_sort = Vdc_cor.sort_values()
Vdc_cor
Vdc_cor_sort = Vdc_cor.sort_values()
Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > 0.5) | (cor_table['HFMat2_VDC'] < -0.5) ]
Vdc_cor_sort = Vdc_cor.sort_values()
final = pd.DataFrame({'cor' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
final.plot(kind='bar')
final.plot(figsize=(8,5), kind='bar')
final.plot(figsize=(10,7), kind='bar')
final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")
ax = final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")
final = pd.DataFrame({'cor' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})


ax = final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

plt.xlabel('cor', fontsize=18)
Vdc_cor.name
Vdc_cor.index
Vdc_cor.index.values()
Vdc_cor.index.value
Vdc_cor.index.values
label = Vdc_cor.index.values
label = list(Vdc_cor.index.values)
label
ax = final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")
plt.xticks(index, label, fontsize=15)
plt.xticks(label, fontsize=15)
ax = final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)

plt.xticks(label, fontsize=15)
plt.bar(cor, final)
plt.bar('cor', final)
ax = final.plot(figsize=(10,7), kind='bar')
plt.bar(index, Vdc_cor_sort)
plt.bar(Index, Vdc_cor_sort)
al = pd.DataFrame({'cor' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})


ax = final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15)
ax = final.plot(figsize=(10,7), kind='barh')
ax = final.plot(figsize=(10,7), kind='barh')

ax = final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15)
ax = final.plot(figsize=(10,7), kind='barh')

#ax = final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15)
ax = final.plot(figsize=(10,7), kind='barh')
ax = final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15)
plt.xticks(index, label, fontsize=15, rotation = 45)
ax = final.plot(figsize=(10,7), kind='barh')

ax = final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 45)
ax = final.plot(figsize=(10,7), kind='barh')

ax = final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 70)
ax = final.plot(figsize=(10,7), kind='barh')

ax = final.plot(figsize=(10,7), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 80)
ax = final.plot(figsize=(15,8), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 80)
ax = final.plot(figsize=(15,8), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 85)
ax = final.plot(figsize=(15,8), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 265)
ax = final.plot(figsize=(15,8), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 85)
Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > 0.7) | (cor_table['HFMat2_VDC'] < -0.7) ]
Vdc_cor_sort = Vdc_cor.sort_values()
ax = final.plot(figsize=(10,7), kind='barh')



ax = final.plot(figsize=(15,8), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 85)
label = list(Vdc_cor.index.values)
ax = final.plot(figsize=(15,8), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 85)
final = pd.DataFrame({'cor' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar')
ax.set_xlabel("x label")
ax.set_ylabel("y label")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 85)
ax = final.plot(figsize=(15,8), kind='bar')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 85)
ax = final.plot(figsize=(15,8), kind='bar', color = 'red')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 85)
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 85)
plt.plot('MFC09_2_AO_OMCTS', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black')
df_5_6step[['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['HFMat2_Zr','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step['HFMat2_Zr'].plot(figsize=(8,5)).line()
df_5_6step['HFMat2_Zr'].plot(figsize=(8,5)).line()

plt.xlabel('Step')
plt.ylabel('HFMat2_Zr')
plt.title('Title')
plt.legend()
df_5_6step['HFMat2_Zr'].plot(figsize=(8,5)).line()
df_5_6step[['HFMat2_Zr','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step['HFMat2_Zr'].plot(figsize=(8,5)).line()

plt.xlabel('Step')
plt.title('Title')
plt.matshow(df_5_6step[['HFMat2_Zr','HFMat2_VDC']].corr())
plt.show()
plt.plot('HFMat2_Zr', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black')
plt.plot('MFC09_2_AO_OMCTS', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black')
plt.plot('HFMat2_Zr', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black')
#plt.title('Scatter Plot of Vdc by matplotlib', fontsize=20)
plt.xlabel('HFMat2_Zr', fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)
cor_table[['HFMat1_VDC','HFMat2_VDC']]
corr = 0.7
Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
final
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
ax.set_ylabel("Correlation")
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')




#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")





label = list(Vdc_cor.index.values)
index = np.arange(len(label))


plt.xticks(index, label, fontsize=15, rotation = 85)
df_5_6step[['MFC09-2-P1-PRESSURE_Al','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09-2-P1-PRESSURE_AI','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_P1-PRESSURE_Al','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_P1_PRESSURE_Al','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_P1_PRESSURE_AI','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_P1_PRESSURE_AI','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step.loc[609:672,[['MFC09_2_AO_OMCTS','HFMat2_VDC']]].plot(figsize=(8,5)).line()
df_5_6step.iloc[609:672,[['MFC09_2_AO_OMCTS','HFMat2_VDC']]].plot(figsize=(8,5)).line()
df_5_6step[609:672,[['MFC09_2_AO_OMCTS','HFMat2_VDC']]].plot(figsize=(8,5)).line()
df_5_6step[[609:672],[['MFC09_2_AO_OMCTS','HFMat2_VDC']]].plot(figsize=(8,5)).line()
df_5_6step[[609],[['MFC09_2_AO_OMCTS','HFMat2_VDC']]].plot(figsize=(8,5)).line()
df_5_6step[609,[['MFC09_2_AO_OMCTS','HFMat2_VDC']]].plot(figsize=(8,5)).line()
df_5_6step.loc[609,[['MFC09_2_AO_OMCTS','HFMat2_VDC']]].plot(figsize=(8,5)).line()
df_5_6step.loc[:,[['MFC09_2_AO_OMCTS','HFMat2_VDC']]]
df_5_6step[:,[['MFC09_2_AO_OMCTS','HFMat2_VDC']]]
df_5_6step[:,['MFC09_2_AO_OMCTS','HFMat2_VDC']]
df_5_6step[['MFC09_2_AO_OMCTS','HFMat2_VDC']]
df_5_6step[672,['MFC09_2_AO_OMCTS','HFMat2_VDC']]
df_5_6step.loc[672,['MFC09_2_AO_OMCTS','HFMat2_VDC']]
df_5_6step.loc[610:672,['MFC09_2_AO_OMCTS','HFMat2_VDC']]
df_5_6step.loc[610:672,['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step.loc[610:690,['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step.loc[610:700,['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step.loc[610:800,['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step.loc[610:700,['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_P1_PRESSURE_AI','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step.loc[610:700,['MFC09_2_P1_PRESSURE_AI','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step.loc[610:700,['MFC09_2_AO_OMCTS','MFC09_2_P1_PRESSURE_AI','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step.loc[610:700,['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_P1_PRESSURE_AI','HFMat2_VDC']].plot(figsize=(8,5)).line()
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")


'''
label 이름 붙여주려고
'''
label = list(Vdc_cor.index.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)
Vdc_cor_sort
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")


'''
label 이름 붙여주려고
'''
label = list(Vdc_cor_sort.index.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)
df_5_6step[['HFMat2_LOAD_POS','HFMat2_VDC']].plot(figsize=(8,5)).line()
plt.plot('HFMat2_LOAD_POS', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black')
plt.plot('HFMat2_LOAD_POS', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.5)
plt.plot('HFMat2_LOAD_POS', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.7)
plt.plot('HFMat2_LOAD_POS', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.2)
plt.plot('HFMat2_LOAD_POS', 'HFMat2_VDC', data = df_5_6step, 
plt.plot('HFMat2_LOAD_POS', 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.2)
df_5_6step[['HFMat2_LOAD_POS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step.loc[610:700,['HFMat2_LOAD_POS','HFMat2_VDC']].plot(figsize=(8,5)).line()
%clear
import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()
files_list
file_list
file_list[21]
f = open(path_dir +  '\\' +  file_list[21]) 
lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  

df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp



df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경

df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat1_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
temp = df_5_6step[['MFC09_2_AO_OMCTS','HFMat2_VDC']]
import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
file_list[20]
k=0
f = open(path_dir +  '\\' +  file_list[k]) 
lines = f.readlines()
labels = lines[1].split() 
df_k = pd.DataFrame(columns = labels)
df_k
df_0
df[k] = pd.DataFrame(columns = labels)
df_[k] = pd.DataFrame(columns = labels)
k
exec('{} = pd.DataFrame()'.format(k))
exec('{} = pd.DataFrame()'.format(k))
    df[k] = pd.DataFrame(columns = labels)
exec('{} = pd.DataFrame()'.df(k))
df[k] = pd.DataFrame(columns = labels)
d = {}
for name in file_list:
    d[name] = pd.DataFrame(columns = labels)

d[0]
d[1]
d{0}
d(0)
d.items[0]
d.items(0)
d.items(1)
d.items()
for name, df in d.items():
for name, df in d.items():
    f = open(path_dir +  '\\' +  file_list[k]) 
    
    lines = f.readlines()
    labels = lines[1].split() # line 0 : Factor 

NAME
name
file_list
file_list[k]
f = open(path_dir +  '\\' +  name) 
for name, df in d.items():
    f = open(path_dir +  '\\' +  name) 
    
    lines = f.readlines()
    labels = lines[1].split() # line 0 : Factor 

d.items()
for name in file_list:
    d[name] = pd.DataFrame(columns = labels)

name
d = {}
for name in file_list:
    d[name] = pd.DataFrame(columns = labels)
    
    f = open(path_dir +  '\\' +  name) 
    
    lines = f.readlines()
    labels = lines[1].split() # line 0 : Factor

file_list
for name in file_list:
    
    f = open(path_dir +  '\\' +  name) 
    
    lines = f.readlines()
    labels = lines[1].split() # line 0 : Factor
    
    d[name] = pd.DataFrame(columns = labels)

d = {}
for name in file_list:
    
    f = open(path_dir +  '\\' +  name) 
    
    lines = f.readlines()
    labels = lines[1].split() # line 0 : Factor
    
    d[name] = pd.DataFrame(columns = labels)

import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()
d = {}

for name in file_list:
    
    f = open(path_dir +  '\\' +  name) 
    
    lines = f.readlines()
    labels = lines[1].split() # line 0 : Factor
    
    d[name] = pd.DataFrame(columns = labels)

d = {}
for name in file_list:
    
    f = open(path_dir +  '\\' +  name) 
    
    lines = f.readlines()
    labels = lines[1].split() # line 0 : Factor
    
    d[name] = pd.DataFrame(columns = labels)
    
    
    
    for i in range(3, len(lines)):
        temp = lines[i]
        temp = temp.split('\t')
        
        d[name].loc[i-3] = temp
    
    
    d[name].rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경

d
d = {}
for name in file_list:
    
    f = open(path_dir +  '\\' +  name) 
    
    lines = f.readlines()
    labels = lines[1].split() # line 0 : Factor
    
    d[name] = pd.DataFrame(columns = labels)
    
    
    
    for i in range(3, len(lines)):
        temp = lines[i]
        temp = temp.split('\t')
        
        d[name].loc[i-3] = temp
        
        
        d[name].rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경

lines[3]
lines[4]
lines[5]
lines[2180]
lines[2170]
lines[2171]
lines[2172]
lines[2173]
lines[2174]
len(lines)
f.close()
d = {}
for name in file_list:
    
    f = open(path_dir +  '\\' +  name) 
    
    lines = f.readlines()
    labels = lines[1].split() # line 0 : Factor
    
    d[name] = pd.DataFrame(columns = labels)
    
    
    
    for i in range(3, len(lines)):
        temp = lines[i]
        temp = temp.split('\t')
        
        d[name].loc[i-3] = temp
    
    
    d[name].rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
    
    d[name]_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

d = {}
for name in file_list:
    
    f = open(path_dir +  '\\' +  name) 
    
    lines = f.readlines()
    labels = lines[1].split() # line 0 : Factor
    
    d[name] = pd.DataFrame(columns = labels)
    
    
    
    for i in range(3, len(lines)):
        temp = lines[i]
        temp = temp.split('\t')
        
        d[name].loc[i-3] = temp
    
    
    d[name].rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
    
    d[name] = d[name].loc[:,'StepNo':(d[name].iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

d1
d.items
d.items()
d.items(1)
d.items(0)
d.items[0]
d.items[1]
%clear
import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
file_list[20]
f = open(path_dir +  '\\' +  file_list[20]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step[['HFMat2_Zr','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['MFC09_2_AO_OMCTS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step[['HFMat2_LOAD_POS','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step.loc[610:700,['MFC09_2_AO_OMCTS','MFC09_2_P1_PRESSURE_AI','HFMat2_VDC']].plot(figsize=(8,5)).line()
df_5_6step.loc[610:700,['HFMat2_LOAD_POS','HFMat2_VDC']].plot(figsize=(8,5)).line()
fig, ax1 = plt.subplots()
fig, ax1 = plt.subplots()

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel('HFMat2_VDC', color=color)

ax1.plot(df_5_6step['HFMat2_VDC'], color=color)
ax1.tick_params(axis='y', labelcolor=color)
ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

color = 'tab:blue'
ax2.set_ylabel('MFC09_2_AO_OMCTS', color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step['MFC09_2_AO_OMCTS'], color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig, ax1 = plt.subplots()

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel('HFMat2_VDC', color=color)

ax1.plot(df_5_6step['HFMat2_VDC'], color=color)
ax1.tick_params(axis='y', labelcolor=color)



ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

color = 'tab:blue'
ax2.set_ylabel('MFC09_2_AO_OMCTS', color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step['MFC09_2_AO_OMCTS'], color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig, ax1 = plt.subplots()

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel('HFMat2_VDC', color=color)

ax1.plot(df_5_6step['HFMat2_VDC'], color=color)
ax1.tick_params(axis='y', labelcolor=color)



ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

color = 'tab:blue'
ax2.set_ylabel('MFC09_2_AO_OMCTS', color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step['MFC09_2_AO_OMCTS'], color=color)
ax2.tick_params(axis='y', labelcolor=color)

fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.show()
fig, ax1 = plt.subplots()

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel('HFMat2_VDC', color=color)

ax1.plot(df_5_6step['HFMat2_VDC'], color=color)
ax1.tick_params(axis='y', labelcolor=color)



ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

color = 'tab:blue'
ax2.set_ylabel('HFMat2_LOAD_POS', color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step['HFMat2_LOAD_POS'], color=color)
ax2.tick_params(axis='y', labelcolor=color)

fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.show()
fig, ax1 = plt.subplots()

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel('HFMat2_VDC', color=color)

ax1.plot(df_5_6step['HFMat2_VDC'], figsize=(8,5), color=color)
ax1.tick_params(axis='y', labelcolor=color)



ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

color = 'tab:blue'
ax2.set_ylabel('HFMat2_LOAD_POS', color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step['HFMat2_LOAD_POS'], figsize=(8,5), color=color)
ax2.tick_params(axis='y', labelcolor=color)

fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.show()
fig, ax1 = plt.subplots()

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel('HFMat2_VDC', color=color)

ax1.plot(df_5_6step['HFMat2_VDC'], color=color)
ax1.tick_params(axis='y', labelcolor=color)



ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

color = 'tab:blue'
ax2.set_ylabel('HFMat2_LOAD_POS', color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step['HFMat2_LOAD_POS'],  color=color)
ax2.tick_params(axis='y', labelcolor=color)

fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.show()
fig, ax1 = plt.subplots(figsize=(8,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel('HFMat2_VDC', color=color)

ax1.plot(df_5_6step['HFMat2_VDC'], color=color)
ax1.tick_params(axis='y', labelcolor=color)



ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

color = 'tab:blue'
ax2.set_ylabel('HFMat2_LOAD_POS', color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step['HFMat2_LOAD_POS'],  color=color)
ax2.tick_params(axis='y', labelcolor=color)

fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.show()
fig, ax1 = plt.subplots(figsize=(10,8))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel('HFMat2_VDC', color=color)
ax1.plot(df_5_6step['HFMat2_VDC'], color=color)
ax1.tick_params(axis='y', labelcolor=color)

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel('HFMat2_LOAD_POS', color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step['HFMat2_LOAD_POS'],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.show()
fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel('HFMat2_VDC', color=color)
ax1.plot(df_5_6step['HFMat2_VDC'], color=color)
ax1.tick_params(axis='y', labelcolor=color)

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel('HFMat2_LOAD_POS', color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step['HFMat2_LOAD_POS'],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.show()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel(y1, color=color)
ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.show()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel(y1, color=color)
ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.legend()
plt.show()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel(y1, color=color)
ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
plt.legend()

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.legend()
plt.show()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel(y1, color=color)
ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
ax1.legend()

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
ax2.legend()
plt.show()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel(y1, color=color)
ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
ax1.legend()

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
#ax2.legend()
plt.show()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel(y1, color=color)
ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
ax1.legend()

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
ax2.legend()
plt.show()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel(y1, color=color)
ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
ax1.legend(loc='down left')

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
ax2.legend(loc='upper left')
plt.show()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel(y1, color=color)
ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
ax1.legend(loc='center right')

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
ax2.legend(loc='center right')
plt.show()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel(y1, color=color)
lns1 = ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
ax1.legend(loc='center right')

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
lns2 = ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
ax2.legend(loc='center right')
plt.show()
fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel(y1, color=color)
lns1 = ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
ax1.legend(loc='center right')

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
lns2 = ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
ax2.legend(loc='center right')

lns = lns1+lns2
labs = [l.get_label() for l in lns]
ax1.legend(lns, labs, loc=0)
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('time')
ax1.set_ylabel(y1, color=color)
lns1 = ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
#ax1.legend(loc='center right')

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
lns2 = ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
#ax2.legend(loc='center right')

lns = lns1+lns2
labs = [l.get_label() for l in lns]
ax1.legend(lns, labs, loc='center right')


plt.show()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('Time')
ax1.set_ylabel(y1, color=color)
lns1 = ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
#ax1.legend(loc='center right')
ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
lns2 = ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
#ax2.legend(loc='center right')

lns = lns1+lns2
labs = [l.get_label() for l in lns]
ax1.legend(lns, labs, loc='center right')
plt.show()
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")


'''
label 이름 붙여주려고
'''
label = list(Vdc_cor_sort.index.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
label = list(Vdc_cor_sort.index.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)

for i, v in enumerate(label):
    ax.text(v + 3, i + .25, str(v), color='blue', fontweight='bold')

label
Vdc_cor_sort
Vdc_cor_sort['HFMat2_VDC']
Vdc_cor_sort.iloc[1,1]
Vdc_cor_sort.loc[1,:]
Vdc_cor_sort.loc[",:]
Vdc_cor_sort.loc[:,:]
Vdc_cor_sort.values
Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
label = list(Vdc_cor_sort.index.values)
values = list(Vdc_cor_sort.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)

for i, v in enumerate(values):
    plt.text(values[i] - 0.25, v + 0.01, str(v))

final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
label = list(Vdc_cor_sort.index.values)
values = list(Vdc_cor_sort.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)

for i, v in enumerate(values):
    plt.text(values[i] - 1, v + 1, str(v))

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
label = list(Vdc_cor_sort.index.values)
values = list(Vdc_cor_sort.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)

for i, v in enumerate(values):
    plt.text(values[i] - 5, v + 1, str(v))

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
label = list(Vdc_cor_sort.index.values)
values = list(Vdc_cor_sort.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)

for i, v in enumerate(values):
    plt.text(values[i] - 5, v + 1, str(v))

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
label = list(Vdc_cor_sort.index.values)
values = list(Vdc_cor_sort.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)

for i, v in enumerate(values):
    plt.text(values[i] - 0.01, v + 5, str(v))

label = list(Vdc_cor_sort.index.values)
values = list(Vdc_cor_sort.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)

for i, v in enumerate(values):
    plt.text(values[i] - 0.25, v + 1, str(v))

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
label = list(Vdc_cor_sort.index.values)
values = list(Vdc_cor_sort.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)

for i, v in enumerate(values):
    plt.text(values[i], v + 1, str(v), va = 'center')

Vdc_cor_sort.values
round(Vdc_cor_sort.values,2)
corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
np.set_printoptions(precision=2)

label = list(Vdc_cor_sort.index.values)
values = list(Vdc_cor_sort.values)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)

for i, v in enumerate(values):
    plt.text(values[i], v + 1, str(v), va = 'center')

Vdc_cor_sort.values
values
values = list(Vdc_cor_sort.values)
values
list(Vdc_cor_sort.values)
np.set_printoptions(precision=2)

label = list(Vdc_cor_sort.index.values)
values = list(Vdc_cor_sort.values
np.set_printoptions(precision=2)

label = list(Vdc_cor_sort.index.values)
values = list(Vdc_cor_sort.values)
values
Vdc_cor_sort.values
values = np.round(list(Vdc_cor_sort.values),2)
values
corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
np.set_printoptions(precision=2)

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)

for i, v in enumerate(values):
    plt.text(values[i], v + 1, str(v), va = 'center')

bars = ax.bar(x, height=y, width=.4)
bars = ax.bar(label, height=y, width=.4)

# access the bar attributes to place the text in the appropriate location
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x(), yval + .005, yval)

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
np.set_printoptions(precision=2)

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)


bars = ax.bar(label, height=values, width=.4)

# access the bar attributes to place the text in the appropriate location
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x(), yval + .005, yval)

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
np.set_printoptions(precision=2)

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)
bars = ax.bar(label, height=values, width=.4)

# access the bar attributes to place the text in the appropriate location
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x(), yval + .005, yval)

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''
np.set_printoptions(precision=2)

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)


bars = ax.bar(label, height=values, width=.4)

# access the bar attributes to place the text in the appropriate location
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x(), yval + .005, yval)

yval
bars = ax.bar(label, height=values, width=.4)
bars
Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'blue')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)


bars = ax.bar(label, height=values, width=.4)

# access the bar attributes to place the text in the appropriate location
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x(), yval + .005, yval)

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)
yval
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x(), yval + .005, yval)

bars = ax.bar(label, height=values, width=.4)

# access the bar attributes to place the text in the appropriate location
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x(), yval + .005, yval)

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)
Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)


bars = ax.bar(label, height=values, width=.4)

# access the bar attributes to place the text in the appropriate location
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x(), yval + .005, yval)

label
for i in range(len(label)):
    plt.text(x = label[i]-0.5 , y = values+0.1, s = label[i], size = 6)

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)




for i in range(len(label)):
    plt.text(x = label[i]-0.5 , y = values+0.1, s = label[i], size = 6)

def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom')

autolabel(ax)
Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()


'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax.set_ylabel("Correlation")

'''
label 이름 붙여주려고
'''

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)






def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom')


autolabel(ax)
fig.tight_layout()

plt.show()
ax
ax = ax.bar(label, values, figsize=(15,8), color = 'black')
ax = ax.bar(label, values,  color = 'black')
ax
plt.show()
ax = ax.bar(label, values,  color = 'black')
plt.show()
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()
'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)
Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()
'''
Series 데이터를 dataframe으로 바꿔주는거 왜냐 series만으로 바그래프를 못그리기 때문

ax = final.plot(figsize=(10,7), kind='barh') 가로로 보여주는게 더 좋을수도
'''
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel("Correlation")
fig, ax = plt.subplots()
test = ax.bar(label, values)
fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom')

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')






def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom')



autolabel(test)
height
autolabel(test)
test.get_height()
corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=10)



corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=20)



corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=15)



corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=12)



corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=12)

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
plt.plot('HFMat2_phase', 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.2)
plt.plot('HFMat2_phase', 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
plt.xlabel('HFMat2_Zr', fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot('HFMat2_phase', 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_phase',
plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)
plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)
plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_phase',

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x
x = 'HFMat2_phase'
x
plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_phase'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3, figsize=(5,5))
x = 'HFMat2_phase'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Zi'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'MFC09-1-AI_OMCTS'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'MFC09_1_AI_OMCTS'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'StgHtr1_PowerReadOutAI'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HT16_POW_1_SH_Heat'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Imag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
file_list
f = open(path_dir +  '\\' +  file_list[19]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]
corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
cor calc
'''
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)

cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')

cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
x = 'STGHTR1_VoltagelInAI'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Zr'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'MFC01_2_AI_O2'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'FORELINE_PRESS_GAUGE_AI'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_phase'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat1_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat1_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_TUNE_POS'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat1_TUNE_POS'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
%clear
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=12)


import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()


f = open(path_dir +  '\\' +  file_list[20]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
'''
cor calc
'''
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
x = 'HFMat1_TUNE_POS'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_TUNE_POS'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat1_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat1_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
df_5_6step['HFMat1_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
%clear
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=12)


import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
file_list[20]
file_list[15]
f = open(path_dir +  '\\' +  file_list[15]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat1_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat1_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
df_5_6step['HFMat1_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
file_list
%clear
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=12)


import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()
file_list[20]
f = open(path_dir +  '\\' +  file_list[20]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat1_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
cor_table_col_name
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
cols = [c for c in df_5_6step.columns if c.lower()[:] != 'HF1_']
df_5_6step[cols = [c for c in df_5_6step.columns if c.lower()[:] != 'HF1_']]
df]cols]
df[cols]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex=['HF1', 'HFMAT1'])))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMAT1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMat1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='LF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='TEMP_1')))]
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='StgHtr1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='STGHTR1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='POW_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='RPG1')))]
corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
file_list
f = open(path_dir +  '\\' +  file_list[18]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMat1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='LF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='TEMP_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='StgHtr1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='STGHTR1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='POW_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='RPG1')))]
'''
cor calc
'''
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
x = 'HFMat2_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'STGHTR2_VoltageInAI'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'STGHTR2_CurrentInAI'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'StgHtr2_PowerReadOutAI'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'StgHtr2_PowerReadInAI'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HF2_ForwardPowerAI'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
f = open(path_dir +  '\\' +  file_list[20]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMat1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='LF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='TEMP_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='StgHtr1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='STGHTR1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='POW_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='RPG1')))]
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'STGHTR2_VoltageInAI'
#x = 'STGHTR2_CurrentOutAI'
#x = 'HF2_ForwardPowerAI'
#x = 'HFMat2_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'STGHTR2_CurrentInAI'
#x = 'HF2_ForwardPowerAI'
#x = 'HFMat2_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'STGHTR2_PowerReadOutAI'
#x = 'HF2_ForwardPowerAI'
#x = 'HFMat2_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)

x = 'StgHtr2_PowerReadOutAI'
#x = 'HF2_ForwardPowerAI'
#x = 'HFMat2_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)


x = 'HF2_ForwardPowerAI'
#x = 'HFMat2_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
file_list[15]
file_list[14]
file_list[6]
file_list[13]
file_list[15]
f = open(path_dir +  '\\' +  file_list[15]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat1_VDC'].plot(figsize=(8,5)).line()
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMat1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='LF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='TEMP_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='StgHtr1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='STGHTR1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='POW_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='RPG1')))]
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
%clear
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=12)


import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
file_list[15]
file_list[14]
file_list[13]
f = open(path_dir +  '\\' +  file_list[13]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat1_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat2_VDC']
df_5_6step['HFMat1_VDC']
file_list[14]
f = open(path_dir +  '\\' +  file_list[14]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat1_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
a = df_5_6step['HFMat2_VDC']
a = df_5_6step[['StepNo', 'HFMat2_VDC']]
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMat1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='LF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='TEMP_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='StgHtr1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='STGHTR1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='POW_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='RPG1')))]
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
x = 'HFMat2_Zmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
file_list[11]
file_list[12]
f = open(path_dir +  '\\' +  file_list[12]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMat1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='LF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='TEMP_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='StgHtr1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='STGHTR1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='POW_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='RPG1')))]
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')

x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Zmag'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
AA = df_5_6step['HFMat2_Zmag']
AA
AA = df_5_6step['HFMat2_Zmag']
df_5_6step.loc[491:end]
df_5_6step.loc[491:len(df_5_6step)]
AA
df_5_6step[df_5_6step['HFMat2_VDC'] > 0]
df_5_6step[df_5_6step['HFMat2_Zmag'] > 0]
x = 'HFMat2_Zmag'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step['HFMat2_Zmag'] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
file_list[12]
temp = df_5_6step[df_5_6step[x] > 0].corr()
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
file_list[12]
f = open(path_dir +  '\\' +  file_list[14]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Zmag'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
temp = df_5_6step[df_5_6step[x] > 0].corr()
f = open(path_dir +  '\\' +  file_list[12]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
x = 'HFMat2_Zmag'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
temp = df_5_6step[df_5_6step[x] > 0].corr()
import scipy.stats as stats
test_df = df_5_6step[df_5_6step[x] > 0]
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Vmag)
test
plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3, kind = 'reg')
plt.regplot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
import seaborn as sns
sns.regplot(test_df.HFMat2_VDC, test_df.HFMat2_Vmag, color = 'blue')
sns.regplot(test_df.HFMat2_Vmag,test_df.HFMat2_VDC, color = 'blue')
f = open(path_dir +  '\\' +  file_list[17]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMat1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='LF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='TEMP_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='StgHtr1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='STGHTR1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='POW_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='RPG1')))]
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)



test_df = df_5_6step[df_5_6step[x] > 0]


temp = df_5_6step[df_5_6step[x] > 0].corr()
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Vmag)
test
import seaborn as sns
sns.regplot(test_df.HFMat2_Vmag, test_df.HFMat2_VDC, color = 'blue')
x = 'HFMat2_Zmag'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Zmag)
test
f = open(path_dir +  '\\' +  file_list[10]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat1_VDC'].plot(figsize=(8,5)).line()
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HF2')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMat2')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='LF2')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='TEMP_2')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='StgHtr2')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='STGHTR2')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='POW_2')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='RPG2')))]
x = 'HFMat1_Zmag'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat1_VDC', fontsize=14)

plt.plot(x, 'HFMat1_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat1_Vmag'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat1_VDC', fontsize=14)

plt.plot(x, 'HFMat1_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
f = open(path_dir +  '\\' +  file_list[11]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat1_VDC'].plot(figsize=(8,5)).line()
test
test_sp = stats.spearmanr(test_df.HFMat2_VDC, test_df.HFMat2_Zmag)
test_sp
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()


f = open(path_dir +  '\\' +  file_list[20]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < -25]
plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Zmag)
test
f = open(path_dir +  '\\' +  file_list[19]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMat1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='LF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='TEMP_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='StgHtr1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='STGHTR1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='POW_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='RPG1')))]
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < -10]
plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Zmag)
test
est_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < 0]
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Zmag)
test
plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < -5]


plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)



import scipy.stats as stats
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Zmag)
test
f = open(path_dir +  '\\' +  file_list[12]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < 0]


plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Zmag)
test
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Vmag)
TEST
test
f = open(path_dir +  '\\' +  file_list[20]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMat1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='LF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='TEMP_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='StgHtr1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='STGHTR1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='POW_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='RPG1')))]
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < 0]


plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < -25]


plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Vmag)
test
f = open(path_dir +  '\\' +  file_list[19]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)
'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < 0]


plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Vmag)
test
test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < -5]


plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)



import scipy.stats as stats
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Vmag)
test
test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < 0]


plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Vmag)
test
f = open(path_dir +  '\\' +  file_list[14]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
test_df = df_5_6step.loc[487:1270]
x = 'HFMat2_Vmag'
plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Vmag'
test_df = test_df[test_df[x] > 0]
plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test_df = test_df[test_df['HFMat2_VDC'] < 10]

plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Vmag)
test
plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 5, color = 'black',alpha = 0.5)
%clear
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=12)


import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
file_list[14]
f = open(path_dir +  '\\' +  file_list[20]) 
lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]
df_5_6step.loc[610:700,['HFMat2_LOAD_POS','HFMat2_VDC']].plot(figsize=(8,5)).line()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_LOAD_POS'

fig, ax1 = plt.subplots(figsize=(10,5))

color = 'tab:red'
ax1.set_xlabel('Time')
ax1.set_ylabel(y1, color=color)
lns1 = ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
#ax1.legend(loc='center right')
ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
lns2 = ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
#ax2.legend(loc='center right')

lns = lns1+lns2
labs = [l.get_label() for l in lns]
ax1.legend(lns, labs, loc='center right')
plt.show()
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_Vmag'

fig, ax1 = plt.subplots(figsize=(10,5))
color = 'tab:red'
ax1.set_xlabel('Time')
ax1.set_ylabel(y1, color=color)
lns1 = ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
#ax1.legend(loc='center right')
ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
lns2 = ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
#ax2.legend(loc='center right')
lns = lns1+lns2
labs = [l.get_label() for l in lns]
ax1.legend(lns, labs, loc='center right')
plt.show()
HFMat2_VDC
df_5_6step.loc[610:700,['MFC09_2_AO_OMCTS','MFC09_2_P1_PRESSURE_AI','HFMat2_VDC']].plot(figsize=(8,5)).line()
cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)

'''
cor_table[['HFMat1_VDC','HFMat2_VDC']]
지금은 Side2에서만 평가하는 듯? Matcher1,2에따라 다를 듯
'''

corr = 0.7

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')


autolabel(test)
plt.matshow(df_5_6step[['HFMat2_Zr','HFMat2_VDC']].corr())
plt.matshow(df_5_6step[['HFMat2_Zr','HFMat2_VDC']].corr())
plt.show()
plt.plot('HFMat2_Zr', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black')
plt.title('Scatter Plot of Vdc by matplotlib', fontsize=20)
plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

plt.plot(x, 'HFMat2_VDC', data = df_5_6step[df_5_6step[x] > 0], 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < 0]

plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Vmag)
import scipy.stats as stats
sns.regplot(test_df.HFMat2_Vmag, test_df.HFMat2_VDC, color = 'blue')
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Vmag)
test
import seaborn as sns
sns.regplot(test_df.HFMat2_Vmag, test_df.HFMat2_VDC, color = 'blue')
temp = df_5_6step[df_5_6step[x] > 0].corr()
final = pd.DataFrame({'variable' : Vdc_cor_sort.index , 'value' : Vdc_cor_sort.values})
ax = final.plot(figsize=(15,8), kind='bar', color = 'black')
#ax.set_xlabel("x label")
ax = ax.bar(label, values,  color = 'black')
plt.show()
%clear
import scipy.stats as stats
import seaborn as sns

def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=12)


import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()


f = open(path_dir +  '\\' +  file_list[20]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='HFMat1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='LF1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='TEMP_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='StgHtr1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='STGHTR1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='POW_1')))]
df_5_6step = df_5_6step[df_5_6step.columns.drop(list(df_5_6step.filter(regex='RPG1')))]
y1 = 'HFMat2_VDC'
y2 = 'HFMat2_Vmag'

fig, ax1 = plt.subplots(figsize=(10,5))
color = 'tab:red'
ax1.set_xlabel('Time')
ax1.set_ylabel(y1, color=color)
lns1 = ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
#ax1.legend(loc='center right')
ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
lns2 = ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
#ax2.legend(loc='center right')
lns = lns1+lns2
labs = [l.get_label() for l in lns]
ax1.legend(lns, labs, loc='center right')
plt.show()
corr = 0.7

cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')
autolabel(test)
aa = df_5_6step[['HFMat2_Imag','HFMat2_VDC']]
plt.plot('HFMat2_Imag', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black')
plt.plot('MFC09_2_AI_OMCATS', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black')
plt.plot('MFC09_2_AI_OMCTS', 'HFMat2_VDC', data = df_5_6step, linestyle = 'none', marker = 'o', markersize = 3, color = 'black')
test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < 0]
sns.regplot(test_df.MFC09_2_AI_OMCTS, test_df.HFMat2_VDC, color = 'blue')
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < 0]
sns.regplot(test_df.MFC09_2_AI_OMCTS, test_df.HFMat2_VDC, color = 'blue')
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Zmag)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.MFC09_2_AI_OMCTS)
test
%clear
import scipy.stats as stats
import seaborn as sns
def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=12)

import scipy.stats as stats
import seaborn as sns
import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np


def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom', fontsize=12)

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리_CVD#6'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
file_list[1]
f = open(path_dir +  '\\' +  file_list[1]) 
lines = f.readlines()
labels = lines[11].split() # line 0 : Factor  
df = pd.DataFrame(columns = labels)
lines[13]
lines[12]
i=13
temp = lines[i]
temp
temp = temp.split('\t')
temp = temp.split(' ')
temp = temp.split('                    ')
temp = lines[13]
temp
temp = temp.split('                    ')
temp = lines[13]
temp = temp.split()
for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()# 알아서 공백으로 나눠짐 ㅋ
    
    df.loc[i-13] = temp

df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['Recioe_Step_Number'] == 5) | (df_1['Recioe_Step_Number'] == 6)]
df_5_6step = df_1.loc[(df_1['Recipe_Step_Number'] == 5) | (df_1['Recipe_Step_Number'] == 6)]
df_5_6step['HF_VDC_A'].plot(figsize=(8,5)).line()
x = 'HF_Vmag_A'

plt.xlabel(x, fontsize=14)
plt.ylabel('HF_VDC_A', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HF_VDC_A'] < 0]

plt.plot(x, 'HF_VDC_A', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
TEST
test
test = stats.pearsonr(test_df.HF_VDC_A, test_df.HF_Vmag_A)
test
corr = 0.7

cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)

Vdc_cor = cor_table['HF_VDC_A'].loc[(cor_table['HF_VDC_A'] > corr ) | (cor_table['HF_VDC_A'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')
autolabel(test)
file_list[1]
x = 'HF_Imag_A'
plt.xlabel(x, fontsize=14)
plt.ylabel('HF_VDC_A', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HF_VDC_A'] < 0]

plt.plot(x, 'HF_VDC_A', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HF_VDC_A, test_df.HF_Imag_A)
test
x = 'HF_Zmag_A'

plt.xlabel(x, fontsize=14)
plt.ylabel('HF_VDC_A', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HF_VDC_A'] < 0]

plt.plot(x, 'HF_VDC_A', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HF_VDC_A, test_df.HF_Zmag_A)
test
df_5_6step['HF_VDC_A'].max
Max(df_5_6step['HF_VDC_A'])
df_5_6step['HF_VDC_A'].max()
df_5_6step['HF_VDC_A'].min()
df_5_6step['HF_VDC_A'].max() - df_5_6step['HF_VDC_A'].min()
file_list[0]
f = open(path_dir +  '\\' +  file_list[0]) 

lines = f.readlines()
labels = lines[11].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()# 알아서 공백으로 나눠짐 ㅋ
    
    df.loc[i-13] = temp


#df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['Recipe_Step_Number'] == 5) | (df_1['Recipe_Step_Number'] == 6)]
df_5_6step['HF_VDC_A'].plot(figsize=(8,5)).line()
df_5_6step['HF_VDC_A'].max() - df_5_6step['HF_VDC_A'].min()
x = 'HF_Zmag_A'

plt.xlabel(x, fontsize=14)
plt.ylabel('HF_VDC_A', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HF_VDC_A'] < 0]

plt.plot(x, 'HF_VDC_A', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HF_VDC_A, test_df.HF_Zmag_A)
test
x = 'HF_Vmag_A'
#x = 'HF_Imag_A'
#x = 'HF_Zmag_A'

plt.xlabel(x, fontsize=14)
plt.ylabel('HF_VDC_A', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HF_VDC_A'] < 0]

plt.plot(x, 'HF_VDC_A', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HF_VDC_A, test_df.HF_Vmag_A)
test
corr = 0.7

cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)

Vdc_cor = cor_table['HF_VDC_A'].loc[(cor_table['HF_VDC_A'] > corr ) | (cor_table['HF_VDC_A'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')
autolabel(test)
corr = 0.7

cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)

Vdc_cor = cor_table['HF_VDC_A'].loc[(cor_table['HF_VDC_A'] > corr ) | (cor_table['HF_VDC_A'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))
fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')
fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')
autolabel(test)
f = open(path_dir +  '\\' +  file_list[1]) 

lines = f.readlines()
labels = lines[11].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()# 알아서 공백으로 나눠짐 ㅋ
    
    df.loc[i-13] = temp


#df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')




df_5_6step = df_1.loc[(df_1['Recipe_Step_Number'] == 5) | (df_1['Recipe_Step_Number'] == 6)]


'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HF_VDC_A'].plot(figsize=(8,5)).line()
df_5_6step['HF_VDC_A'].max() - df_5_6step['HF_VDC_A'].min()
plt.xlabel(x, fontsize=14)
plt.ylabel('HF_VDC_A', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HF_VDC_A'] < 0]

plt.plot(x, 'HF_VDC_A', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HF_VDC_A, test_df.HF_Imag_A)
test
x = 'HF_Imag_A'
#x = 'HF_Zmag_A'

plt.xlabel(x, fontsize=14)
plt.ylabel('HF_VDC_A', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HF_VDC_A'] < 0]

plt.plot(x, 'HF_VDC_A', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HF_VDC_A, test_df.HF_Imag_A)
test
plt.xlabel(x, fontsize=14)
plt.ylabel('HF_VDC_A', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HF_VDC_A'] < 0]

plt.plot(x, 'HF_VDC_A', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HF_VDC_A, test_df.HF_Zmag_A)
x = 'HF_Zmag_A'

plt.xlabel(x, fontsize=14)
plt.ylabel('HF_VDC_A', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HF_VDC_A'] < 0]

plt.plot(x, 'HF_VDC_A', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HF_VDC_A, test_df.HF_Zmag_A)
test
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list[1]
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()
file_list[0]
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리'
file_list = os.listdir(path_dir)
file_list.sort()


f = open(path_dir +  '\\' +  file_list[0]) 

lines = f.readlines()
labels = lines[1].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(3, len(lines)):
    temp = lines[i]
    temp = temp.split('\t')
    
    df.loc[i-3] = temp


df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'StepNo':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_5_6step = df_1.loc[(df_1['StepNo'] == 5) | (df_1['StepNo'] == 6)]
del df_5_6step["N/A"]

'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HFMat2_VDC'].plot(figsize=(8,5)).line()
df_5_6step['HFMat2_VDC'].max() - df_5_6step['HFMat2_VDC'].min()
x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < 0]

plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Vmag)
test
x = 'HFMat2_Zmag'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]
test_df = df_5_6step[df_5_6step['HFMat2_VDC'] < 0]

plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
test = stats.pearsonr(test_df.HFMat2_VDC, test_df.HFMat2_Zmag)
test
x = 'HFMat2_Zmag'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]


plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
x = 'MFC09_2_P1_PRESSURE_AI'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]


plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
y1 = 'HFMat2_VDC'
y2 = 'MFC09_2_P1_PRESSURE_AI'

fig, ax1 = plt.subplots(figsize=(10,5))
color = 'tab:red'
ax1.set_xlabel('Time')
ax1.set_ylabel(y1, color=color)
lns1 = ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
#ax1.legend(loc='center right')
ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
lns2 = ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
#ax2.legend(loc='center right')
lns = lns1+lns2
labs = [l.get_label() for l in lns]
ax1.legend(lns, labs, loc='center right')
plt.show()
x = 'FORELINE_PRESS_GAUGE_AI'
#x = 'MFC09_2_P1_PRESSURE_AI'
#x = 'HFMat2_Vmag'

plt.xlabel(x, fontsize=14)
plt.ylabel('HFMat2_VDC', fontsize=14)

test_df = df_5_6step[df_5_6step[x] > 0]


plt.plot(x, 'HFMat2_VDC', data =test_df, 
         linestyle = 'none', marker = 'o', markersize = 3, color = 'black',alpha = 0.3)
y1 = 'HFMat2_VDC'
y2 = 'FORELINE_PRESS_GAUGE_AI'

fig, ax1 = plt.subplots(figsize=(10,5))
color = 'tab:red'
ax1.set_xlabel('Time')
ax1.set_ylabel(y1, color=color)
lns1 = ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
#ax1.legend(loc='center right')
ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
lns2 = ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
#ax2.legend(loc='center right')
lns = lns1+lns2
labs = [l.get_label() for l in lns]
ax1.legend(lns, labs, loc='center right')
plt.show()
corr = 0.5

cor_table = df_5_6step.corr()
cor_table_col_name = list(cor_table.columns.values)

Vdc_cor = cor_table['HFMat2_VDC'].loc[(cor_table['HFMat2_VDC'] > corr ) | (cor_table['HFMat2_VDC'] < -corr) ]
Vdc_cor_sort = Vdc_cor.sort_values()

label = list(Vdc_cor_sort.index.values)
values = np.round(list(Vdc_cor_sort.values),2)
index = np.arange(len(label))

fig, ax = plt.subplots(figsize=(15,8))
test = ax.bar(label, values)
plt.xticks(index, label, fontsize=15, rotation = 85)
ax.set_ylabel('Correlation')
autolabel(test)
x=1
y=2
z=1.2
print(x+y)
print(x**y)
print(y**x)
print(y**y)
print("안녕") + print("잘 지내니")
print("안녕") + print(4)
print("안녕" + "잘 지내니")
print("안녕" + str(4))
if 1 > 2:
    print("hello")

if not 1 > 2:
    print("hello")

if 1>0 and 2>1:
    print("hello")

if 0>0 or 2>1:
    print("hello")

x=3 
if x>5:
    print()


elif x==3:
    print("Bye")
else:
    print("hi")
print("철수: 안녕? 넌 몇 살이니?")
print("영희: 나? 나느 20")
def chat():
    print("철수: 안녕? 넌 몇 살이니?")
    print("영희: 나? 나는 20")

chat()
def chat(name1, name2):
    print("%s: 안녕? 넌 몇 살이니?" % name1)
    print("%s: 나? 나는 20" % name2)

chat("알렉스", "윤하")
chat("철수", "윤하")
chat("철수", "윤하",20)
def chat(name1, name2, age):
    print("%s: 안녕? 넌 몇 살이니?" % name1)
    print("%s: 나? 나는 %d" % (name2, age))

chat("철수", "윤하", 30)
chat("알렉스", "윤하", 40)
def dsum(a, b):
    result = a +b
    return result



d=dsum(1,2)
print(d)
d=dsum(2,4)
print(d)
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리_CVD#6'
file_list = os.listdir(path_dir)
file_list.sort()


f = open(path_dir +  '\\' +  file_list[1]) 

lines = f.readlines()
labels = lines[11].split() # line 0 : Factor  


df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()# 알아서 공백으로 나눠짐 ㅋ
    
    df.loc[i-13] = temp


#df.rename(columns = {'$LOG_ITEM' : 'LOG_ITEM'}, inplace = True) #col 이름 변경
df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')




df_5_6step = df_1.loc[(df_1['Recipe_Step_Number'] == 5) | (df_1['Recipe_Step_Number'] == 6)]


'''
line graph 
'''

#HF1_ForwardPowerAI
df_5_6step['HF_VDC_A'].plot(figsize=(8,5)).line()
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200218 Low-k Arcing\로그 정리_CVD#6'
file_list = os.listdir(path_dir)
file_list.sort()


f = open(path_dir +  '\\' +  file_list[1]) 

lines = f.readlines()
y1 = 'HF_VDC_A'
y2 = 'HF_Zmag_A'

fig, ax1 = plt.subplots(figsize=(10,5))
color = 'tab:red'
ax1.set_xlabel('Time')
ax1.set_ylabel(y1, color=color)
lns1 = ax1.plot(df_5_6step[y1], color=color)
ax1.tick_params(axis='y', labelcolor=color)
#ax1.legend(loc='center right')
ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
color = 'tab:blue'
ax2.set_ylabel(y2, color=color)  # we already handled the x-label with ax1
lns2 = ax2.plot(df_5_6step[y2],  color=color)
ax2.tick_params(axis='y', labelcolor=color)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
#ax2.legend(loc='center right')
lns = lns1+lns2
labs = [l.get_label() for l in lns]
ax1.legend(lns, labs, loc='center right')
plt.show()
%clear
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    model = pandasModel(df_Meta_final)
    
    view = QTableView()
    
    view.setModel(model)
    view.resize(800, 600)
    view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.connect(self.data_Search)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_Search(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.connect(self.data_Search)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_Search(self):
        fname = data_Search.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.connect(self.data_Search)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_Search(self):
        fname = data_Search.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search = QPushButton("File Open")
        self.data_Search.connect(self.data_SearchClicked)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search = QPushButton("File Open")
        self.data_Search.connect(self.data_SearchClicked)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search = QPushButton("File Open")
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search = QPushButton("File Open")
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search = QPushButton("File Open")
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search = QPushButton("File Open")
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search = QPushButton("File Open")
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        #self.data_Search = QPushButton("File Open")
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        #self.data_Search = QPushButton("File Open")
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())



Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        self.label.setText(fname[0])

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        self.path_dir.setText(fname[0])

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        self.path_dir.setText(fname[0])

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        self.path_dir.setText(fname[0])

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Wafer viewer를 개발 중입니다. 
PyQt5를 사용해서 User가 Interactive하게 사용할 수 있는 프로그램을 개발 중입니다.

http://blog.rcnelson.com/building-a-matplotlib-gui-with-qt-designer-part-2/ 를 참고중
"""
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")





'''
class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

'''

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")





'''
class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

'''

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
    
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")





'''
class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

'''

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(2)
        self.meta_table_view.setRowCount(2)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

%clear
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(2)
        self.meta_table_view.setRowCount(2)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(2)
        self.meta_table_view.setRowCount(2)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))






'''
class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

'''

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        '''
        self.meta_table_view.setRowCount(2)
        self.meta_table_view.setRowCount(2)
        self.setTableWidgetData()
        '''
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        '''    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))
        '''





'''
class pandasModel(QAbstractTableModel):
    
    def __init__(self, data):
        QAbstractTableModel.__init__(self)
        self._data = data
    
    def rowCount(self, parent=None):
        return self._data.shape[0]
    
    def columnCount(self,parent=None):
        return self._data.shape[1]
    
    def data(self, index, role = Qt.DisplayRole):
        if index.isValid():
            if role == Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
    
    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self._data.columns[col]
        return None

'''

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    
    
    #model = pandasModel(df_Meta_final)
    
    #view = QTableView()
    
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    
    main.show()
    
    
    sys.exit(app.exec_())


import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        '''
        self.meta_table_view.setRowCount(2)
        self.meta_table_view.setRowCount(2)
        self.setTableWidgetData()
        '''
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        '''    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))
        '''


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.rowCount(2)
        self.meta_table_view.columnCount(2)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.rowCount(2)
        self.meta_table_view.columnCount(2)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.rowCount(2)
        self.meta_table_view.columnCount(2)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.rowCount(2)
        self.meta_table_view.columnCount(2)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(2)
        self.meta_table_view.setColumnCount(2)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(2)
        self.meta_table_view.setColumnCount(2)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("(0,0)"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(2)
        self.meta_table_view.setColumnCount(2)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem("(0,1)"))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기
file_list[3]
for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
df_Meta
num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Meta_final
%clear

## ---(Thu Feb 27 11:26:11 2020)---
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

import data_processing.py
import data_processing
import data_processing.py
f= open('data_processing.py','wb')
f.write(code.encode())
df_Meta_final
df_Meta_final.loc[5,1]
df_Meta_final[1,1]
df_Meta_final(5,5)
df_Meta_final.loc(5,5)
df_Meta_final.loc[5,5]
df_Meta_final.loc[5]
df_Meta_final.iloc[5,1]
df_Meta_final.iloc[5,3]
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[5,3]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[5,3]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[5,3]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[5,3]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
import sys
from PyQt5.QtWidgets import *    

from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)


from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)


import sys
import pandas as pd
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

#import data_processing.py

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
"""

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[5,3]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
            self.meta_table_view.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[5,3]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[5,3]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

"""

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[5,3]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

"""

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[5,3]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    fig1 = Figure()
    ax1f1 = fig1.add_subplot(111) 
    img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    fig1.colorbar(img)
    
    fig2 = Figure()
    ax1f2 = fig2.add_subplot(111) 
    ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    main.addmpl(fig1)
    main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

"""

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk"))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[5,3]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem("(1,0)"))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem("(1,1)"))



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

df_Meta_final.loc[0,1]
df_Meta_final.iloc[0,1]
df_Meta_final.iloc[0,2]
df_Meta_final.iloc[0,0]
df_Meta_final.iloc[0,1]
df_Meta_final.iloc[0,2]
df_Meta_final.iloc[0,3]
df_Meta_final.iloc[0,4]
df_Meta_final.iloc[0,0]
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 5, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

"""

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 5, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem(df_Meta_final.iloc[1,0]))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

"""

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

"""

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]


"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

"""
'''
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

'''

"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

"""
'''
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

'''

"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            
            
            
            
            
            
            
            
            self.path_dir.setText(fname[0])
        
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
    
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import numpy as np
import pandas as pd
import os
base_dir = r'C:\Users\Downloads'
excel_file = 'Coin_crack.xlsx'
excel_dir = os.path.join(base_dir, excel_file)
excel_dir
base_dir = r'C:\Users\wtjang\Downloads'

excel_file = 'Coin_crack.xlsx'

excel_dir = os.path.join(base_dir, excel_file)
excel_dir
df = pd.read_excel(excel_dir)
import matplotlib.pyplot as plt
import seaborn as sns
plt.rcParams['figure.figsize'] = [10, 8] # setting figure size
groups = df.groupby('Cause')
sns.scatterplot(x='S/N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
pip install --upgrade seaborn
sns.scatterplot(x='S/N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
plt.show()
import seaborn as sns
sns.scatterplot(x='S/N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
plt.show()
import numpy as np
import pandas as pd
import os

import matplotlib.pyplot as plt
import seaborn as sns
sns.scatterplot(x='S/N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
plt.show()
seaborn
sns.pairplot(x='S/N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
plt.show()
import matplotlib.pyplot as plt
import seaborn as sns
sns.scatterplot(x='S/N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
plt.show()
sns.distplot(df[df.Cause == 'Center crack']['Use_Period(days)'], color = 'red')
plt.show()
sns.distplot(df[df.Cause == 'Center crack']['Use_Period(days)'], color = 'red', label = 'Center crack')
sns.distplot(df[df.Cause == 'coin crack']['Use_Period(days)'], color = 'green', label = 'coin crack')
sns.distplot(df[df.Cause == 'ㅡ자 crack']['Use_Period(days)'], color = 'blue', label = 'ㅡ자 crack')
plt.show()
sns.distplot(df[df.Cause == 'ㅡ자 crack']['Use_Period(days)'], color = 'blue', label = 'ㅡ자 crack')
plt.show()
df.Cause.name
df.Cause.items
df.Cause.item
df.Cause.is_unique
sns.distplot(df[df.Cause == 'Center crack']['Use_Period(days)'], color = 'red', label = 'Center crack')
sns.distplot(df[df.Cause == 'coin crack']['Use_Period(days)'], color = 'green', label = 'coin crack')
sns.distplot(df[df.Cause == '一자 crack']['Use_Period(days)'], color = 'blue', label = 'ㅡ자 crack')
plt.show()
sns.distplot(df[df.Cause == 'Center crack']['Use_Period(days)'], color = 'red', label = 'Center crack')
sns.distplot(df[df.Cause == 'coin crack']['Use_Period(days)'], color = 'green', label = 'coin crack')
sns.distplot(df[df.Cause == '一자 crack']['Use_Period(days)'], color = 'blue', label = '一자 crack')
plt.show()
sns.distplot(df[df.Cause == 'Center crack']['Use_Period(days)'], color = 'red', label = 'Center crack')
sns.distplot(df[df.Cause == 'coin crack']['Use_Period(days)'], color = 'green', label = 'coin crack')
sns.distplot(df[df.Cause == '一자 crack']['Use_Period(days)'], color = 'blue', label = '一자 crack')
plt.legend(title="Cause")
plt.show()
sns.distplot(df[df.Cause == 'Center crack']['Use_Period(days)'], color = 'red', label = 'Center crack')
sns.distplot(df[df.Cause == 'coin crack']['Use_Period(days)'], color = 'green', label = 'coin crack')
sns.distplot(df[df.Cause == '一자 crack']['Use_Period(days)'], color = 'blue', label = '-자 crack')
plt.legend(title="Cause")
plt.show()
sns.distplot(df[df.Cause == 'Center crack']['Use_Period(days)'], color = 'red', label = 'Center crack')
sns.distplot(df[df.Cause == 'coin crack']['Use_Period(days)'], color = 'green', label = 'coin crack')
sns.distplot(df[df.Cause == '一자 crack']['Use_Period(days)'], color = 'blue', label = ' ㅡ shape crack')
plt.legend(title="Cause")
plt.show()
sns.distplot(df[df.Cause == 'Center crack']['Use_Period(days)'], color = 'red', label = 'Center crack')
sns.distplot(df[df.Cause == 'coin crack']['Use_Period(days)'], color = 'green', label = 'coin crack')
sns.distplot(df[df.Cause == '一자 crack']['Use_Period(days)'], color = 'blue', label = ' - shape crack')
plt.legend(title="Cause")
plt.show()
import pytesseract
pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract'
print(pytesseract.image_to_string('test.jpg'))
pytesseract.pytesseract.tesseract_cmd = r'C:\Users\wtjang\Downloads'
print(pytesseract.image_to_string('test.jpg'))

## ---(Mon Mar  2 14:33:34 2020)---
import pytesseract
pytesseract.pytesseract.tesseract_cmd = r'C:\Users\wtjang\Downloads'
print(pytesseract.image_to_string('test.jpg'))
pytesseract.image_to_string('test.jpg')
import pytesseract
pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR'

print(pytesseract.image_to_string('test.jpg'))
pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
print(pytesseract.image_to_string('test.jpg'))
pytesseract.pytesseract.tesseract_cmd = r'C:\\Program Files (x86)\\Tesseract-OCR\\tesseract'
print(pytesseract.image_to_string('test.jpg'))
pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files (x86)\Tesseract-OCR\tesseract'
print(pytesseract.image_to_string('test.jpg'))
pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR'
print(pytesseract.image_to_string('test.jpg'))
import pytesseract
pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR'
print(pytesseract.image_to_string('test.jpg'))
from PIL import Image
from pytesseract import *

filename = r"C:\Users\wtjang\Downloads\test.jpg"
filename
image = Image.open(filename)
text = image_to_string(image, lang="eng")
with open("sample.txt", "w") as f:
    f.write(text)

filename = r"C:\Users\wtjang\Downloads\test.jpg"
image = Image.open(filename)
text = image_to_string(image, lang="eng")
from PIL import Image
from pytesseract import *
import re
import cv2    
img = Image.open(r"C:\Users\wtjang\Downloads\test.jpg")
img
text = pytesseract.image_to_string(img,lang='ecu')#영어면 'euc'
pytesseract.pytesseract.tesseract_cmd = r'C:\\\Program Files\\\Tesseract-OCR\\\tesseract.exe'
act import *
from pytesseract import *
pytesseract.pytesseract.tesseract_cmd = r'C:\\\Program Files\\\Tesseract-OCR\\\tesseract.exe'
pytesseract.pytesseract.tesseract_cmd = "C:\Program Files\Tesseract-OCR\tesseract.exe"
import pytesseract
pytesseract.pytesseract.tesseract_cmd = "C:\Program Files\Tesseract-OCR\tesseract.exe"
text = pytesseract.image_to_string(img,lang='ecu')#영어면 'euc'
pytesseract.pytesseract.tesseract_cmd = "C:\Program Files\Tesseract-OCR"
text = pytesseract.image_to_string(img,lang='ecu')#영어면 'euc'
pytesseract.pytesseract.tesseract_cmd = "C:/Program Files/Tesseract 4.0.0/tesseract.exe"
text = pytesseract.image_to_string(img,lang='ecu')#영어면 'euc'
pytesseract.pytesseract.tesseract_cmd = "C:/Program Files/Tesseract-OCR/tesseract.exe"
text = pytesseract.image_to_string(img,lang='ecu')#영어면 'euc'
img
pytesseract
pytesseract.pytesseract.tesseract_cmd = "C:/Program Files/Tesseract-OCR/tesseract.exe"
text = pytesseract.image_to_string(img,lang='ecu')#영어면 'euc'
text = pytesseract.image_to_string(img,lang='euc')#영어면 'euc'
text = pytesseract.image_to_string(img,lang='eng')#영어면 'euc'
test
text
print(text)
df = pd.DataFrame()
import pandas as pd
df = pd.DataFrame()
len(text)
for i in range(2, len(text)):
    temp = text[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp

text[0]
text_1 = pytesseract.image_to_data(img,lang='eng')#영어면 'eng'
img = Image.open(r"C:\Users\wtjang\Downloads\test_2.jpg")

import pytesseract

# [WinError 5] 액세스가 거부되었습니다 해결
pytesseract.pytesseract.tesseract_cmd = "C:/Program Files/Tesseract-OCR/tesseract.exe"

text = pytesseract.image_to_string(img,lang='eng')#영어면 'eng' 근데 str로 읽어서 이거 또 처리해야댐
base_dir = r'C:\Users\wtjang\Downloads'
excel_file = 'Coin_crack.xlsx'
excel_dir = os.path.join(base_dir, excel_file)


df = pd.read_excel(excel_dir)
import numpy as np
import pandas as pd
import os

import matplotlib.pyplot as plt
import seaborn as sns



base_dir = r'C:\Users\wtjang\Downloads'
excel_file = 'Coin_crack.xlsx'
excel_dir = os.path.join(base_dir, excel_file)


df = pd.read_excel(excel_dir)
plt.rcParams['figure.figsize'] = [10, 8] # setting figure size


sns.scatterplot(x='S/N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
plt.show()


sns.pairplot(x='S/N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
plt.show()
plt.rcParams['figure.figsize'] = [10, 8] # setting figure size


sns.scatterplot(x='S/N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
plt.show()
sns.distplot(df[df.Cause == 'Center crack']['Use_Period(days)'], color = 'red', label = 'Center crack')
sns.distplot(df[df.Cause == 'coin crack']['Use_Period(days)'], color = 'green', label = 'coin crack')
sns.distplot(df[df.Cause == '一자 crack']['Use_Period(days)'], color = 'blue', label = ' - shape crack')
plt.legend(title="Cause")
plt.show()
df.No
df.S/N
df.'S/N'
df.'S/N
df.columns
df.S/N
import numpy as np
import pandas as pd
import os

import matplotlib.pyplot as plt
import seaborn as sns



base_dir = r'C:\Users\wtjang\Downloads'
excel_file = 'Coin_crack.xlsx'
excel_dir = os.path.join(base_dir, excel_file)


df = pd.read_excel(excel_dir)
sns.distplot(df[df.S_N >= 307]['Use_Period(days)'], color = 'red', label = 'Center crack')
sns.distplot(df[df.S_N <307]['Use_Period(days)'], color = 'green', label = 'coin crack')

plt.legend(title="S_N")
plt.show()
df.S_N
df.Use_Period(days)
df.Cause
df.No
df.columns
import numpy as np
import pandas as pd
import os

import matplotlib.pyplot as plt
import seaborn as sns



base_dir = r'C:\Users\wtjang\Downloads'
excel_file = 'Coin_crack.xlsx'
excel_dir = os.path.join(base_dir, excel_file)


df = pd.read_excel(excel_dir)
sns.pairplot(x='S_N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
plt.show()
sns.distplot(df[df.S_N >= 307]['Use_Period(days)'], color = 'red', label = 'Center crack')
sns.distplot(df[df.S_N <307]['Use_Period(days)'], color = 'green', label = 'coin crack')

plt.legend(title="S_N")
sns.distplot(df[df.S_N >= 307]['Use_Period(days)'], color = 'red', label = 'S/N > 307')
sns.distplot(df[df.S_N <307]['Use_Period(days)'], color = 'green', label = 'S/N < 307')

plt.legend(title="S/N")
plt.show()
sns.distplot(df[df.S_N >= 307]['Use_Period(days)'], color = 'blue', label = 'S/N > 307')
sns.distplot(df[df.S_N <307]['Use_Period(days)'], color = 'red', label = 'S/N < 307')

plt.legend(title="S/N")
plt.show()
df[df.S_N >= 307]['Use_Period(days)']
(df[df.S_N >= 307]['Use_Period(days)']).stat
stat(df[df.S_N >= 307]['Use_Period(days)'])
(df[df.S_N >= 307]['Use_Period(days)']).mean
aa = df[df.S_N >= 307]['Use_Period(days)'])
aa = df[df.S_N >= 307]['Use_Period(days)']
aa.mean
df_1 = df[df.S_N >= 307 ]['Use_Period(days)']
df_1[(df.Use_Periios(days)) >0 & (df.Use_Periios(days) <= 20)]
df_1[(df.Use_Periods(days)) >0 & (df.Use_Periios(days) <= 20)]
df_1[(df.Use_Period(days)) >0 & (df.Use_Periios(days) <= 20)]
df_1 = df[(df.Use_Period(days)) >0 & (df.Use_Periios(days) <= 20)]
df_1 = df[df.S_N >= 307]['Use_Period(days)']
df_1[df_1['Use_Period(days)'] <= 21]
[df_1['Use_Period(days)'] <= 21]
df_1['Use_Period(days)'] <= 21
df_1["Use_Period(days)"] <= 21
df_1["Use_Period(days)"] <21
df_1
df_1.columns
df_1[0]
df_1[1]
df_1(1)
df_1 = pd.Series.to_frame(df_1)
df_1["Use_Period(days)"] <21
d(f_1["Use_Period(days)"] <21).count
(df_1["Use_Period(days)"] <21).count
df[df_1["Use_Period(days)"] <21]
df_1[df_1["Use_Period(days)"] <21]
df_1[(df_1["Use_Period(days)"] > = 0) && (df_1["Use_Period(days)"] <21)]
df_1[(df_1["Use_Period(days)"] => 0) && (df_1["Use_Period(days)"] <21)]
df_1[(df_1["Use_Period(days)"] >= 0) && (df_1["Use_Period(days)"] <21)]
df_1[(df_1["Use_Period(days)"] > 0) && (df_1["Use_Period(days)"] <21)]
df_1[(df_1["Use_Period(days)"] > 0) & (df_1["Use_Period(days)"] <21)]
df_1[(df_1["Use_Period(days)"] > 0) & (df_1["Use_Period(days)"] <=21)]
df_1[(df_1["Use_Period(days)"] >= 0) & (df_1["Use_Period(days)"] <21)]
a_1 = df_1[(df_1["Use_Period(days)"] >= 0) & (df_1["Use_Period(days)"] <21)]
a_2 = df_1[(df_1["Use_Period(days)"] >= 21) & (df_1["Use_Period(days)"] <41)]
a_3 = df_1[(df_1["Use_Period(days)"] >= 41) & (df_1["Use_Period(days)"] <61)]
a_4 = df_1[(df_1["Use_Period(days)"] >= 61) & (df_1["Use_Period(days)"] <81)]
a_5 = df_1[(df_1["Use_Period(days)"] >= 81) & (df_1["Use_Period(days)"] <101)]
a_6 = df_1[(df_1["Use_Period(days)"] >= 101) & (df_1["Use_Period(days)"] <121)]
a_6 = df_1[(df_1["Use_Period(days)"] >= 121) & (df_1["Use_Period(days)"] <141)]
a_6 = df_1[(df_1["Use_Period(days)"] >= 141) & (df_1["Use_Period(days)"] <161)]
a_6 = df_1[(df_1["Use_Period(days)"] >= 161) & (df_1["Use_Period(days)"] <181)]
a_6 = df_1[(df_1["Use_Period(days)"] >= 181) & (df_1["Use_Period(days)"] <201)]
a_1 = df_1[(df_1["Use_Period(days)"] >= 0) & (df_1["Use_Period(days)"] <21)]
a_2 = df_1[(df_1["Use_Period(days)"] >= 21) & (df_1["Use_Period(days)"] <41)]
a_3 = df_1[(df_1["Use_Period(days)"] >= 41) & (df_1["Use_Period(days)"] <61)]
a_4 = df_1[(df_1["Use_Period(days)"] >= 61) & (df_1["Use_Period(days)"] <81)]
a_5 = df_1[(df_1["Use_Period(days)"] >= 81) & (df_1["Use_Period(days)"] <101)]
a_6 = df_1[(df_1["Use_Period(days)"] >= 101) & (df_1["Use_Period(days)"] <121)]
a_7 = df_1[(df_1["Use_Period(days)"] >= 121) & (df_1["Use_Period(days)"] <141)]
a_8 = df_1[(df_1["Use_Period(days)"] >= 141) & (df_1["Use_Period(days)"] <161)]
a_9 = df_1[(df_1["Use_Period(days)"] >= 161) & (df_1["Use_Period(days)"] <181)]
a_10 = df_1[(df_1["Use_Period(days)"] >= 181) & (df_1["Use_Period(days)"] <201)]
sns.distplot(df[df.Cause == 'Center crack']['Use_Period(days)'], color = 'red', label = 'Center crack')
sns.scatterplot(x='S_N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
plt.show()


sns.pairplot(x='S_N', y = 'Use_Period(days)', hue = 'Cause', style = 'Cause', s= 100, data=df)
plt.show()
import os
import pandas as pd
import numpy as np
df_eFSG = pd.read_excel(r'C:\Users\wtjang\Documents\work\Void_Free_Data.xlsx')
df_eFSG = pd.read_excel(r'C:\Users\wtjang\Documents\work\Void_Free_Data.xlsx', header=2)
Factor = ['O2', 'Ar','SiF4','TEOS','Pressure','HF','LF','Gap','Void_Bottom_up','Stress', 'WER', 'D_R']
df_final = df[Factor]
df_final = df[[Factor]]
df_final = df_eFSG[Factor]
from sklearn.model_selection import train_test_split
from sklearn import neighbors
from sklearn.metrics import mean_squared_error 
from math import sqrt
import matplotlib.pyplot as plt
train_x = train_data['O2', 'Ar','SiF4','TEOS','Pressure','HF','LF','Gap']
train_data, test_data = train_test_split(df_final, test_size = 0.2, random_state = 123)
train_x = train_data['O2', 'Ar','SiF4','TEOS','Pressure','HF','LF','Gap']
train_x = train_data[['O2', 'Ar','SiF4','TEOS','Pressure','HF','LF','Gap']]
train_y = train_data['Void_Bottom_up']
test_x = test_data[['O2', 'Ar','SiF4','TEOS','Pressure','HF','LF','Gap']]
test_y = test_data['Void_Bottom_up']
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0, 1))
train_x_scaled = scaler.fit_transform(train_x)
train_x = pd.DataFrame(train_x_scaled)
test_x_scaled = scaler.fit_transform(test_x)
test_x = pd.DataFrame(test_x_scaled)
rmse_val = []
for K in range(20):
    K = K+1
    
    model = neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

df_final = df_final.dropna(axis=0)
from sklearn.model_selection import train_test_split
from sklearn import neighbors
from sklearn.metrics import mean_squared_error 
from math import sqrt
import matplotlib.pyplot as plt

# train_test_split(arrays, test_size, train_size, random_state, shuffle, stratify)
train_data, test_data = train_test_split(df_final, test_size = 0.2, random_state = 123)

# seperate the independent and target variable on training data
train_x = train_data[['O2', 'Ar','SiF4','TEOS','Pressure','HF','LF','Gap']]
train_y = train_data['Void_Bottom_up']

test_x = test_data[['O2', 'Ar','SiF4','TEOS','Pressure','HF','LF','Gap']]
test_y = test_data['Void_Bottom_up']

# Preprocessing 전처리 한게 더 오차율 좋음 RMSE 100감소
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0, 1))

train_x_scaled = scaler.fit_transform(train_x)
train_x = pd.DataFrame(train_x_scaled)

test_x_scaled = scaler.fit_transform(test_x)
test_x = pd.DataFrame(test_x_scaled)
rmse_val = []

for K in range(20):
    K = K+1
    
    model = neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)

curve = pd.DataFrame(rmse_val)
curve.plot() # k에 따른 rmse 곡선
plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')

## ---(Tue Mar 10 15:41:15 2020)---
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem(df_Meta_final.iloc[1,1]))
        self.meta_table_view.setItem(1, 2, QTableWidgetItem(df_Meta_final.iloc[1,2]))
        self.meta_table_view.setItem(1, 3, QTableWidgetItem(df_Meta_final.iloc[1,3]))
        self.meta_table_view.setItem(1, 4, QTableWidgetItem(df_Meta_final.iloc[1,4]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

"""
'''
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

'''

"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem(df_Meta_final.iloc[1,1]))
        self.meta_table_view.setItem(1, 2, QTableWidgetItem(df_Meta_final.iloc[1,2]))
        self.meta_table_view.setItem(1, 3, QTableWidgetItem(df_Meta_final.iloc[1,3]))
        self.meta_table_view.setItem(1, 4, QTableWidgetItem(df_Meta_final.iloc[1,4]))



'''        
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))
 '''
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt

"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    

"""
'''
path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

'''

"""
C.I 이미지 가져오기

아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
"""
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)

"""
PyQt에서 UI파일을 사용하는 방법은 2가지

1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem(df_Meta_final.iloc[1,1]))
        self.meta_table_view.setItem(1, 2, QTableWidgetItem(df_Meta_final.iloc[1,2]))
        self.meta_table_view.setItem(1, 3, QTableWidgetItem(df_Meta_final.iloc[1,3]))
        self.meta_table_view.setItem(1, 4, QTableWidgetItem(df_Meta_final.iloc[1,4]))



'''        
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))
 '''
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem(df_Meta_final.iloc[1,1]))
        self.meta_table_view.setItem(1, 2, QTableWidgetItem(df_Meta_final.iloc[1,2]))
        self.meta_table_view.setItem(1, 3, QTableWidgetItem(df_Meta_final.iloc[1,3]))
        self.meta_table_view.setItem(1, 4, QTableWidgetItem(df_Meta_final.iloc[1,4]))



'''        
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))
 '''
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem(df_Meta_final.iloc[1,1]))
        self.meta_table_view.setItem(1, 2, QTableWidgetItem(df_Meta_final.iloc[1,2]))
        self.meta_table_view.setItem(1, 3, QTableWidgetItem(df_Meta_final.iloc[1,3]))
        self.meta_table_view.setItem(1, 4, QTableWidgetItem(df_Meta_final.iloc[1,4]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem(df_Meta_final.iloc[1,1]))
        self.meta_table_view.setItem(1, 2, QTableWidgetItem(df_Meta_final.iloc[1,2]))
        self.meta_table_view.setItem(1, 3, QTableWidgetItem(df_Meta_final.iloc[1,3]))
        self.meta_table_view.setItem(1, 4, QTableWidgetItem(df_Meta_final.iloc[1,4]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))
        self.meta_table_view.setItem(1, 1, QTableWidgetItem(df_Meta_final.iloc[1,1]))
        self.meta_table_view.setItem(1, 2, QTableWidgetItem(df_Meta_final.iloc[1,2]))
        self.meta_table_view.setItem(1, 3, QTableWidgetItem(df_Meta_final.iloc[1,3]))
        self.meta_table_view.setItem(1, 4, QTableWidgetItem(df_Meta_final.iloc[1,4]))



'''        
    def setTableWidgetData(self):
        self.meta_table_view.setItem(0, 0, QTableWidgetItem(df_Meta_final.iloc[0,0]))
        self.meta_table_view.setItem(0, 1, QTableWidgetItem(df_Meta_final.iloc[0,1]))
        self.meta_table_view.setItem(0, 2, QTableWidgetItem(df_Meta_final.iloc[0,2]))
        self.meta_table_view.setItem(0, 3, QTableWidgetItem(df_Meta_final.iloc[0,3]))
        self.meta_table_view.setItem(0, 4, QTableWidgetItem(df_Meta_final.iloc[0,4]))
        self.meta_table_view.setItem(1, 0, QTableWidgetItem(df_Meta_final.iloc[1,0]))
 '''
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)-1):
            for meta_col in range(0,4):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col])

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)-1):
            for meta_col in range(0,4):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)-1):
            for meta_col in range(0,4):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)-1):
            for meta_col in range(0,4):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(10)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)-1):
            for meta_col in range(0,4):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)-1):
            for meta_col in range(0,4):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
import sys
import os
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw()
    
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)-1):
            for meta_col in range(0,4):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

%clear
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_test = df_Stat.set_index('SLOT', append=True).swaplevel(0,1)
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
          
          for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
"""
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))


import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.meta_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

len(df_Stat)
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # SFX200 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

len(df_Stat))
len(df_Stat)
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Meta_final.iloc[stat_row,stat_col]))



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())




import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())


import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
"""
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))

import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())


Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))









if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())




import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
"""
"""
C.I 이미지 가져오기
아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)
"""
"""
PyQt에서 UI파일을 사용하는 방법은 2가지
1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))









if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())



import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())



import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
"""
Data frame 계산 속도 향상 필요, 현재 임의의 Wafer 계측값으로 사용. 추후 보간을 활용해 값 채워 넣는 알고리즘 개발 필요
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
"""
"""
C.I 이미지 가져오기
아래 오류 해결 - 폴더를 지정하는게 아니라 경로를 지정해야함!
[Errno 13] Permission denied: 'C:\\Users\\wtjang\\Wafer viewer'
from PIL import Image
CI_Path = r"C:\Users\wtjang\Wafer viewer\CI.JPG"
im = Image.open(CI_Path)
"""
"""
PyQt에서 UI파일을 사용하는 방법은 2가지
1. UI파일을 파이썬 코드로 변경해서 사용 -> UI가 변경될 때마다 계속 파이썬 코드로 변경해야하는 번거로움
2. UI파일을 파이썬 코드에서 로드하는 방법 -> loadUiType 사용해서 UI파일을 파이썬 코드에 이벤트로 처리
"""
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))









if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())


import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        #self.meta_table_view.setRowCount(25)
        #self.meta_table_view.setColumnCount(5)
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        #self.stat_table_view.setRowCount(30)
        #self.stat_table_view.setColumnCount(10)
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())




import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        #self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        #self.stat_table_view.setRowCount(30)
        self.stat_table_view.setColumnCount(10)
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())




import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
"""
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        # 사전에 테이블 row, col 이 정의되어야함.. 흠...;; 정해지지 않으면 출력x row, column 갯수 설정해야만 tablewidget 사용할수있다.
        
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        self.stat_table_view.setRowCount(75)
        self.stat_table_view.setColumnCount(10)
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())



import sys
import os
import pandas as pd 
import numpy as np
import matplotlib as mpl
import matplotlib.pylab as plt    
from PyQt5.QtWidgets import *    
from PyQt5.uic import loadUiType
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg as FigureCanvas,
    NavigationToolbar2QT as NavigationToolbar)
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QApplication, QWidget, 
                             QTableWidget, QTableWidgetItem, QAbstractItemView)
from PyQt5.QtWidgets import QApplication, QTableView
from PyQt5.QtCore import QAbstractTableModel, Qt
Ui_MainWindow, QMainWindow = loadUiType(r'C:\Users\wtjang\Wafer viewer\test_file_open.ui')

class Main(QMainWindow, Ui_MainWindow):
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)
        self.setStyleSheet("background-color : white;")  #Qmainwindow 배경처리
        self.setWindowTitle("Wafer viewer")
        
        self.data_Search.clicked.connect(self.data_SearchClicked)
        
        # 사전에 테이블 row, col 이 정의되어야함.. 흠...;; 정해지지 않으면 출력x row, column 갯수 설정해야만 tablewidget 사용할수있다.
        
        
        self.meta_table_view.setRowCount(25)
        self.meta_table_view.setColumnCount(5)
        self.meta_table_view.setHorizontalHeaderLabels(['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL'])
        
        
        
        
        self.stat_table_view.setRowCount(75)
        self.stat_table_view.setColumnCount(10)
        self.stat_table_view.setHorizontalHeaderLabels(['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE'])
        #self.setTableWidgetData()
    
    def addmpl(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl.addWidget(self.canvas)
        self.canvas.draw()
    
    def addmpl_2(self, fig):
        self.canvas = FigureCanvas(fig)
        self.mplvl_2.addWidget(self.canvas)
        self.canvas.draw() 
    
    def data_SearchClicked(self):
        fname = QFileDialog.getOpenFileName(self, 'Open file', "",
                                            "All Files(*);; Excel Files(*.xlsx);;Excel Files(*.csv)", '/home')
        
        if fname[0]:
            '''
            f = open(fname[0], 'r')
            flines = f.readlines()
            
            for line in flines:
                print(line)
            '''
            
            f = open(fname[0], 'r')
            lines = f.readlines()
            labels = lines[0].split(',') # line 0 : Factor  
            df = pd.DataFrame(columns = labels)
            
            for i in range(2, len(lines)):
                temp = lines[i]
                temp = temp.split(',')
                
                df.loc[i-2] = temp
            
            
            del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
            df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
            df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
            df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]
            
            
            num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
            num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])
            
            num_Wafer =num_last_Wafer - num_first_Wafer + 1
            num_Feature = len(df_Meta) / num_Wafer
            
            df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
            
            for k in range(0, num_Wafer):
                df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]
            
            self.path_dir.setText(fname[0])
        
        else:
            QMessageBox.about(self, "Warning", "파일을 선택하지 않았습니다.")
        
        for meta_row in range(0, len(df_Meta_final)):
            for meta_col in range(0,5):
                self.meta_table_view.setItem(meta_row, meta_col, QTableWidgetItem(df_Meta_final.iloc[meta_row,meta_col]))
        
        
        for stat_row in range(0, len(df_Stat)):
            for stat_col in range(0,10):
                
                self.stat_table_view.setItem(stat_row, stat_col, QTableWidgetItem(df_Stat.iloc[stat_row,stat_col]))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    
    #fig1 = Figure()
    #ax1f1 = fig1.add_subplot(111) 
    #img = ax1f1.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
    #fig1.colorbar(img)
    
    #fig2 = Figure()
    #ax1f2 = fig2.add_subplot(111) 
    #ax1f2.plot(np.random.rand(5))
    
    main = Main()
    
    #main.addmpl(fig1)
    #main.addmpl_2(fig2)
    
    #model = pandasModel(df_Meta_final)
    #view = QTableView()
    #view.setModel(model)
    #view.resize(800, 600)
    #view.show()
    
    main.show()
    
    sys.exit(app.exec_())



import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

f = open(path_dir +  '\\' +  file_list[1]) # 49p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

len(df_Point)
len(df_Point.columns)
aaa = pd.DataFrame(columns = ['X','Y'] + ['V1','V2'] )
df_Stat[df_Stat['SLOT'] == num_first_Wafer]
df_Stat.loc[df_Stat['SLOT'] == num_first_Wafer]
df_Stat['SLOT'] == num_first_Wafer
num_first_Wafer
num_first_Wafer +1
int(df_Stat['SLOT'])
df_Stat['RESULT TYPE']
set(df_Stat['RESULT TYPE'])
df_Stat.loc[num_Feature,'RESULT TYPE']
df_Stat.loc[1:num_Feature,'RESULT TYPE']
df_Stat.loc[0:num_Feature,'RESULT TYPE']
df_Stat.loc[0:num_Feature-1,'RESULT TYPE']
bba = df_Stat.loc[0:num_Feature-1,'RESULT TYPE']
aaa = pd.DataFrame(columns = ['X','Y'] + bba)
bba.values.tolist()
aaa = pd.DataFrame(columns = ['X','Y'] + bba.values.tolist())
(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()
ttt = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
len(df_Point.columns)/3
num_Wafer*(len(df_Point.columns)/3)
df_Point[0,0]
df_Point(0,0)
df_Point.loc[0,0]
df_Point.iloc[0,0]
df_Point.iloc[0,1]
df_Point.iloc[1,0]
df_Point.iloc[3,0]
df_Point.iloc[0,3]
df["1"] = "rome"
kk=1
df_Point[kk] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_Point_final[kk] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_Point[0:num_Feature-1,]
df_Point.loc[0:num_Feature-1,]
df_17 = df_Point.loc[0:num_Feature-1,]
df_18 = df_Point.loc[5:num_Feature*2-1,]
df_17_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_17_T = df_17.T
df_17_T.reindex
df_17_T.reset_index
df_17_T.loc[1,]
df_17_T.loc(1,)
df_17_T.iloc[0,]
df_17_final.iloc =df_17_T.iloc[0,]
df_17_final.iloc[1,] = df_17_T.iloc[0,]
df_17_final.iloc[0,] = df_17_T.iloc[0,]
df_17_final.iloc[0,0] = df_17_T.iloc[0,]
df_17_final.iloc[0,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_17_T.iloc[0,]
(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()
df_17_final.iloc[0,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = 0
df_17_final.iloc[0,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = [0,0,0,0,0,0,0]
df_17_final.iloc[0,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()]
df_17_final
df_17_final.iloc[0,0]
df_17_final.iloc[0,1]
df_17_final.loc[0,1]
df_17_final.loc[0,0]
df_17_final.loc[0]
df_17_final.loc[1]
df_17_T.iloc[0,]
df_17_final[point_num] = df_17_T.iloc[0,]
point_num = 0
df_17_final[point_num] = df_17_T.iloc[0,]
df_17_T.iloc[0,]
df_17_T.iloc[0,].T
df_17_final[point_num] = df_17_T.iloc[0,].T
df_17_T.iloc[0,]
df_17_T.iloc[0,].type
df_17_T.iloc[0,].values.tolist()
df_17_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_17_final[point_num] = df_17_T.iloc[0,].values.tolist()
df_17_final[(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()]
df_17_final[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()]
df_17_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()]
df_17_final.iloc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()]
df_17_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_17_T.iloc[0,].values.tolist()
df_17_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_17_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_17_T.iloc[0,].values.tolist()
df_17_T.iloc[1,0]
df_17_final.loc[point_num,'X'] = df_17_T.iloc[1,0]
df_17_final.loc[point_num,'Y'] = df_17_T.iloc[2,0]
df_17_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_17_T.iloc[0,].values.tolist()
point_num=1
df_17_final.loc[point_num,'X'] = df_17_T.iloc[4,0]
df_17_final.loc[point_num,'Y'] = df_17_T.iloc[5,0]
df_17_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_17_T.iloc[3,].values.tolist()
for point_num in range(0,len(df_Point.columns)/3 ):
    df_17_final.loc[point_num,'X'] = df_17_T.iloc[3*point_num+1,0]
    df_17_final.loc[point_num,'Y'] = df_17_T.iloc[3*point_num+2,0]
    df_17_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_17_T.iloc[3*point_num,].values.tolist()

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_17_final.loc[point_num,'X'] = df_17_T.iloc[3*point_num+1,0]
    df_17_final.loc[point_num,'Y'] = df_17_T.iloc[3*point_num+2,0]
    df_17_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_17_T.iloc[3*point_num,].values.tolist()

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_18_final.loc[point_num,'X'] = df_18_T.iloc[3*point_num+1,0]
    df_18_final.loc[point_num,'Y'] = df_18_T.iloc[3*point_num+2,0]
    df_18_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_18_T.iloc[3*point_num,].values.tolist()

df_18_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_18_T = df_18.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_18_final.loc[point_num,'X'] = df_18_T.iloc[3*point_num+1,0]
    df_18_final.loc[point_num,'Y'] = df_18_T.iloc[3*point_num+2,0]
    df_18_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_18_T.iloc[3*point_num,].values.tolist()

companies = ['AA', 'AAPL', 'BA', 'YHOO']
d = []
d = {}
companies.name
for name in companies:
    d[name] : pd.DataFrame()

d[AA]
d['AA']
d
companies = ['AA', 'AAPL', 'BA', 'YHOO']
for name in companies:
    d[name] : pd.DataFrame()

company.unique()
companies.unique()
companies[0]
d['AA'] : pd.DataFrame()
for name in companies:
    #d[name] : pd.DataFrame()
    print(name)

%clear
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp



del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]


num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_10 = df_Point.loc[3*0:num_Feature*1-1,]
df_11 = df_Point.loc[3*1:num_Feature*2-1,]
df_12 = df_Point.loc[3*2:num_Feature*3-1,]
num_Feature
df_10 = df_Point.loc[num_Feature*0:num_Feature*1-1,]
df_11 = df_Point.loc[num_Feature*1:num_Feature*2-1,]
df_12 = df_Point.loc[num_Feature*2:num_Feature*3-1,]
df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T
for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

i
num_first_Wafer
num_last_Wafer
for i in range(num_first_Wafer, num_last_Wafer):
    print(i)

for i in range(num_first_Wafer, num_last_Wafer+1):
    print(i)

temp={}
for i in range(0, 10):
    temp[i] = df_Point.loc[num_Feature*i:num_Feature*i-1,]

for i in range(0, 50):
    temp[i] = df_Point.loc[num_Feature*i:num_Feature*i-1,]

for i in range(0, 100):
    temp[i] = df_Point.loc[num_Feature*i:num_Feature*i-1,]

for i in range(num_first_Wafer, num_last_Wafer+1):
    temp[i] = df_Point.loc[num_Feature*(i/i-1):num_Feature*(i/i-1)-1,]

%clear
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

temp={}
num_first_Wafer
num_last_Wafer
i=10
temp[i] = df_Point.loc[num_Feature*(i/i-1):num_Feature*(i/i-1)-1,]
df_Point.loc[num_Feature*(i/i-1):num_Feature*(i/i-1)-1,]
num_Feature
num_Feature*(i/i-1)
num_Feature*(i/i-1)-1
temp[i] = df_Point.loc[num_Feature*(i/i-1):num_Feature*(i/i)-1,]
i=11
df_Point.loc[num_Feature*(i/i-1):num_Feature*(i/i)-1,]
num_last_Wafer-num_first_Wafer+1
i
i=10
num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1)
i=11
num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1)
i=10
temp[i] = df_Point.loc[num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1):num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i)-1,]
i=11
temp[i] = df_Point.loc[num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1):num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i)-1,]
for i in range(num_first_Wafer, num_last_Wafer+1):
    temp[i] = df_Point.loc[num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1):num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i)-1,]

%clear
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[1]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]




'''
df_10 = df_Point.loc[num_Feature*0:num_Feature*1-1,]
df_11 = df_Point.loc[num_Feature*1:num_Feature*2-1,]
df_12 = df_Point.loc[num_Feature*2:num_Feature*3-1,]

dict 사용해서 loop 돌리는 코드

wafer 숫자가 임의로 들어오기 떄문에 임의의 숫자 n(가령 12라던지)가 들어와도 이를 0으로 시작하는 반복문으로 만들 필요가 있음
이를 계산하려면 num_last_Wafer-num_first_Wafer+1 이 값이 항상 상수로 존재하기 때문에 이를 i에 관해서 풀어 0으로 시작
'i/i = 1, 2i/i = 2' 이런 관계로 표현한거임

output : dict의 key 값은 wafer slot과 동일하고 그 안에는 해당 wafer의 좌표 계측 값이 있음.
'''
temp={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    temp[i] = df_Point.loc[num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1):num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i)-1,]

num_first_Wafer
num_last_Wafer
ㅑ
i
i=17
df_Point.loc[num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1):num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i)-1,]
(i-(num_last_Wafer-num_first_Wafer+1))*i/i-1
num_first_Wafer
i
num_last_Wafer
num_first_Wafer
i-(num_last_Wafer-num_first_Wafer+1)
num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1)
num_Feature
((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1)
num_first_Wafer
i
num_last_Wafer-num_first_Wafer+1
for i in range(num_first_Wafer, num_last_Wafer+1):
    #temp[i] = df_Point.loc[num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1):num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i)-1,]
    temp[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):num_Feature*(i-num_first_Wafer+1),]

i-num_first_Wafer+1
i-num_first_Wafer
i=
i
i=17
i-num_first_Wafer
i-num_first_Wafer+1
temp[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):num_Feature*(i-num_first_Wafer+1),]
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[1]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

temp={}
temp
num_first_Wafer
num_last_Wafer
(i-num_first_Wafer)
i=17
(i-num_first_Wafer)
(i-num_first_Wafer+1)
num_Feature*(i-num_first_Wafer+1
)
num_Feature*(i-num_first_Wafer)
i-num_first_Wafer+1
num_Feature*((i-num_first_Wafer+1)-1)
i=18
num_Feature*(i-num_first_Wafer)
i=17
i-num_first_Wafer+1
(num_Feature*(i-num_first_Wafer+1))-1
i=18
(num_Feature*(i-num_first_Wafer+1))-1
for i in range(num_first_Wafer, num_last_Wafer+1):
    #temp[i] = df_Point.loc[num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1):num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i)-1,]
    temp[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]

file_list
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

temp={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    #temp[i] = df_Point.loc[num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i-1):num_Feature*((i-(num_last_Wafer-num_first_Wafer+1))*i/i)-1,]
    temp[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]

df_Point_dict.keys()
df_Point_dict.values
df_Point_dict.values()
companies = ['NAVER', 'KAKAO', 'YAHOO', 'GOOGLE']
d = {}
for name in companies:
    d[name] = pd.DataFrame()

d.get('NAVER')
df_Point_dict[11]
test = df_Point_dict[11]
d['NAVER']
temp = df_Point_dict[11].T
i=14
temp = df_Point_dict[i].T
df_Point_finial_dict = {}
df_Point_finial_dict = {}
for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
    
    temp = df_Point_finial_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()

df_Point_finial_dict = {}
num_first_Wafer
i
df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
temp = df_Point_finial_dict[i].T
df_Point_finial_dict[i]
temp = df_Point_dict[i].T
for point_num in range(0,int(len(df_Point.columns)/3)):
    df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
    df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
    df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()

df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
    
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()

import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[1]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]




'''
df_10 = df_Point.loc[num_Feature*0:num_Feature*1-1,]
df_11 = df_Point.loc[num_Feature*1:num_Feature*2-1,]
df_12 = df_Point.loc[num_Feature*2:num_Feature*3-1,]

dict 사용해서 loop 돌리는 코드

wafer 숫자가 임의로 들어오기 떄문에 임의의 숫자 n(가령 12라던지)가 들어와도 이를 0으로 시작하는 반복문으로 만들 필요가 있음
이를 계산하려면 i-num_first_Wafer 이 값이 1씩 증가하기 때문에 이를 사용
'i/i = 1, 2i/i = 2' 이런 관계로 표현한거임

output : dict의 key 값은 wafer slot과 동일하고 그 안에는 해당 wafer의 좌표 계측 값이 있음.
25p, 49p 확인완료
'''

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]




df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
    
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]


'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입

df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다
'''

df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

%clear
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]


'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다
'''

df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None


df_Point_finial_dict[10]
import numpy as np
(df_Stat.loc[0:num_Feature-1,'RESULT TYPE'])
(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()
%clear
import os
import pandas as pd
import numpy as np

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
df_10 = df_Point.loc[num_Feature*0:num_Feature*1-1,]
df_11 = df_Point.loc[num_Feature*1:num_Feature*2-1,]
df_12 = df_Point.loc[num_Feature*2:num_Feature*3-1,]

dict 사용해서 loop 돌리는 코드

wafer 숫자가 임의로 들어오기 떄문에 임의의 숫자 n(가령 12라던지)가 들어와도 이를 0으로 시작하는 반복문으로 만들 필요가 있음
이를 계산하려면 i-num_first_Wafer 이 값이 1씩 증가하기 때문에 이를 사용
'i/i = 1, 2i/i = 2' 이런 관계로 표현한거임

output : dict의 key 값은 wafer slot과 동일하고 그 안에는 해당 wafer의 좌표 계측 값이 있음.
25p, 49p 확인완료
'''
df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan    
test
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()   
import matplotlib.pylab as plt 
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
df_Point_finial_dict[10]
test_2 = pd.DataFrame(index=range(0,4), columns=range(0,4))     
for i in range(0,4):
    for j in range(0,4):
        if ((2-i)**2 + (2-j)**2) < 2**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test_2[test_2 == 0] = np.nan   

plt.figure(1)
plt.imshow(test_2, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()     
test_2 = pd.DataFrame(index=range(0,5), columns=range(0,5))     
for i in range(0,5):
    for j in range(0,5):
        if ((2-i)**2 + (2-j)**2) < 2**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test_2[test_2 == 0] = np.nan   

plt.figure(1)
plt.imshow(test_2, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()     
test_2 = pd.DataFrame(index=range(0,5), columns=range(0,5))     
for i in range(0,5):
    for j in range(0,5):
        if ((2-i)**2 + (2-j)**2) < 2**2:
            test_2.loc[i,j] = i*2+i+j
        else:
            test_2.loc[i,j] = 0

test_2[test_2 == 0] = np.nan   

plt.figure(1)
plt.imshow(test_2, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()     
test = pd.DataFrame(index=range(0,151), columns=range(0,151))     
for i in range(0,151):
    for j in range(0,151):
        if ((150-i)**2 + (150-j)**2) < 150**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan   

plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()   
test = pd.DataFrame(index=range(0,301), columns=range(0,301))     
for i in range(0,301):
    for j in range(0,301):
        if ((150-i)**2 + (150-j)**2) < 150**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan   

plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()   
point_temp = df_Point_finial_dict[11]
point_temp
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan   

plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()     
test = pd.DataFrame(index=range(0,151), columns=range(0,151))     
for i in range(0,151):
    for j in range(0,151):
        if ((75-i)**2 + (75-j)**2) < 75**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan   

plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()   
test = pd.DataFrame(index=range(0,51), columns=range(0,51))     
for i in range(0,51):
    for j in range(0,51):
        if ((25-i)**2 + (25-j)**2) < 25**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan   

plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()   
test = pd.DataFrame(index=range(0,51), columns=range(0,51))     
for i in range(0,51):
    for j in range(0,51):
        if ((25-i)**2 + (25-j)**2) < 25**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan   

plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan   

plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()   
test = pd.DataFrame(index=range(0,151), columns=range(0,151))     
for i in range(0,151):
    for j in range(0,151):
        if ((75-i)**2 + (75-j)**2) < 75**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan   

plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan   

plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
df_Point_finial_dict[10]
temp_25point = df_Point_finial_dict[10]
temp_25point[1,1]
temp_25point(1,1)
temp_25point.iloc(1,1)
temp_25point.iloc[1,1]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
temp_25point_scale = temp_25point.loc[:,'X'+2:(temp_25point.iloc[:,-1]).name]
temp_25point.iloc[:,1]
temp_25point.iloc[:,2]
temp_25point.iloc[:,0]
temp_25point.iloc[:,2]
temp_25point.iloc[:,-1
]
temp_25point[['X','Y']]
temp_25point[['X','Y']]/3
temp_25point_scale = pd.concat([temp_25point[['X','Y']]/3,temp_25point.loc[:,(temp_25point.iloc[:,2]):(temp_25point.iloc[:,-1]).name]], axis=1)
[temp_25point[['X','Y']]/3
]
temp_25point[['X','Y']]/3
temp_25point.loc[:,(temp_25point.iloc[:,2]):(temp_25point.iloc[:,-1]).name]
temp_25point.loc[:,(temp_25point.iloc[:,2]):(temp_25point.iloc[:,-1]).name]]
temp_25point.loc[:,(temp_25point.iloc[:,2])
]
temp_25point_scale = pd.concat([temp_25point[['X','Y']]/3], axis=1)
temp_25point.loc[:,(temp_25point.iloc[:,2]):(temp_25point.iloc[:,-1]).name]
temp_25point.loc[:,(temp_25point.iloc[:,2]):(temp_25point.iloc[:,-1])]
temp_25point.loc[:,(temp_25point.iloc[:,2])]
temp_25point.loc[:,(temp_25point.iloc[:,-1])]
temp_25point[:,2]
temp_25point.iloc[:,(temp_25point.iloc[:,2]):(temp_25point.iloc[:,-1])]
temp_25point.iloc[:,2]
temp_25point.iloc[:,2:-1]
temp_25point.iloc[:,2:0]
temp_25point.iloc[:,2:-2]
temp_25point.iloc[:,2:-1]
temp_25point.iloc[:,2:end]
temp_25point.iloc[:,-1]
temp_25point.iloc[:,2:temp_25point.iloc[:,-1]]
temp_25point.iloc[:,2:-1]
temp_25point.iloc[:,-1]
temp_25point.iloc[:,3:-1]
temp_25point.iloc[:,3]
temp_25point.iloc[:,4]
temp_25point.iloc[:,2]
temp_25point.iloc[:,2:2+num_Feature-1]
temp_25point.iloc[:,2:2+int(num_Feature)-1]
temp_25point.iloc[:,2:2+int(num_Feature)]
temp_25point_scale = pd.concat([temp_25point[['X','Y']]/3,temp_25point.iloc[:,2:2+int(num_Feature)]], axis=1)
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = np.nan 
        else:
            test.loc[i,j] = np.nan 

test[test == 0] = np.nan  
temp_25point_scale = pd.concat([temp_25point[['X','Y']]/3+50,temp_25point.iloc[:,2:2+int(num_Feature)]], axis=1)
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
test = test.apply(pd.to_numeric, errors = 'coerce')
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
test
test.iloc[50,58]
test.iloc[49,58]
test.iloc[48,58]
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
test
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
test
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = i*2+i+j
        else:
            test.loc[i,j] = 0

test[test == 0] = np.nan   

plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
[temp_25point[['X','Y']]/3+50
]
[temp_25point[['X','Y']]/3+50]
round([temp_25point[['X','Y']]/3+50])
temp_25point_scale.X = temp_25point_scale.X.round()
temp_25point_scale.Y = temp_25point_scale.Y.round()
temp_25point_scale,iloc[0,1]
temp_25point_scale.iloc[0,1]
temp_25point_scale.iloc[0,1] +1 
temp_25point_scale.iloc[0,0]
temp_25point_scale.iloc[0,2]
for i in range(0, len(temp_25point_scale)):
    test.iloc[temp_25point_scale.iloc[i,0],temp_25point_scale.iloc[i,1]] = temp_25point_scale.iloc[i,2]

for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]

plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar() 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]

%clear
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
df_10 = df_Point.loc[num_Feature*0:num_Feature*1-1,]
df_11 = df_Point.loc[num_Feature*1:num_Feature*2-1,]
df_12 = df_Point.loc[num_Feature*2:num_Feature*3-1,]

dict 사용해서 loop 돌리는 코드

wafer 숫자가 임의로 들어오기 떄문에 임의의 숫자 n(가령 12라던지)가 들어와도 이를 0으로 시작하는 반복문으로 만들 필요가 있음
이를 계산하려면 i-num_first_Wafer 이 값이 1씩 증가하기 때문에 이를 사용
'i/i = 1, 2i/i = 2' 이런 관계로 표현한거임

output : dict의 key 값은 wafer slot과 동일하고 그 안에는 해당 wafer의 좌표 계측 값이 있음.
25p, 49p 확인완료
'''
df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None


temp_25point = df_Point_finial_dict[10]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')


#temp_25point.iloc[:,2:2+int(num_Feature)]

temp_25point_scale = pd.concat([temp_25point[['X','Y']]/3+50,temp_25point.iloc[:,2:2+int(num_Feature)]], axis=1)
temp_25point_scale.X = temp_25point_scale.X.round()
temp_25point_scale.Y = temp_25point_scale.Y.round()
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]


test = test.apply(pd.to_numeric, errors = 'coerce')
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.colorbar()
plt.imshow(test, cmap = 'gist_rainbow_r')
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[1]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
df_10 = df_Point.loc[num_Feature*0:num_Feature*1-1,]
df_11 = df_Point.loc[num_Feature*1:num_Feature*2-1,]
df_12 = df_Point.loc[num_Feature*2:num_Feature*3-1,]

dict 사용해서 loop 돌리는 코드

wafer 숫자가 임의로 들어오기 떄문에 임의의 숫자 n(가령 12라던지)가 들어와도 이를 0으로 시작하는 반복문으로 만들 필요가 있음
이를 계산하려면 i-num_first_Wafer 이 값이 1씩 증가하기 때문에 이를 사용
'i/i = 1, 2i/i = 2' 이런 관계로 표현한거임

output : dict의 key 값은 wafer slot과 동일하고 그 안에는 해당 wafer의 좌표 계측 값이 있음.
25p, 49p 확인완료
'''
df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

temp_25point = df_Point_finial_dict[17]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')


#temp_25point.iloc[:,2:2+int(num_Feature)]

temp_25point_scale = pd.concat([temp_25point[['X','Y']]/3+50,temp_25point.iloc[:,2:2+int(num_Feature)]], axis=1)
temp_25point_scale.X = temp_25point_scale.X.round()
temp_25point_scale.Y = temp_25point_scale.Y.round()




test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]


test = test.apply(pd.to_numeric, errors = 'coerce')



plt.figure(1)
#plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = 0
        else:
            test.loc[i,j] = np.nan

for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]


test = test.apply(pd.to_numeric, errors = 'coerce')
plt.figure(1)
#plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = 0
        else:
            test.loc[i,j] = np.nan




for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]


test = test.apply(pd.to_numeric, errors = 'coerce')
plt.figure(1)
#plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = 0
        else:
            test.loc[i,j] = np.nan




for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,3]


test = test.apply(pd.to_numeric, errors = 'coerce')






plt.figure(1)
#plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = 0
        else:
            test.loc[i,j] = np.nan




for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]


test = test.apply(pd.to_numeric, errors = 'coerce')






plt.figure(1)
#plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]



test = test.apply(pd.to_numeric, errors = 'coerce')






plt.figure(1)
#plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]



test = test.apply(pd.to_numeric, errors = 'coerce')






plt.figure(1)
#plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
#plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
#plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
test_df = test.interpolate(method = 'linear', limit_direction = 'forward')
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = 0
        else:
            test.loc[i,j] = np.nan




for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    '''
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    '''


test = test.apply(pd.to_numeric, errors = 'coerce')
test_df = test.interpolate(method = 'linear', limit_direction = 'forward')
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = np.nan
        else:
            test.loc[i,j] = np.nan




for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    '''
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    '''


test = test.apply(pd.to_numeric, errors = 'coerce')


test_df = test.interpolate(method = 'linear', limit_direction = 'forward')
plt.figure(1)
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
#plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 

plt.figure(1)
plt.imshow(test_df, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
#plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
#plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
test_df = test.interpolate(method = 'linear', limit_direction = 'forward',axix=0)
test_df = test.interpolate(method = 'nearest', limit_direction = 'forward',axix=0)
test_df = test.interpolate(method = 'values', limit_direction = 'forward',axix=0)
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = np.nan
        else:
            test.loc[i,j] = np.nan




for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    '''
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    '''


test = test.apply(pd.to_numeric, errors = 'coerce')
plt.figure(1)
#plt.imshow(test_df, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
#plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
test = test.apply(pd.to_numeric, errors = 'coerce')
plt.figure(1)
#plt.imshow(test_df, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
#plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
test = pd.DataFrame(index=range(0,101), columns=range(0,101))     
for i in range(0,101):
    for j in range(0,101):
        if ((50-i)**2 + (50-j)**2) < 50**2:
            test.loc[i,j] = 0
        else:
            test.loc[i,j] = np.nan


for i in range(0, len(temp_25point_scale)):
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    '''
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]
    
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])+1,int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])-1] = temp_25point_scale.iloc[i,2]
    test.iloc[int(temp_25point_scale.iloc[i,0])-1,int(temp_25point_scale.iloc[i,1])+1] = temp_25point_scale.iloc[i,2]
    '''


test = test.apply(pd.to_numeric, errors = 'coerce')


test_df = test.interpolate(method = 'values', limit_direction = 'forward',axix=0)
plt.figure(1)
#plt.imshow(test_df, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(test, interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
#plt.imshow(test, cmap = 'gist_rainbow_r')
plt.colorbar() 
data = {(1,3):22, (1,3.5):23, (1,4.5):25, (1.5,3.3):19, (4,4):100}
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt
data = {(1,3):22, (1,3.5):23, (1,4.5):25, (1.5,3.3):19, (4,4):100}
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:0.01, miny:maxy:0.01]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

# Look at it!
plt.imshow(z_, origin="lower", extent=extent)
plt.scatter(x, y, s=2, c='w')
data_temp = {}
data_temp = {}

for i in range(0, len(temp_25point_scale)):
    
    data_temp[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]

data = {}

for i in range(0, len(temp_25point_scale)):
    
    data[int(temp_25point_scale.iloc[i,0]),int(temp_25point_scale.iloc[i,1])] = temp_25point_scale.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:0.01, miny:maxy:0.01]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

# Look at it!
plt.imshow(z_, origin="lower", extent=extent)
plt.scatter(x, y, s=2, c='w')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

# Look at it!
plt.imshow(z_, origin="lower", extent=extent)
plt.scatter(x, y, s=2, c='w')
extent
plt.imshow(z_, origin="lower", extent=extent)
plt.imshow(z_,  interpolation = 'hanning', vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(z_,   vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(z_, origin="lower", extent=extent)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

# Look at it!
plt.imshow(z_, origin="lower", extent=extent)
plt.scatter(x, y, s=2, c='w')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow')
plt.colorbar() 
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:2, miny:maxy:2]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)
plt.imshow(z_, origin="lower", extent=extent)
plt.scatter(x, y, s=2, c='w')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow')
plt.colorbar() 
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

# Look at it!
plt.imshow(z_, origin="lower", extent=extent)
plt.scatter(x, y, s=2, c='w')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow')
plt.colorbar() 
plt.imshow(z_,   vmin = 0, cmap = 'gist_rainbow_r')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow')
plt.colorbar() 
len(z_)
z_[1,1]
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((i)**2 + (j)**2) > 147**2:
            z_.loc[i,j] = 0

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((i)**2 + (j)**2) > 147**2:
            z_.loc[i,j] = 0

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((i)**2 + (j)**2) > 147**2:
            z_[i,j] = 0

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow')
plt.colorbar() 
plt.imshow(z_, origin="lower",cmap = 'gist_rainbow')
plt.colorbar() 
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0

z_[z_ == 0] = np.nan  
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow')
plt.colorbar() 
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar()
cmap = plt.get_cmap('jet', 20)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
cmap = plt.get_cmap('jet', 20)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=2, c='w')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=5, c='w')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='b')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
%clear
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

x = np.array([k[0] for k in data.keys()])
data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

temp_25point = df_Point_finial_dict[17]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
rbfi = Rbf(x, y, z)




# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

or i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0

z_[z_ == 0] = np.nan  
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)




# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

or i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0

z_[z_ == 0] = np.nan  

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
temp_25point = df_Point_finial_dict[18]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
temp_25point = df_Point_finial_dict[10]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 


cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')

cmap = plt.get_cmap('jet', 5)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 20)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
%clear
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
df_10 = df_Point.loc[num_Feature*0:num_Feature*1-1,]
df_11 = df_Point.loc[num_Feature*1:num_Feature*2-1,]
df_12 = df_Point.loc[num_Feature*2:num_Feature*3-1,]

dict 사용해서 loop 돌리는 코드

wafer 숫자가 임의로 들어오기 떄문에 임의의 숫자 n(가령 12라던지)가 들어와도 이를 0으로 시작하는 반복문으로 만들 필요가 있음
이를 계산하려면 i-num_first_Wafer 이 값이 1씩 증가하기 때문에 이를 사용
'i/i = 1, 2i/i = 2' 이런 관계로 표현한거임

output : dict의 key 값은 wafer slot과 동일하고 그 안에는 해당 wafer의 좌표 계측 값이 있음.
25p, 49p 확인완료
'''
df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[10]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  
cmap = plt.get_cmap('jet', 20)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
cmap = plt.get_cmap('jet', 20)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 5)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
rbfi
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar()
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
z_[147,0]
maxx
maxx*2
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[0:maxx*2:1, 0:maxy*2:1]
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
rbfi
z_[0,147]
grid_x, grid_y = np.mgrid[0:294:1, 0:294:1]
rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y)
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
extent = (0, 294, 0, 294)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y)

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x)

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 20)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 5)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
%clear
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]

df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[10]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[11]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[10]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')





cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[12]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[13]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[14]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[15]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[16]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[17]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
file_list
f = open(path_dir +  '\\' +  file_list[1]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
df_10 = df_Point.loc[num_Feature*0:num_Feature*1-1,]
df_11 = df_Point.loc[num_Feature*1:num_Feature*2-1,]
df_12 = df_Point.loc[num_Feature*2:num_Feature*3-1,]

dict 사용해서 loop 돌리는 코드

wafer 숫자가 임의로 들어오기 떄문에 임의의 숫자 n(가령 12라던지)가 들어와도 이를 0으로 시작하는 반복문으로 만들 필요가 있음
이를 계산하려면 i-num_first_Wafer 이 값이 1씩 증가하기 때문에 이를 사용
'i/i = 1, 2i/i = 2' 이런 관계로 표현한거임

output : dict의 key 값은 wafer slot과 동일하고 그 안에는 해당 wafer의 좌표 계측 값이 있음.
25p, 49p 확인완료
'''
df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[17]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[18]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
file_list
%clear
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
f = open(path_dir +  '\\' +  file_list[2]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((148-i)**2 + (148-j)**2) > 148**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[21]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[21]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[21]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  
temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan    
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[21]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan    
temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[21]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[21]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}
for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]
rbfi = Rbf(x, y, z)
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[21]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_xxx = temp_25point.loc[25:72,]
temp_25point = temp_25point.loc[25:72,]
data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0
        if ((147-i)**2 + (147-j)**2) < 147**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan    
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):    


# log파일 분할시키기
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor  
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    #Step부터 end col factor까지 numeric으로 타입 
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_1.Time = pd.to_datetime(df.Time) # 타입 변환
    df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_1.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_1 = df_1[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 특정 Step 값만 가져오기
    
    # 6Step만 선택 - Depo Step
    df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 사전 정의 - based on domain knowledge
    Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
                 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  
    
    #Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
    #              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
    df_3 = df_2[Gas_Input]
    
    df_3['Delivery_Power'] = df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']
    
    del df_3['HF_FORWARD_A']
    del df_3['HF_REFLECT_A']
    
    # Factor들 이름만 가져옴
    answer = df_3.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_3.mean()
    answer_median = answer + '_median'
    value_median = df_3.median()
    answer_std = answer + '_std'
    value_std = df_3.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master = pd.concat([master, temp_master])


# Temp 추출

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    df_temp = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df_temp.loc[i-12] = temp
    
    df_4 = df_temp.loc[:,'Recipe_Step_Number':(df_temp.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    df_4.Time = pd.to_datetime(df_temp.Time) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
    
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    # 6Step만 선택
    df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 사전 정의
    Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    #Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Impedence 계산
    # df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) 
    # sqrt 쓰면 cannot convert the series to <class 'float'> 오류남
    
    df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)
    
    del df_6['HF_R_A']
    del df_6['HF_X_A']
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])



##########################################################################
########################## 2. Master Table 작성 ##########################
##########################################################################


result = pd.read_excel(r'C:\Users\wtjang\Documents\work\L_MOLD_result.xlsx')

# re_index 해주기 -> index 맞추는 작업 필요 
master = master.reset_index(drop=True)   # Gas
master_2 = master_2.reset_index(drop=True) # Temp 
result = result.reset_index(drop=True)  # Result

# col삭제 del master['stress']

# pd.concat으로 Dataframe 합칠 수 있는데, axis=1이면 col 옆으로 합친다는 뜻
# 열로 붙일때 index 넘버가 같아야댐.. 그래야지 맞춰지더라 그래서 reset_index 쓴거임
final_master_D_R = pd.concat([master, master_2, result['D_R']],axis = 1)
%clear

## ---(Thu Apr  9 18:40:11 2020)---
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):    


# log파일 분할시키기
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor  
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    #Step부터 end col factor까지 numeric으로 타입 
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_1.Time = pd.to_datetime(df.Time) # 타입 변환
    df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_1.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_1 = df_1[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 특정 Step 값만 가져오기
    
    # 6Step만 선택 - Depo Step
    df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 사전 정의 - based on domain knowledge
    Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
                 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  
    
    #Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
    #              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
    df_3 = df_2[Gas_Input]
    
    df_3['Delivery_Power'] = df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']
    
    del df_3['HF_FORWARD_A']
    del df_3['HF_REFLECT_A']
    
    # Factor들 이름만 가져옴
    answer = df_3.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_3.mean()
    answer_median = answer + '_median'
    value_median = df_3.median()
    answer_std = answer + '_std'
    value_std = df_3.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master = pd.concat([master, temp_master])
file_list
f
labels
df
file_sort
file_list
k=3
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor  

df = pd.DataFrame(columns = labels)
for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp

df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
#Step부터 end col factor까지 numeric으로 타입 
#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_1.Time = pd.to_datetime(df.Time) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]

#df_1에서 모든 log 분할 완성 

# 특정 Step 값만 가져오기

# 6Step만 선택 - Depo Step
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]

df_3['Delivery_Power'] = df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']

del df_3['HF_FORWARD_A']
del df_3['HF_REFLECT_A']
answer = df_3.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_3.mean()
answer_median = answer + '_median'
value_median = df_3.median()
answer_std = answer + '_std'
value_std = df_3.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)


if k ==0:
    master = temp_master # 제일 처음에만    

# log 50개를 누적해서 50row로 만드는게 목적
#조건문으로 들어가게 해줘야함
else:
    master = pd.concat([master, temp_master])
k=2
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor  

df = pd.DataFrame(columns = labels)
for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp

df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
#Step부터 end col factor까지 numeric으로 타입 
#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_1.Time = pd.to_datetime(df.Time) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_1.Time = pd.to_datetime(df.Time) # 타입 변환
df_1.Time = pd.to_datetime(df.Time) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]
df_1.loc[1,1]
df_1.iloc[1,1]
df_1.iloc[1,2]
df_1.iloc[1,0]
df_1.iloc[1,'Time']
df_1.loc[1,'Time']
df_1.loc[1,'Time'] + 1
df_1.iloc[1,2]
df_1.iloc[1,2] + 1
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]

df_3['Delivery_Power'] = df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']

del df_3['HF_FORWARD_A']
del df_3['HF_REFLECT_A']
answer = df_3.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_3.mean()
answer_median = answer + '_median'
value_median = df_3.median()
answer_std = answer + '_std'
value_std = df_3.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)


if k ==0:
    master = temp_master # 제일 처음에만    

# log 50개를 누적해서 50row로 만드는게 목적
#조건문으로 들어가게 해줘야함
else:
    master = pd.concat([master, temp_master])
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):    


# log파일 분할시키기
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor  
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    #Step부터 end col factor까지 numeric으로 타입 
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_1.Time = pd.to_datetime(df.Time) # 타입 변환
    df_1['Time'] = pd.DataFrame({'Time' : df_1.Time})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_1.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_1 = df_1[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 특정 Step 값만 가져오기
    
    # 6Step만 선택 - Depo Step
    df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 사전 정의 - based on domain knowledge
    Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
                 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  
    
    #Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
    #              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
    df_3 = df_2[Gas_Input]
    
    df_3['Delivery_Power'] = df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']
    
    del df_3['HF_FORWARD_A']
    del df_3['HF_REFLECT_A']
    
    # Factor들 이름만 가져옴
    answer = df_3.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_3.mean()
    answer_median = answer + '_median'
    value_median = df_3.median()
    answer_std = answer + '_std'
    value_std = df_3.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master = pd.concat([master, temp_master])
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()
%clear
file_list
file_list[0]
file_list[len(file_list)]
len(file_list)
file_list(len(file_list))
file_list(len(file_list)-1)
file_list[len(file_list)-1]
file_list[len(file_list)]
k=0
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor  

df = pd.DataFrame(columns = labels)
i=13
temp = lines[i]
temp = temp.split()
temp_date = temp[0] + ' ' + temp[1]
temp
del temp[0]
temp
temp.insert(0, temp_date)
temp
df.loc[i-12] = temp
for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp

df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_1['Time'] = pd.to_datetime(df['Time'])
df_1['Time'] = pd.DataFrame({'Time' : df_1['Time']})
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]
df_1.iloc[1,1]
df_1.iloc[1,0]
df_1['Time'] = pd.to_datetime(df['Time']) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1['Time']})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]

df_3['Delivery_Power'] = df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']

del df_3['HF_FORWARD_A']
del df_3['HF_REFLECT_A']
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A'] 
df_3 = df_2[Gas_Input]
df_3['Delivery_Power'] = df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']
df_3.loc[:,'Delivery_Power'] = df_3.loc[:,'HF_FORWARD_A'] - df_3.loc[:,'HF_REFLECT_A']
aaa = df_3.loc[:,'HF_FORWARD_A'] - df_3.loc[:,'HF_REFLECT_A']
bbb = pd.DataFrame(aaa)
df_3['Delivery_Power'] = bbb
df_3.loc[:,'k'] = bbb
df_3[:,'k'] = bbb
df_3.iolc[:,'k'] = bbb
df_3.iloc[:,'k'] = bbb
df_3.loc['k'] = bbb
df_3 = pd.concat([df_3, bbb], axis = 0)
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor  

df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp


df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
#Step부터 end col factor까지 numeric으로 타입 
#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_1['Time'] = pd.to_datetime(df['Time']) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1['Time']})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]

#df_1에서 모든 log 분할 완성 

# 특정 Step 값만 가져오기

# 6Step만 선택 - Depo Step
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]
temp_dp = df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']
temp_dp = pd.DataFrame(temp_dp)
DataFrame
temp_dp = pd.DataFrame(df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A'])
df_3 = pd.concat([df_3, temp_dp], axis = 0)
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]
temp_dp = pd.DataFrame(df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A'])
df_3 = pd.concat([df_3, temp_dp], axis = 2)
df_3 = pd.concat([df_3, temp_dp], axis = 1)
df_3['Delivery_Power'] = pd.concat([df_3, temp_dp], axis = 1)
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]
temp_dp = pd.DataFrame(df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A'])
df_3['Delivery_Power'] = pd.concat([df_3, temp_dp], axis = 1)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]

#df_1에서 모든 log 분할 완성 

# 특정 Step 값만 가져오기

# 6Step만 선택 - Depo Step
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]
temp_dp['Delivery_Power'] = pd.DataFrame(df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A'])
del temp_dp
df_1['Time'] = pd.to_datetime(df['Time']) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1['Time']})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]

#df_1에서 모든 log 분할 완성 

# 특정 Step 값만 가져오기

# 6Step만 선택 - Depo Step
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]
temp_dp['Delivery_Power'] = pd.DataFrame(df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A'])
temp_dp = pd.DataFrame(df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A'])
temp_dp.rename(columns = {"0":"Delivery_Power"},inplace=True)
temp_dp.rename(columns = {"0": "Delivery_Power"}, inplace = True)
df_3 = pd.concat([df_3, temp_dp], axis = 1)
df_3['0']
df_3.columns
df_3[0]
temp_dp.rename(columns = {0: "Delivery_Power"}, inplace = True)
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]
temp_dp = pd.DataFrame(df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A'])
temp_dp.rename(columns = {0: "Delivery_Power"}, inplace = True)

df_3 = pd.concat([df_3, temp_dp], axis = 1)
del df_3['HF_FORWARD_A']
del df_3['HF_REFLECT_A']
del temp_dp
answer = df_3.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_3.mean()
answer_median = answer + '_median'
value_median = df_3.median()
answer_std = answer + '_std'
value_std = df_3.std()
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)


if k ==0:
    master = temp_master # 제일 처음에만    

# log 50개를 누적해서 50row로 만드는게 목적
#조건문으로 들어가게 해줘야함
else:
    master = pd.concat([master, temp_master])
k=1
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor  

df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp


df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
#Step부터 end col factor까지 numeric으로 타입 
#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_1['Time'] = pd.to_datetime(df['Time']) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1['Time']})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]

#df_1에서 모든 log 분할 완성 

# 특정 Step 값만 가져오기

# 6Step만 선택 - Depo Step
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]


temp_dp = pd.DataFrame(df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A'])
temp_dp.rename(columns = {0: "Delivery_Power"}, inplace = True)

df_3 = pd.concat([df_3, temp_dp], axis = 1)


del df_3['HF_FORWARD_A']
del df_3['HF_REFLECT_A']
del temp_dp

# Factor들 이름만 가져옴
answer = df_3.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_3.mean()
answer_median = answer + '_median'
value_median = df_3.median()
answer_std = answer + '_std'
value_std = df_3.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)


if k ==0:
    master = temp_master # 제일 처음에만    

# log 50개를 누적해서 50row로 만드는게 목적
#조건문으로 들어가게 해줘야함
else:
    master = pd.concat([master, temp_master])
k=2
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor  

df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp

df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
#Step부터 end col factor까지 numeric으로 타입 
#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_1['Time'] = pd.to_datetime(df['Time']) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1['Time']})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]


temp_dp = pd.DataFrame(df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A'])
temp_dp.rename(columns = {0: "Delivery_Power"}, inplace = True)

df_3 = pd.concat([df_3, temp_dp], axis = 1)


del df_3['HF_FORWARD_A']
del df_3['HF_REFLECT_A']
del temp_dp
import os
import pandas as pd

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_GAS'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)-1):    


# log파일 분할시키기
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor  
    
    df = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df.loc[i-12] = temp
    
    df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    #Step부터 end col factor까지 numeric으로 타입 
    #df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
    #col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
    #제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱
    
    df_1['Time'] = pd.to_datetime(df['Time']) # 타입 변환
    df_1['Time'] = pd.DataFrame({'Time' : df_1['Time']})
    
    #Dataframe에서 col 순서 바꾸기(end col -> first col으로)
    cols = df_1.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_1 = df_1[cols]
    
    #df_1에서 모든 log 분할 완성 
    
    # 특정 Step 값만 가져오기
    
    # 6Step만 선택 - Depo Step
    df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 사전 정의 - based on domain knowledge
    Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
                 'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  
    
    #Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
    #              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
    df_3 = df_2[Gas_Input]
    
    
    temp_dp = pd.DataFrame(df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A'])
    temp_dp.rename(columns = {0: "Delivery_Power"}, inplace = True)
    
    df_3 = pd.concat([df_3, temp_dp], axis = 1)
    
    
    del df_3['HF_FORWARD_A']
    del df_3['HF_REFLECT_A']
    del temp_dp
    
    # Factor들 이름만 가져옴
    answer = df_3.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_3.mean()
    answer_median = answer + '_median'
    value_median = df_3.median()
    answer_std = answer + '_std'
    value_std = df_3.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    
    if k ==0:
        master = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master = pd.concat([master, temp_master])
k=49
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor  

df = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df.loc[i-12] = temp


df_1 = df.loc[:,'Recipe_Step_Number':(df.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
#Step부터 end col factor까지 numeric으로 타입 
#df_1 = df.apply(pd.to_numeric, errors = 'coerce') 
#col값을 numeric으로 변경하는데, numerice으로 변경 안되는건 NaN으로 변경
#제일 마지막 칼럼 이름을 지정해줘야 하는데 (df.iloc[:,-1]).name 이걸로 인덱싱

df_1['Time'] = pd.to_datetime(df['Time']) # 타입 변환
df_1['Time'] = pd.DataFrame({'Time' : df_1['Time']})

#Dataframe에서 col 순서 바꾸기(end col -> first col으로)
cols = df_1.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_1 = df_1[cols]

#df_1에서 모든 log 분할 완성 

# 특정 Step 값만 가져오기

# 6Step만 선택 - Depo Step
df_2 = df_1.loc[df_1['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의 - based on domain knowledge
Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
             'S1_P0_PRESS', 'S1_P1_PRESS', 'S1_VAT_Pressure', 'S1_VAT_Position','HF_FORWARD_A','HF_REFLECT_A']  

#Gas_Input = ['Time', 'S1_NH3_FLOW','S1_SiH4_FLOW', 'S1_N2_FLOW', 'S1_Ar_Flow(Teos)', 
#              'S1_VAT_Pressure', 'HF_FORWARD_A','HF_REFLECT_A']   
df_3 = df_2[Gas_Input]
temp_dp = pd.DataFrame((df_3['HF_FORWARD_A'] - df_3['HF_REFLECT_A']),columns=['Delivery_Power'])
df_3 = pd.concat([df_3, temp_dp], axis = 1)
del df_3['HF_FORWARD_A']
del df_3['HF_REFLECT_A']
del temp_dp
answer = df_3.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_3.mean()
answer_median = answer + '_median'
value_median = df_3.median()
answer_std = answer + '_std'
value_std = df_3.std()

# 1줄로 추출
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)


if k ==0:
    master = temp_master # 제일 처음에만    

# log 50개를 누적해서 50row로 만드는게 목적
#조건문으로 들어가게 해줘야함
else:
    master = pd.concat([master, temp_master])
path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()
path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    df_temp = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df_temp.loc[i-12] = temp
    
    df_4 = df_temp.loc[:,'Recipe_Step_Number':(df_temp.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    df_4.Time = pd.to_datetime(df_temp.Time) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4.Time})
    
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    # 6Step만 선택
    df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 사전 정의
    Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    #Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Impedence 계산
    # df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) 
    # sqrt 쓰면 cannot convert the series to <class 'float'> 오류남
    
    df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)
    
    del df_6['HF_R_A']
    del df_6['HF_X_A']
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])

path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()
k=0
f = open(path_dir +  '\\' +  file_list[k])

lines = f.readlines()
labels = lines[11].split() # line 11 : Factor

df_temp = pd.DataFrame(columns = labels)

for i in range(13, len(lines)):
    temp = lines[i]
    temp = temp.split()
    temp_date = temp[0] + ' ' + temp[1]
    
    del temp[0]
    del temp[0]
    
    temp.insert(0, temp_date)
    
    df_temp.loc[i-12] = temp

df_4 = df_temp.loc[:,'Recipe_Step_Number':(df_temp.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
df_4['Time'] = pd.to_datetime(df_temp['Time']) # 타입 변환
df_4['Time'] = pd.DataFrame({'Time' : df_4['Time']})

cols = df_4.columns.tolist()
cols = cols[-1:] + cols[:-1]
df_4 = df_4[cols]
df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]

#뽑을 Factor들을 사전 정의
Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
#Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'HF_R_A', 'HF_X_A' ]   
df_6 = df_5[Temp_Input]
df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)
temp_imp = pd.DataFrame(((df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)),columns=['Impedence'])
df_6 = pd.concat([df_6, temp_imp], axis = 1)
del df_6['HF_R_A']
del df_6['HF_X_A']
del temp_imp

# Factor들 이름만 가져옴
answer = df_6.std().index 

# 통계량 접미사 만들고 통계량 추출
answer_mean = answer + '_mean'
value_mean = df_6.mean()
answer_median = answer + '_median'
value_median = df_6.median()
answer_std = answer + '_std'
value_std = df_6.std()
temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
temp_mean.loc[0] = value_mean.values
temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
temp_median.loc[0] = value_median.values
temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
temp_std.loc[0] = value_std.values

# log 한개당 한줄로 추출
temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)

if k ==0:
    master_2 = temp_master # 제일 처음에만    

# log 50개를 누적해서 50row로 만드는게 목적
#조건문으로 들어가게 해줘야함
else:
    master_2 = pd.concat([master_2, temp_master])
path_dir = r'C:\Users\wtjang\Documents\work\L_MOLD_TEMP'
file_list = os.listdir(path_dir)
file_list.sort()

for k in range(0, len(file_list)):
    
    f = open(path_dir +  '\\' +  file_list[k])
    
    lines = f.readlines()
    labels = lines[11].split() # line 11 : Factor
    
    df_temp = pd.DataFrame(columns = labels)
    
    for i in range(13, len(lines)):
        temp = lines[i]
        temp = temp.split()
        temp_date = temp[0] + ' ' + temp[1]
        
        del temp[0]
        del temp[0]
        
        temp.insert(0, temp_date)
        
        df_temp.loc[i-12] = temp
    
    df_4 = df_temp.loc[:,'Recipe_Step_Number':(df_temp.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
    
    
    df_4['Time'] = pd.to_datetime(df_temp['Time']) # 타입 변환
    df_4['Time'] = pd.DataFrame({'Time' : df_4['Time']})
    
    cols = df_4.columns.tolist()
    cols = cols[-1:] + cols[:-1]
    df_4 = df_4[cols]
    
    # 6Step만 선택
    df_5 = df_4.loc[df_4['Recipe_Step_Number'] == 6]
    
    #뽑을 Factor들을 사전 정의
    Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'FORE_BARA_GAUGE','HEAT_EX_TEMP_A' ,'HF_R_A', 'HF_X_A' ]   
    #Temp_Input = ['Time', 'S1_CHUCK_POSITION', 'HF_R_A', 'HF_X_A' ]   
    df_6 = df_5[Temp_Input]
    
    # Impedence 계산
    # df_6['Impedence'] = sqrt(df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) 
    # sqrt 쓰면 cannot convert the series to <class 'float'> 오류남
    
    #df_6['Impedence'] = (df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)
    temp_imp = pd.DataFrame(((df_6['HF_R_A'] * df_6['HF_R_A'] + df_6['HF_X_A'] * df_6['HF_X_A']) ** (1/2)),columns=['Impedence'])
    
    df_6 = pd.concat([df_6, temp_imp], axis = 1)
    
    del df_6['HF_R_A']
    del df_6['HF_X_A']
    del temp_imp
    
    # Factor들 이름만 가져옴
    answer = df_6.std().index 
    
    # 통계량 접미사 만들고 통계량 추출
    answer_mean = answer + '_mean'
    value_mean = df_6.mean()
    answer_median = answer + '_median'
    value_median = df_6.median()
    answer_std = answer + '_std'
    value_std = df_6.std()
    
    # 1줄로 추출
    temp_mean = pd.DataFrame(index=range(0,0), columns=[answer_mean])
    temp_mean.loc[0] = value_mean.values
    temp_median = pd.DataFrame(index=range(0,0), columns=[answer_median])
    temp_median.loc[0] = value_median.values
    temp_std = pd.DataFrame(index=range(0,0), columns=[answer_std])
    temp_std.loc[0] = value_std.values
    
    # log 한개당 한줄로 추출
    temp_master = pd.concat([temp_mean, temp_median, temp_std], axis = 1)
    
    if k ==0:
        master_2 = temp_master # 제일 처음에만    
    # log 50개를 누적해서 50row로 만드는게 목적
    #조건문으로 들어가게 해줘야함
    else:
        master_2 = pd.concat([master_2, temp_master])

master = master.reset_index(drop=True)   # Gas
master_2 = master_2.reset_index(drop=True) # Temp 
result = result.reset_index(drop=True)  # Result
result = pd.read_excel(r'C:\Users\wtjang\Documents\work\L_MOLD_result.xlsx')

# re_index 해주기 -> index 맞추는 작업 필요 
master = master.reset_index(drop=True)   # Gas
master_2 = master_2.reset_index(drop=True) # Temp 
result = result.reset_index(drop=True)  # Result
final_master_D_R = pd.concat([master, master_2, result['D_R']],axis = 1)
from sklearn.model_selection import train_test_split
from sklearn import neighbors
from sklearn.metrics import mean_squared_error 
from math import sqrt
import matplotlib.pyplot as plt
train_data, test_data = train_test_split(final_master_D_R, test_size = 0.2, random_state = 123)

# seperate the independent and target variable on training data
train_x = train_data.drop(columns=['D_R'], axis=1)
train_y = train_data['D_R']

test_x = test_data.drop(columns=['D_R'], axis=1)
test_y = test_data['D_R']
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0, 1))
train_x_scaled = scaler.fit_transform(train_x)
train_x = pd.DataFrame(train_x_scaled)

test_x_scaled = scaler.fit_transform(test_x)
test_x = pd.DataFrame(test_x_scaled)
rmse_val = []

for K in range(20):
    K = K+1
    
    model = neighbors.KNeighborsRegressor(n_neighbors = K)
    
    model.fit(train_x, train_y)
    pred = model.predict(test_x)
    error = sqrt(mean_squared_error(test_y, pred))
    rmse_val.append(error)
    print('RMSE value for k = ' , K , 'is:', error)


curve = pd.DataFrame(rmse_val)
curve.plot() # k에 따른 rmse 곡선
curve.index = np.arange(1, len(curve))
import numpy as np
curve.index = np.arange(1, len(curve))
curve.index += 1
curve.plot() # k에 따른 rmse 곡선
K=5
model = neighbors.KNeighborsRegressor(n_neighbors = K)
model.fit(train_x, train_y)
pred = model.predict(test_x)
error = sqrt(mean_squared_error(test_y, pred))
rmse_val.append(error)
error
xs = np.arange(0,10,1)
ys = test_y.values
model = neighbors.KNeighborsRegressor(n_neighbors = K)
model.fit(train_x, train_y)
pred = model.predict(test_x)
error = sqrt(mean_squared_error(test_y, pred))
import numpy as np
xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')    

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')

ys_1 = pred
for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b') 

plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')
import numpy as np
xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')    

plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')
xs = np.arange(0,10,1)
ys = test_y.values
for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')

from matplotlib import pyplot
from sklearn.model_selection import cross_val_score,KFold
from sklearn.cross_validation import  train_test_split
from sklearn.metrics import mean_absolute_error
import matplotlib.pyplot as plt
from sklearn.grid_search import GridSearchCV   #Perforing grid search
from scipy.stats import skew
from collections import OrderedDict
import csv as csv
for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')

plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')

plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')    

from sklearn.metrics import mean_squared_error
RMSE = mean_squared_error(ys,ys_1) ** 0.5
RMSE
ys-ys1
ys-ys_1
abs(ys-ys_1)
abs(ys-ys_1)/ys
sum(abs(ys-ys_1)/ys)
len(ys)
100/len(ys)*sum(abs(ys-ys_1)/ys)
MAPE
MAPE = 100/len(ys)*sum(abs(ys-ys_1)/ys)
MAPE
K=16
odel = neighbors.KNeighborsRegressor(n_neighbors = K)

model.fit(train_x, train_y)
pred = model.predict(test_x)
error = sqrt(mean_squared_error(test_y, pred))
rmse_val.append(error)
curve = pd.DataFrame(rmse_val)
curve.index += 1
curve.plot() # k에 따른 rmse 곡선

# graph of acvtual vs pred value

plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')    

del curve
model = neighbors.KNeighborsRegressor(n_neighbors = K)

model.fit(train_x, train_y)
pred = model.predict(test_x)
error = sqrt(mean_squared_error(test_y, pred))
rmse_val.append(error)
curve = pd.DataFrame(rmse_val)
curve.index += 1
curve.plot() # k에 따른 rmse 곡선

# graph of acvtual vs pred value

plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')
del remse_val
del rmse_val
del curve
model = neighbors.KNeighborsRegressor(n_neighbors = K)
model.fit(train_x, train_y)
pred = model.predict(test_x)
error = sqrt(mean_squared_error(test_y, pred))
rmse_val.append(error)
curve = pd.DataFrame(rmse_val)
rmse_val = []
model = neighbors.KNeighborsRegressor(n_neighbors = K)
model.fit(train_x, train_y)
pred = model.predict(test_x)
error = sqrt(mean_squared_error(test_y, pred))
rmse_val.append(error)
curve = pd.DataFrame(rmse_val)
curve.index += 1
curve.plot() # k에 따른 rmse 곡선
model.fit(train_x, train_y)
pred = model.predict(test_x)
from sklearn.model_selection import train_test_split
from sklearn import neighbors
from sklearn.metrics import mean_squared_error 
from math import sqrt
import matplotlib.pyplot as plt

# train_test_split(arrays, test_size, train_size, random_state, shuffle, stratify)
train_data, test_data = train_test_split(final_master_D_R, test_size = 0.2, random_state = 123)

# seperate the independent and target variable on training data
train_x = train_data.drop(columns=['D_R'], axis=1)
train_y = train_data['D_R']

test_x = test_data.drop(columns=['D_R'], axis=1)
test_y = test_data['D_R']

# Preprocessing 전처리 한게 더 오차율 좋음 RMSE 100감소
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0, 1))

train_x_scaled = scaler.fit_transform(train_x)
train_x = pd.DataFrame(train_x_scaled)

test_x_scaled = scaler.fit_transform(test_x)
test_x = pd.DataFrame(test_x_scaled)
rmse_val = []
model = neighbors.KNeighborsRegressor(n_neighbors = K)

model.fit(train_x, train_y)
pred = model.predict(test_x)
error = sqrt(mean_squared_error(test_y, pred))
rmse_val.append(error)
print('RMSE value for k = ' , K , 'is:', error)
curve = pd.DataFrame(rmse_val)
plt.plot(test_y.values, 'ro-')
plt.plot(pred, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')    

from sklearn.metrics import mean_squared_error
RMSE = mean_squared_error(ys,ys_1) ** 0.5
MAPE = 100/len(ys)*sum(abs(ys-ys_1)/ys)
RMSE
MAPE
mean_absolute_error(ys,ys_1)
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
model_random_forest = RandomForestRegressor()
model_random_forest.fit(train_x, train_y)
pred_random_forest = model_random_forest.predict(test_x)
plt.plot(test_y.values, 'ro-')
plt.plot(pred_random_forest, 'bo-')
plt.plot(test_y.values, 'ro-')
plt.plot(pred_random_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_random_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')  

model_random_forest = RandomForestRegressor(n_estimators = 20)
model_random_forest.fit(train_x, train_y)



pred_random_forest = model_random_forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_random_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_random_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')  

model_random_forest = RandomForestRegressor()
model_random_forest.fit(train_x, train_y)



pred_random_forest = model_random_forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_random_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_random_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')  

model_random_forest = RandomForestRegressor(n_estimators=100)
model_random_forest.fit(train_x, train_y)



pred_random_forest = model_random_forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_random_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_random_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'b')  

forest = RandomForestRegressor(n_estimators=100)
forest.fit(train_x, train_y)
pred_forest = forest.predict(test_x)
plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')
plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')
xs = np.arange(0,10,1)
ys = test_y.values
pred_forest = forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,20),
                 ha = 'center',
                 color = 'r')

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

lt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

ys_1 = forest
plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

forest = RandomForestRegressor(n_estimators=100, random_state=42)
forest.fit(train_x, train_y)



pred_forest = forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

forest = RandomForestRegressor(n_estimators=100, max_features = 10, random_state=42)
forest.fit(train_x, train_y)



pred_forest = forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

forest = RandomForestRegressor(n_estimators=100, max_features = 100, random_state=42)
forest.fit(train_x, train_y)



pred_forest = forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

forest = RandomForestRegressor(n_estimators=100, max_features = 30, random_state=42)
forest.fit(train_x, train_y)



pred_forest = forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b') 

forest = RandomForestRegressor(n_estimators=100, max_features = 40, random_state=42)
forest.fit(train_x, train_y)



pred_forest = forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

forest = RandomForestRegressor(n_estimators=100, max_features = 35, random_state=42)
forest.fit(train_x, train_y)



pred_forest = forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

forest = RandomForestRegressor(n_estimators=100, max_features = 30, random_state=42)
forest.fit(train_x, train_y)



pred_forest = forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

forest = RandomForestRegressor(n_estimators=100, max_features = 31, random_state=42)
forest.fit(train_x, train_y)



pred_forest = forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

forest = RandomForestRegressor(n_estimators=100, max_features = 31, random_state=100)
forest.fit(train_x, train_y)



pred_forest = forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

forest = RandomForestRegressor(n_estimators=100, max_features = 31, random_state=200)
forest.fit(train_x, train_y)



pred_forest = forest.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b') 

from sklearn.model_selection import RandomizedSearchCV
n_estimators = [int(x) for x in np.linspace(start = 200, stop = 2000, num = 10)]
max_features = ['auto', 'sqrt']
max_depth = [int(x) for x in np.linspace(10, 110, num = 11)]
max_depth.append(None)
min_samples_split = [2, 5, 10]
min_samples_leaf = [1, 2, 4]
bootstrap = [True, False]
random_grid = {'n_estimators': n_estimators,
               'max_features': max_features,
               'max_depth': max_depth,
               'min_samples_split': min_samples_split,
               'min_samples_leaf': min_samples_leaf,
               'bootstrap': bootstrap}
pprint(random_grid)
print(random_grid)
rf = RandomForestRegressor()
rf_random = RandomizedSearchCV(estimator = rf, param_distributions = random_grid, 
                               n_iter = 100, cv = 3, verbose=2, random_state=42, n_jobs = -1)
rf_random.fit(train_x, train_y)
rf_random.best_params_
from sklearn.model_selection import GridSearchCV
param_grid = {
    'bootstrap': [True],
    'max_depth': [80, 90, 100, 110],
    'max_features': [2, 3],
    'min_samples_leaf': [3, 4, 5],
    'min_samples_split': [8, 10, 12],
    'n_estimators': [100, 200, 300, 1000]
}
rf = RandomForestRegressor()
grid_search = GridSearchCV(estimator = rf, param_grid = param_grid, 
grid_search = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 1, verbose = 2)
grid_search.fit(train_x, train_y)
grid_search.best_params_
best_grid = grid_search.best_estimator_

grid_accuracy = evaluate(best_grid, test_features, test_labels)
best_grid = grid_search.best_estimator_
best_grid
pred_forest_grid_1 = grid_search.predict(test_x)
plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest_grid_1, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest_grid_1

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

RMSE = mean_squared_error(ys,ys_1) ** 0.5
MAPE = 100/len(ys)*sum(abs(ys-ys_1)/ys)
RMSE
MAPE
grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 8, verbose = 10)
import time
start = time.time()  # 시작 시간 저장

grid_search_2.fit(train_x, train_y)

print("time :", time.time() - start)  # 현재시각 - 시작시간 = 실행 시간
grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
import time
start = time.time()  # 시작 시간 저장
_
grid_search_2.fit(train_x, train_y)
print("time :", time.time() - start)  # 현재시각 - 시작시간 = 실행 시간
if __name__ == '__main__':
    grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
    import time
    start = time.time()  # 시작 시간 저장
    
    
    grid_search_2.fit(train_x, train_y)
    
    print("time :", time.time() - start)  # 현재시각 - 시작시간 = 실행 시간

if __name__ == '__main__':
    grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)

if __name__ == '__main__':
    grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
    import time
    start = time.time()  # 시작 시간 저장

start
if __name__ == '__main__':
    grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
    import time
    start = time.time()  # 시작 시간 저장
    
    
    grid_search_2.fit(train_x, train_y)

if __name__ == '__main__':
    grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 2, verbose = 10)
    import time
    start = time.time()  # 시작 시간 저장
    
    
    grid_search_2.fit(train_x, train_y)

import time
from math import sqrt
from joblib import Parallel, delayed
if __name__ == '__main__':
    grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 2, verbose = 10)
    
    start = time.time()  # 시작 시간 저장
    
    
    grid_search_2.fit(train_x, train_y)
    
    print("time :", time.time() - start)  # 현재시각 - 시작시간 = 실행 시간

if __name__ == '__main__':
    grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
    
    start = time.time()  # 시작 시간 저장
    
    
    grid_search_2.fit(train_x, train_y)
    
    print("time :", time.time() - start)  # 현재시각 - 시작시간 = 실행 시간

if __name__ == '__main__':
    grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = -1, verbose = 10)
    
    start = time.time()  # 시작 시간 저장
    
    
    grid_search_2.fit(train_x, train_y)
    
    print("time :", time.time() - start)  # 현재시각 - 시작시간 = 실행 시간

if __name__ == '__main__':
    grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
    
    start = time.time()  # 시작 시간 저장
    
    
    grid_search_2.fit(train_x, train_y)

if __name__ == '__main__':
    grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
    
    start = time.time()  # 시작 시간 저장




grid_search_2.fit(train_x, train_y)
from joblib import Parallel, delayed
class Test():
   def __init__(self):
       rf = RandomForestRegressor()
       grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
       grid_search_2.fit(train_x, train_y)



if __name__ == '__main__':
   Test()

import numpy as np
from sklearn.model_selection import RandomizedSearchCV
from sklearn.tree import DecisionTreeClassifier
class Test():
   def __init__(self):
       rf = RandomForestRegressor()
       grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
       grid_search_2.fit(train_x, train_y)



if __name__ == '__main__':
   Test()

from sklearn.externals.joblib  import Parallel, delayed
class Test():
   def __init__(self):
       rf = RandomForestRegressor()
       grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
       grid_search_2.fit(train_x, train_y)



if __name__ == '__main__':
   Test()

if __name__ == '__main__':
    grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
    
    start = time.time()  # 시작 시간 저장
    
    
    grid_search_2.fit(train_x, train_y)
    
    print("time :", time.time() - start)  # 현재시각 - 시작시간 = 실행 시간

grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                      cv = 3, n_jobs = 10, verbose = 10)
grid_search_2
grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                      cv = 3, n_jobs = 10, verbose = 10)
grid_search_2
param_grid = {
    'bootstrap': [True],
    'max_depth': [80, 90, 100, 150, 200, 250, 300],
    'max_features': [2, 5, 8, 11, 14, 17, 20],
    'min_samples_leaf': [3, 4, 5, 6, 7, 8],
    'min_samples_split': [8, 10, 12],
    'n_estimators': [100, 200, 300, 500, 1000]
}

grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 10, verbose = 10)
start = time.time()  # 시작 시간 저장
grid_search_2.fit(train_x, train_y)
print("time :", time.time() - start)  # 현재시각 - 시작시간 = 실행 시간
grid_search_2
start = time.time()  # 시작 시간 저장
grid_search_2.fit(train_x, train_y)
print("time :", time.time() - start)  # 현재시각 - 시작시간 = 실행 시간
grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 1, verbose = 10)
start = time.time()  # 시작 시간 저장
grid_search_2.fit(train_x, train_y)
print("time :", time.time() - start)  # 현재시각 - 시작시간 = 실행 시간
grid_search_2 = GridSearchCV(estimator = rf, param_grid = param_grid, 
                          cv = 3, n_jobs = 1, verbose = 10)


start = time.time()  # 시작 시간 저장
grid_search_2.fit(train_x, train_y)
print("time :", time.time() - start)  # 현재시각 - 시작시간 = 실행 시간
grid_search_2.best_params_
grid_search_2
grid_search_2.best_grid_search_2
grid_search_2
grid_search_2.best_estimator_
pred_forest_grid_2 = grid_search_2.best_estimator_(test_x)
model_2 = grid_search_2.best_estimator_
pred_forest_grid_2 = model_2.predict(test_x)
plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest_grid_2, 'bo-')
plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest_grid_2, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest_grid_2

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  


RMSE = mean_squared_error(ys,ys_1) ** 0.5
MAPE = 100/len(ys)*sum(abs(ys-ys_1)/ys)
plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest_grid_1, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest_grid_1

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  


RMSE = mean_squared_error(ys,ys_1) ** 0.5
MAPE = 100/len(ys)*sum(abs(ys-ys_1)/ys)
model_1 = grid_search_1.best_estimator_
model_1 = grid_search_.best_estimator_
model_1 = grid_search.best_estimator_
pred_forest_grid_1 = model_1.predict(test_x)
pred_forest_grid_1 = model_1.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest_grid_1, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest_grid_1

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  


RMSE = mean_squared_error(ys,ys_1) ** 0.5
MAPE = 100/len(ys)*sum(abs(ys-ys_1)/ys)
model_2 = grid_search_2.best_estimator_


pred_forest_grid_2 = model_2.predict(test_x)

plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest_grid_2, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest_grid_2

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

RMSE = mean_squared_error(ys,ys_1) ** 0.5
MAPE = 100/len(ys)*sum(abs(ys-ys_1)/ys)
RMSE
MAPE
plt.plot(test_y.values, 'ro-')
plt.plot(pred_forest, 'bo-')

xs = np.arange(0,10,1)
ys = test_y.values

for x, y in zip(xs, ys):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'r')


ys_1 = pred_forest

for x, y in zip(xs, ys_1):
    label = "{:.2f}".format(y)
    
    plt.annotate(label,
                 (x,y),
                 textcoords = "offset points",
                 xytext=(0,10),
                 ha = 'center',
                 color = 'b')  

RMSE = mean_squared_error(ys,ys_1) ** 0.5
MAPE = 100/len(ys)*sum(abs(ys-ys_1)/ys)
RMSE
MAPE
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
f = open(path_dir +  '\\' +  file_list[2]) # 25p 가져오기
file_list[2]
lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
data = {}
for i in range(0, len(temp_25point)):
data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]
data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:0.5, minx:maxx:0.5]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0
        if ((147-i)**2 + (147-j)**2) < 147**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:0.5, minx:maxx:0.5]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0
        if ((147-i)**2 + (147-j)**2) < 147**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:0.5, miny:maxy:0.5]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:0.1, miny:maxy:0.1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((1470-i)**2 + (1470-j)**2) > 1470**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = temp_25point.loc[0:48,]
for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
109_point = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt 좌표.xlsx')
109_point = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx')
result = pd.read_excel(r'C:\Users\wtjang\Documents\work\L_MOLD_result.xlsx')
kkk = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx')
109_point = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx')
point_109 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx')
point_109 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx', header = 1)
point_109 = point_109[['X','Y','THK']]
data = {}
data = {}

for i in range(0, len(point_109)):
    
    data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((144-i)**2 + (144-j)**2) > 144**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan    
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan  
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((142-i)**2 + (142-j)**2) > 142**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      
len(z_)
size(z_)
type(z_)
z_.ndim
z_.size
z_.shape
z_.shape(,2)
z_.shape[2]
z_.shape[,2]
z_.shape[0]
z_.shape[1]
for i in range(0,len(z_.shape[1])):
    for j in range(0,len(z_.shape[1])):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan    
len(z_.shape[1])
z_.shape[1]
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0

z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:0.5, minx:maxx:0.5]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0

z_[z_ == 0] = np.nan     
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((246-i)**2 + (246-j)**2) > 246**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)
z_.shape[1]
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
z_.shape[1]
min(z_.shape[0], z_.shape[1])
for i in range(0,min(z_.shape[0], z_.shape[1])):
    for j in range(0,min(z_.shape[0], z_.shape[1])):
        if ((min(z_.shape[0], z_.shape[1])-i)**2 + (min(z_.shape[0], z_.shape[1])-j)**2) > min(z_.shape[0], z_.shape[1])**2:
            z_[i,j] = 0

z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,min(z_.shape[0], z_.shape[1])):
    for j in range(0,min(z_.shape[0], z_.shape[1])):
        if ((min(z_.shape[0], z_.shape[1])-i)**2 + (min(z_.shape[0], z_.shape[1])-j)**2) > min(z_.shape[0], z_.shape[1])**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan     
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x=np.random.rand(100)*100
y=np.random.rand(100)*100
interpolants = numpy.array([xnew, ynew])
xnew = range(100)
ynew = range(100)
xnew
interpolants = numpy.array([xnew, ynew])
interpolants = np.array([xnew, ynew])
znew = scipy.interpolate.griddata((x, y), z, interpolants) 
import scipy
znew = scipy.interpolate.griddata((x, y), z, interpolants)
from scipy.interpolate import interp1d
znew = scipy.interpolate.griddata((x, y), z, interpolants) 
interpolants
xnew = range(100)
ynew = range(100)

z= x*y

interpolants = np.array([xnew, ynew])

from scipy.interpolate import interp1d

znew = scipy.interpolate.griddata((x, y), z, interpolants) 
file_list
temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
temp_73point = df_Point_finial_dict[20]
temp_73point = temp_73point.loc[:,'X':(temp_73point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
temp_ring = temp_73point.loc[24:end,:]
temp_ring = temp_73point.loc[[24:end],:]
temp_ring = temp_73point.loc[24:len(temp_73point),:]
temp_ring = temp_73point.loc[25:len(temp_73point),:]
data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_ring.iloc[i,0]),int(temp_ring.iloc[i,1])] = temp_ring.iloc[i,2]

data = {}

for i in range(0, len(temp_ring)):
    
    data[int(temp_ring.iloc[i,0]),int(temp_ring.iloc[i,1])] = temp_ring.iloc[i,2]

temp_ring.iloc[i,0]
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])
np.amin(x)
np.amin(x,2)
np.argsort(np.max(x, axis=0))[-2]
np.max(x, axis=0)
np.argsort(x, axis=0)
np.argsort(x)
x
import heapq
heapq.nlargest(2,x)
heapq.nlargest(2,x)[0]
heapq.nlargest(2,x)[1]
minx, maxx = heapq.nlargest(2,x)[1], heapq.nlargest(2,x)[0]
minx, maxx = heapq.nlargest(2,x)[1], heapq.nlargest(2,x)[0]
miny, maxy = heapq.nlargest(2,y)[1], heapq.nlargest(2,y)[0]
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:0.1, miny:maxy:0.1]
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = 142
y= 38
r = 117
sqrt(4)
r
r^2
r**2
x1 =  sqrt(r**2/(1+(y/x)**2))
x1
y1 = (y/x)*x1
y1
x = 127
y= 73
r = 117

x1 =  sqrt(r**2/(1+(y/x)**2))
y1 = (y/x)*x1

x1
y1
x1
y1
x = 104
y= 104
r = 117

x1 =  sqrt(r**2/(1+(y/x)**2))
y1 = (y/x)*x1
x1
1
y1
x = 73
y= 127
r = 117
x1 =  sqrt(r**2/(1+(y/x)**2))
y1 = (y/x)*x1
x1
y1
x = -38
y= 142
r = 117

x1 =  sqrt(r**2/(1+(y/x)**2))
y1 = (y/x)*x1
x1
y1
x = 38
y= 142
x1 =  sqrt(r**2/(1+(y/x)**2))
y1 = (y/x)*x1
x1
y1
x = 38
y= 142
r = 117

x1 =  sqrt(r**2/(1+(abs(y/x))**2))
y1 = (abs(y/x))*x1
x1
1
y1
x = -38
y= 142
r = 117

x1 =  sqrt(r**2/(1+(abs(y/x))**2))
y1 = (abs(y/x))*x1
x1
y1
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
file_list
file_list[2]
file_list[3]
f = open(path_dir +  '\\' +  file_list[23) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[23) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[23]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[23]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

file_list[3]
df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]

df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')

cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_73point = df_Point_finial_dict[20]
temp_73point = temp_73point.loc[:,'X':(temp_73point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
temp_1_25point = temp_73point.loc[0:24,:]
temp_1_25point = temp_73point.loc[0:24,:]
temp_26_49point = temp_73point.loc[25:48,:]
temp_50_73point = temp_73point.loc[49:72,:]
temp_26_49point.loc[25,'X']
temp_26_49point.loc[25,'Y']
temp_26_49point.loc[25,'Y'] < 0
temp_26_49point.loc[25,'X'] ==\ 0
temp_26_49point.loc[25,'X'] == 0
len(temp_26_49point)
i
i=25
temp_26_49point.loc[i,'X'] == 0
temp_26_49point.loc[i,'X']
temp_26_49point.loc[i,'Y']
temp_26_49point.loc[i,'X'] == 0 || temp_26_49point.loc[i,'Y'] == 0
temp_26_49point.loc[i,'X'] == 0 | temp_26_49point.loc[i,'Y'] == 0
int(temp_26_49point.loc[i,'X']) == 0 | int(temp_26_49point.loc[i,'Y']) == 0
i
(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
i=32
(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
i=33
(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
i=31
(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
after_r = 30
temp_26_49point.loc[i,'X']
i=25
temp_26_49point.loc[i,'X']
(int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
x1
del x1, y1
after_r
for i in range(25,len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_26_49point.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_26_49point.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_26_49point.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        else (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_26_49point.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r
    
    
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = x1
            temp_26_49point.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) | (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = -x1
            temp_26_49point.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) | (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = -x1
            temp_26_49point.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = x1
            temp_26_49point.loc[i,'Y'] = -y1
            
            del x1, y1

for i in range(25,len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_26_49point.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_26_49point.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_26_49point.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        else (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_26_49point.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r

(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) < 0)
temp_1_25point = temp_73point.loc[0:24,:]
temp_26_49point = temp_73point.loc[25:48,:]
temp_50_73point = temp_73point.loc[49:72,:]

after_r = 30

for i in range(25,len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_26_49point.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_26_49point.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_26_49point.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        else (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_26_49point.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r
    
    
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = x1
            temp_26_49point.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) | (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = -x1
            temp_26_49point.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) | (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = -x1
            temp_26_49point.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = x1
            temp_26_49point.loc[i,'Y'] = -y1
            
            del x1, y1

I
i
(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
(int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) > 0)
temp_26_49point.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
(int(temp_26_49point.loc[i,'X']) < 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) < 0)
temp_26_49point.loc[i,'X']
temp_26_49point.loc[i,'Y']
for i in range(25,len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_26_49point.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_26_49point.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_26_49point.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        else (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_26_49point.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = x1
            temp_26_49point.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) | (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = -x1
            temp_26_49point.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) | (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = -x1
            temp_26_49point.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_26_49point.loc[i,'X'] = x1
            temp_26_49point.loc[i,'Y'] = -y1
            
            del x1, y1

temp_1_25point = temp_73point.loc[0:24,:]
temp_26_49point = temp_73point.loc[25:48,:]
temp_50_73point = temp_73point.loc[49:72,:]
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]



'''
df_10 = df_Point.loc[num_Feature*0:num_Feature*1-1,]
df_11 = df_Point.loc[num_Feature*1:num_Feature*2-1,]
df_12 = df_Point.loc[num_Feature*2:num_Feature*3-1,]

dict 사용해서 loop 돌리는 코드

wafer 숫자가 임의로 들어오기 떄문에 임의의 숫자 n(가령 12라던지)가 들어와도 이를 0으로 시작하는 반복문으로 만들 필요가 있음
이를 계산하려면 i-num_first_Wafer 이 값이 1씩 증가하기 때문에 이를 사용
'i/i = 1, 2i/i = 2' 이런 관계로 표현한거임

output : dict의 key 값은 wafer slot과 동일하고 그 안에는 해당 wafer의 좌표 계측 값이 있음.
25p, 49p 확인완료
'''
df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

temp_73point = df_Point_finial_dict[20]
temp_73point = temp_73point.loc[:,'X':(temp_73point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]



temp_1_25point = temp_73point.loc[0:24,:]
temp_26_49point = temp_73point.loc[25:48,:]
temp_50_73point = temp_73point.loc[49:72,:]
after_r = 30
temp_data = temp_26_49point
(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
(int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0)
(int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0)
(int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0)
(int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0)
i=26
(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
(int(temp_26_49point.loc[i,'X']) > 0) | (int(temp_26_49point.loc[i,'Y']) > 0)
(int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0)
(int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0)
(int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0)
(int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0)
x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
x1
y1
-x1
for i in range(25,len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        else (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1


temp_data = temp_26_49point

for i in range(25,len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        else (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1

int(temp_26_49point.loc[i,'X']) == 0
int(temp_26_49point.loc[i,'Y']) < 0
for i in range(25,len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        else int(temp_26_49point.loc[i,'X']) == 0 & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1

for i in range(25,len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1

after_r
temp_data = temp_26_49point

for i in range(25,len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1

i
temp_73point = df_Point_finial_dict[20]
temp_73point = temp_73point.loc[:,'X':(temp_73point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]



temp_1_25point = temp_73point.loc[0:24,:]
temp_26_49point = temp_73point.loc[25:48,:]
temp_50_73point = temp_73point.loc[49:72,:]

after_r = 30
len(temp_26_49point)
25+len(temp_26_49point)
for i in range(25,25+len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1


temp_26_49point = temp_data
temp_ring = pd.concat([temp_26_49point, temp_50_73point], axis = 1)
temp_ring = pd.concat([temp_26_49point, temp_50_73point], axis = 0)
data = {}

for i in range(0, len(temp_ring)):
    
    data[int(temp_ring.iloc[i,0]),int(temp_ring.iloc[i,1])] = temp_ring.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
import heapq
#heapq.nlargest(2,x)
minx, maxx = heapq.nlargest(2,x)[1], heapq.nlargest(2,x)[0]
miny, maxy = heapq.nlargest(2,y)[1], heapq.nlargest(2,y)[0]
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:1, miny:maxy:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
import heapq
#heapq.nlargest(2,x)
minx, maxx = heapq.nlargest(2,x)[1], heapq.nlargest(2,x)[0]
miny, maxy = heapq.nlargest(2,y)[1], heapq.nlargest(2,y)[0]
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:0.1, miny:maxy:0.1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!
temp_ring = pd.concat([temp_1_25point,temp_26_49point, temp_50_73point], axis = 0)
data = {}

for i in range(0, len(temp_ring)):
    
    data[int(temp_ring.iloc[i,0]),int(temp_ring.iloc[i,1])] = temp_ring.iloc[i,2]


x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
import heapq
#heapq.nlargest(2,x)
minx, maxx = heapq.nlargest(2,x)[1], heapq.nlargest(2,x)[0]
miny, maxy = heapq.nlargest(2,y)[1], heapq.nlargest(2,y)[0]
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:0.1, miny:maxy:0.1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)
data = {}

for i in range(0, len(temp_ring)):
    
    data[int(temp_ring.iloc[i,0]),int(temp_ring.iloc[i,1])] = temp_ring.iloc[i,2]






x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])






minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y) #뒤집어!
rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0
        if ((117-i)**2 + (117-j)**2) < 117**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan    
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0
        if ((117-i)**2 + (117-j)**2) < 115**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0
        
        if ((117-i)**2 + (117-j)**2) < 117**2:
            z_[i,j] = 0



z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0





z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0



for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((117-i)**2 + (117-j)**2) < 117**2:
            z_[i,j] = 0       


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')

cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


'''
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((117-i)**2 + (117-j)**2) < 117**2:
            z_[i,j] = 0       
 '''           

z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')

cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0



for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) < 117**2:
            z_[i,j] = 0       


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
%clear
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

temp_73point = df_Point_finial_dict[20]
temp_73point = temp_73point.loc[:,'X':(temp_73point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
temp_73point = df_Point_finial_dict[20]
temp_73point = temp_73point.loc[:,'X':(temp_73point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]



temp_1_25point = temp_73point.loc[0:24,:]
temp_26_49point = temp_73point.loc[25:48,:]
temp_50_73point = temp_73point.loc[49:72,:]

after_r = 30
temp_data = temp_26_49point
for i in range(25,25+len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1




temp_26_49point = temp_data
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt
for i in range(25,25+len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] + after_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + after_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1




temp_26_49point = temp_data
temp_73point = df_Point_finial_dict[20]
temp_73point = temp_73point.loc[:,'X':(temp_73point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]



temp_1_25point = temp_73point.loc[0:24,:]
temp_26_49point = temp_73point.loc[25:48,:]
temp_50_73point = temp_73point.loc[49:72,:]

after_r = 30


temp_data = temp_26_49point
i=25
25+len(temp_26_49point)
if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0)

(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
(int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0)
(int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0)
(int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0)
(int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0)
temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - after_r
i=26
(int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0)
(int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0)
(int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0)
x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
import math
x1 =  sqrt(r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))
x1 =  (r**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
orginal_r = 147
delta_r = 30
(int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0)
(int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0)
x1 = ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
x1
y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
temp_data.loc[i,'X'] = -x1
temp_data.loc[i,'Y'] = y1
for i in range(25,25+len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] - delta_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - delta_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] + delta_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + delta_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1




temp_26_49point = temp_data
temp_26_49point = temp_data
temp_73point = df_Point_finial_dict[20]
temp_73point = temp_73point.loc[:,'X':(temp_73point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]



temp_1_25point = temp_73point.loc[0:24,:]
temp_26_49point = temp_73point.loc[25:48,:]
temp_50_73point = temp_73point.loc[49:72,:]


orginal_r = 147
delta_r = 30
orginal_r = 147
delta_r = 30

import math
temp_data = temp_26_49point

for i in range(25,25+len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] - delta_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - delta_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] + delta_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + delta_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1




temp_26_49point = temp_data
temp_ring = pd.concat([temp_1_25point,temp_26_49point, temp_50_73point], axis = 0)
data = {}

for i in range(0, len(temp_ring)):
    
    data[int(temp_ring.iloc[i,0]),int(temp_ring.iloc[i,1])] = temp_ring.iloc[i,2]






x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0



for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) < 117**2:
            z_[i,j] = 0       


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_73point = df_Point_finial_dict[20]
temp_73point = temp_73point.loc[:,'X':(temp_73point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]



temp_1_25point = temp_73point.loc[0:24,:]
temp_26_49point = temp_73point.loc[25:48,:]
temp_50_73point = temp_73point.loc[49:72,:]


orginal_r = 147
delta_r = 30

import math
temp_data = temp_26_49point

for i in range(25,25+len(temp_26_49point)):
    if (int(temp_26_49point.loc[i,'X']) == 0) | (int(temp_26_49point.loc[i,'Y']) == 0):
        
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] - delta_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] - delta_r
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) == 0):
            temp_data.loc[i,'X'] = temp_26_49point.loc[i,'X'] + delta_r
        
        elif (int(temp_26_49point.loc[i,'X']) == 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            temp_data.loc[i,'Y'] = temp_26_49point.loc[i,'Y'] + delta_r
    
    else:
        if (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) > 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) < 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = -x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1
        
        elif (int(temp_26_49point.loc[i,'X']) > 0) & (int(temp_26_49point.loc[i,'Y']) < 0):
            x1 =  ((orginal_r-delta_r)**2/(1+(abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))**2))**0.5
            y1 = (abs(temp_26_49point.loc[i,'Y']/temp_26_49point.loc[i,'X']))*x1
            
            temp_data.loc[i,'X'] = x1
            temp_data.loc[i,'Y'] = -y1
            
            del x1, y1



temp_26_49point = temp_data
temp_ring = pd.concat([temp_1_25point,temp_26_49point, temp_50_73point], axis = 0)

data = {}

for i in range(0, len(temp_ring)):
    
    data[int(temp_ring.iloc[i,0]),int(temp_ring.iloc[i,1])] = temp_ring.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

rbfi = Rbf(x, y, z)
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0



for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) < 117**2:
            z_[i,j] = 0       


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
file_list
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기
file_list[0]
point_109 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx', header = 1)
point_109 = point_109[['X','Y','THK']]
for i in range(0, len(point_109)):
    
    data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]

data = {}
point_109 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx', header = 1)

point_109 = point_109[['X','Y','THK']]

data = {}

for i in range(0, len(point_109)):
    
    data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]

i=0
point_109.iloc[i,0]
int(point_109.iloc[i,0])**2
int(point_109.iloc[i,0])**2 + int(point_109.iloc[i,1])**2
int(point_109.iloc[i,1])**2
edge_s = 135
(int(point_109.iloc[i,0])**2 + int(point_109.iloc[i,1])**2 < edge_s**2)
(int(point_109.iloc[i,0])**2 + int(point_109.iloc[i,1])**2 > edge_s**2)
for i in range(0, len(point_109)):
   
   if (int(point_109.iloc[i,0])**2 + int(point_109.iloc[i,1])**2 > edge_s**2):
       data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]

point_109 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx', header = 1)

point_109 = point_109[['X','Y','THK']]
edge_s = 135

for i in range(0, len(point_109)):
   if (int(point_109.iloc[i,0])**2 + int(point_109.iloc[i,1])**2 > edge_s**2):
       data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]

edge_s**2
i=0
(int(point_109.iloc[i,0])**2 + int(point_109.iloc[i,1])**2 > edge_s**2)
i=1
(int(point_109.iloc[i,0])**2 + int(point_109.iloc[i,1])**2 > edge_s**2)
del data
i=0
data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]
edge_s = 135
data = {}
for i in range(0, len(point_109)):
   if (int(point_109.iloc[i,0])**2 + int(point_109.iloc[i,1])**2 > edge_s**2):
       data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0

import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) < 135**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan    
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0

z_[z_ == 0] = np.nan      
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan    
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
edge_s = 135
data = {}
for i in range(0, len(point_109)):
   if (int(point_109.iloc[i,0])**2 + int(point_109.iloc[i,1])**2 > edge_s**2):
       data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]






'''
data = {}

for i in range(0, len(point_109)):
    
    data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]

'''





x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
z_.size
len(z_)
size(s_)
z_.ndim
z_.shape
z_.shape(1)
z_.shape[1]
z_.shape[0]
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
max(z_.shape[0], z_.shape[1])
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > max(z_.shape[0], z_.shape[1])/2**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > min(z_.shape[0], z_.shape[1])/2**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan   
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
min(z_.shape[0], z_.shape[1])/2
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > 142**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > 141**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > 143**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
z_.shape[0]/2
min(z_.shape[0]/2,z_.shape[1]/2)
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > min(z_.shape[0]/2,z_.shape[1]/2)**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > max(z_.shape[0]/2,z_.shape[1]/2)**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
point_109 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx', header = 1)

point_109 = point_109[['X','Y','THK']]


edge_s = 130
data = {}
for i in range(0, len(point_109)):
   if (int(point_109.iloc[i,0])**2 + int(point_109.iloc[i,1])**2 > edge_s**2):
       data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > max(z_.shape[0]/2,z_.shape[1]/2)**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      


plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > max(z_.shape[0]/2,z_.shape[1]/2)**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      
max(z_)
z_.max
max(z_)
z_.max()
z_.min()
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,z_.shape[1]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > max(z_.shape[0]/2,z_.shape[1]/2)**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan    
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar(boundaries=np.linspace(0,1,5)) 
z_.amax()
np.min(z_)
np.max(z_)
z_.min()
z_.max()
z_.argmin()
z_.argmax()
z_.argmax
z_.argmax()
arr = np.array([[8,2,3,4,5,6],  [3,6,6,7,2,6],   [3,8,5,1,2,9],   [6,4,2,7,8,3]])\                   
arr = np.array([[8,2,3,4,5,6],  [3,6,6,7,2,6],   [3,8,5,1,2,9],   [6,4,2,7,8,3]])
arr.min()
arr.max()
z_.min()
z_.nanmax()
nanmax(z_)
np.nanmax(z_)
np.nanmin(z_)
for i in range(0,z_.shape[0]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > max(z_.shape[0]/2,z_.shape[1]/2)**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
np.nanmin(z_)
np.nanmax(z_)
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar(boundaries=np.linspace(np.nanmin(z_),np.nanmax(z_),5)) 
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar(boundaries=np.linspace(np.nanmin(z_),np.nanmax(z_),10)) 
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar(boundaries=np.linspace(np.nanmin(z_),np.nanmax(z_),10),cmap = 'gist_rainbow_r') 
np.nanmax(z_)
import pandas as pd
STAR = pd.read_csv(r'C:\Users\wtjang\Documents\work\STAR_CA.csv')
STAR
import pandas as pd

STAR = pd.read_csv(r'C:\Users\wtjang\Documents\work\STAR_CA.csv')
STAR
type(STAR)
import pandas as pd
STAR = pd.read_csv(r'C:\Users\wtjang\Documents\work\STAR_CA.csv')
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp

STAR[1,1]
STAR(1,1)
STAR.iloc[1,1]
temp = STAR
temp.astype
type(temp.E)
type(temp.A)
import seaborn as sns
sns.distplotlot(temp['E'])
plt.show()
sns.distplot(temp['E'])
plt.show()
temp['E']
sns.distplot(temp['B_C/A'])
plt.show()
sns.distplot(temp[temp.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
temp_150 = temp.loc[temp['A'] == 150]
temp_150 = temp.loc[temp['A'] == 150 && temp['B'] == 3000]
temp_150 = temp.loc[temp['A'] == 150 & temp['B'] == 3000]
temp_150 = temp.loc[[temp['A'] == 150,  temp['B'] == 3000]]
temp[(temp.A == 150) & (temp.B == 3000)]
temp_150_2torr =  temp[(temp.A == 150) & (temp.B == 3000) &(temp.C == 2.5) & (temp.D == 100)]
temp_150_2torr =  temp[(temp.A == 150) & (temp.B == 3000) &(temp.C == 2.5)]
temp_150_2_5torr =  temp[(temp.A == 150) & (temp.B == 3000) &(temp.C == 2.5)]
temp_150_5torr =  temp[(temp.A == 150) & (temp.B == 3000) &(temp.C == 5)]
temp_150 =  temp[(temp.A == 150)]
sns.distplot(temp_150[temp_150.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_150[temp_150.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_150[temp_150.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_150[temp_150.E == "500/50"]["B_C/A"],  color="red", label="500/50")
sns.distplot(temp_150[temp_150.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_150[temp_150.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_150[temp_150.E == "500/50"]["B_C/A"],  color="red", label="500/50")
sns.distplot(temp_150[temp_150.E == "LF400"]["B_C/A"],  color="black", label="LF400")
sns.distplot(temp_150[temp_150.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_150[temp_150.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_150[temp_150.E == "LF400"]["B_C/A"],  color="red", label="LF400")
sns.distplot(temp_150[temp_150.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_150[temp_150.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_150[temp_150.E == "LF400"]["B_C/A"],  color="red", label="LF400")
plt.legend(title="E")
sns.distplot(temp_150[temp_150.C == 2.5]["B_C/A"],  color="blue", label="2.5")
sns.distplot(temp_150[temp_150.C == 5]["B_C/A"],  color="black", label="5")
sns.distplot(temp_150[temp_150.C == 2.5]["B_C/A"],  color="blue", label="2.5")
sns.distplot(temp_150[temp_150.C == 5]["B_C/A"],  color="black", label="5")
plt.legend(title="C")
sns.distplot(temp_150[temp_150.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_150[temp_150.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_150[temp_150.E == "LF400"]["B_C/A"],  color="red", label="LF400")
plt.legend(title="E")
STAR = pd.read_csv(r'C:\Users\wtjang\Documents\work\STAR_CA.csv')
temp_150_2_5torr =  temp[(temp.A == 150) & (temp.B == 3000) &(temp.C == 2.5)]

sns.distplot(temp_150_2_5torr[temp_150_2_5torr.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_150_2_5torr[temp_150_2_5torr.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_150_2_5torr[temp_150_2_5torr.E == "LF400"]["B_C/A"],  color="red", label="LF400")
plt.legend(title="E")
sns.distplot(temp_150_5torr[temp_150_5torr.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_150_5torr[temp_150_5torr.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_150_5torr[temp_150_5torr.E == "LF400"]["B_C/A"],  color="red", label="LF400")
plt.legend(title="E")
sns.distplot(temp_150_5torr[temp_150_5torr.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_150_5torr[temp_150_5torr.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_150_5torr[temp_150_5torr.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_150_5torr[temp_150_5torr.E == "CW"]["B_C/A"],  color="black", label="CW")
plt.legend(title="E")
temp_0 =  temp[(temp.A == 0) ]
temp_0 =  temp[(temp.A == 0) & (temp.B = 3000)]
temp_0 =  temp[(temp.A == 0) & (temp.B == 3000)]
sns.distplot(temp[temp.A == 0]["B_C/A"],  color="blue", label="0")
sns.distplot(temp[temp.A == 150]["B_C/A"],  color="black", label="150")
plt.legend(title="A")
temp_0['E'].values
temp_0['E'].unique()
sns.distplot(temp_0[temp_0.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_0[temp_0.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_0[temp_0.E == "LF50"]["B_C/A"],  color="red", label="LF50")
sns.distplot(temp_0[temp_0.E == "900/10"]["B_C/A"],  color="green", label="900/10")
plt.legend(title="E")
sns.distplot(temp_0[temp_0.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_0[temp_0.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_0[temp_0.E == "LF50"]["B_C/A"],  color="red", label="LF50")
#sns.distplot(temp_0[temp_0.E == "900/10"]["B_C/A"],  color="green", label="900/10")
plt.legend(title="E")
sns.distplot(temp_0[temp_0.C == 2]["B_C/A"],  color="blue", label="2")
sns.distplot(temp_0[temp_0.C == 2.5]["B_C/A"],  color="black", label="2.5")
plt.legend(title="C")
temp_0_2torr =  temp[(temp.A == 0) & (temp.B == 3000)& (temp.C == 2)]


temp_0_2_5torr =  temp[(temp.A == 0) & (temp.B == 3000)& (temp.C == 2.5)]
temp_0_2torr['E'].unique()
temp_0_2_5torr['E'].unique()
sns.distplot(temp_0_2torr[temp_0_2torr.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_0_2torr[temp_0_2torr.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_0_2torr[temp_0_2torr.E == "LF50"]["B_C/A"],  color="red", label="LF50")
plt.legend(title="E")
sns.distplot(temp_0_2_5torr[temp_0_2_5torr.E == "LF50"]["B_C/A"],  color="blue", label="LF50")
sns.distplot(temp_0_2_5torr[temp_0_2_5torr.E == "CW"]["B_C/A"],  color="black", label="CW")
plt.legend(title="E")
temp[temp.A == 0].mean()
temp.B_C/A[temp.A == 0].mean()
temp.A_RNG
temp.T
temp['B_C/A']
temp['B_C/A'].mean()
temp[temp.A == 0].mean()
temp[temp.A == 150].mean()
a = temp[temp.A == 150]
a['B_C/A'].mean()
temp[temp.A == 0].mean()
temp[temp.A == 150].mean()
temp[temp.A == 0].std() # 69.49
temp[temp.A == 150].std() # 81.14
temp_150[temp.C == 2.5].mean() # 69.49
temp_150[temp.C == 2.5].std() # 11.22
temp_150[temp.C == 5].mean() # 81.14
temp_150[temp.C == 5].std() # 14.96
temp_150[temp.C == 2.5].mean() # 69.49
temp_150[temp.C == 2.5].std() # 11.22
temp_150[temp.C == 5].mean() # 81.14
temp_150[temp.C == 5].std() # 14.96
temp_150[temp.E == "500/10"].mean() # 85.05
temp_150[temp.E == "500/10"].std() # 85.05
temp_150[temp.E == "CW"].mean() # 85.05
temp_150[temp.E == "CW"].std() # 85.05
temp_150[temp.E == "LF400"].mean() # 85.05
temp_150[temp.E == "LF400"].std() # 85.05
temp_150_2_5torr[temp_150_2_5torr.E == "500/10"].mean() # 78.4
temp_150_2_5torr[temp_150_2_5torr.E == "500/10"].std() # 16.5
temp_150_2_5torr[temp_150_2_5torr.E == "CW"].mean() # 88.59
temp_150_2_5torr[temp_150_2_5torr.E == "CW"].std() # 6
temp_150_2_5torr[temp_150_2_5torr.E == "LF400"].mean() # 64.7
temp_150_2_5torr[temp_150_2_5torr.E == "LF400"].std() # 3.57
temp_150_5torr[temp_150_5torr.E == "500/10"].mean() # 85.6
temp_150_5torr[temp_150_5torr.E == "500/10"].std() # 9.22
temp_150_5torr[temp_150_5torr.E == "CW"].mean() # 87.77
temp_150_5torr[temp_150_5torr.E == "CW"].std() # 6.08
temp_0[temp_0.C == 2].mean() # 72.2
temp_0[temp_0.C == 2].std() # 19.22
temp_0[temp_0.C == 2.5].mean() # 68.9
temp_0[temp_0.C == 2.5].std() # 12.12
temp_0[temp_0.E == "500/10"].mean() # 68.9
temp_0[temp_0.E == "500/10"].std() # 12.12
temp_0[temp_0.E == "CW"].mean() # 81.3
temp_0[temp_0.E == "CW"].std() # 8.18
temp_0[temp_0.E == "LF50"].mean() # 81.3
temp_0[temp_0.E == "LF50"].std() # 8.18
temp_0_2torr[temp_0_2torr.E == "500/10"].mean() # 81.3
temp_0_2torr[temp_0_2torr.E == "500/10"].std() # 8.18
temp_0_2torr[temp_0_2torr.E == "CW"].mean() # 66.71
temp_0_2torr[temp_0_2torr.E == "CW"].std() # 8.56
temp_0_2torr[temp_0_2torr.E == "LF50"].mean() # 59.37
temp_0_2torr[temp_0_2torr.E == "LF50"].std() # 5.29
temp_0_2_5torr[temp_0_2_5torr.E == "LF50"].mean() # 81.02
temp_0_2_5torr[temp_0_2_5torr.E == "LF50"].std() # 8.31
temp_0_2_5torr[temp_0_2_5torr.E == "CW"].mean() # 64.36
temp_0_2_5torr[temp_0_2_5torr.E == "CW"].std() # 9.23
sns.distplot(temp_150_2_5torr[temp_150_2_5torr.E == "500/10"]["B_C/A"],  color="blue", label="500/10")
sns.distplot(temp_150_2_5torr[temp_150_2_5torr.E == "CW"]["B_C/A"],  color="black", label="CW")
sns.distplot(temp_150_2_5torr[temp_150_2_5torr.E == "LF400"]["B_C/A"],  color="red", label="LF400")
sns.distplot(temp_150_2_5torr[temp_150_2_5torr.E == "500/50"]["B_C/A"],  color="red", label="500/50")
sns.distplot(temp[temp.C == 2.5]["B_C/A"],  color="blue", label="2")
sns.distplot(temp[temp.C == 5]["B_C/A"],  color="black", label="5")
plt.legend(title="C")
sns.distplot(temp[temp.C == 2]["B_C/A"],  color="blue", label="2")
sns.distplot(temp[temp.C == 2.5]["B_C/A"],  color="blue", label="2.5")
sns.distplot(temp[temp.C == 5]["B_C/A"],  color="black", label="5")
plt.legend(title="C")
sns.distplot(temp[temp.C == 2]["B_C/A"],  color="blue", label="2")
sns.distplot(temp[temp.C == 2.5]["B_C/A"],  color="red", label="2.5")
sns.distplot(temp[temp.C == 5]["B_C/A"],  color="black", label="5")
plt.legend(title="C")
sns.distplot(temp[temp.C == 2]["B_C/A"],  color="black", label="2")
sns.distplot(temp[temp.C == 2.5]["B_C/A"],  color="red", label="2.5")
sns.distplot(temp[temp.C == 5]["B_C/A"],  color="blue", label="5")
plt.legend(title="C")
sns.distplot(temp_150[temp_150.G == 250]["B_C/A"],  color="black", label="250")
sns.distplot(temp_150[temp_150.G == 350]["B_C/A"],  color="red", label="350")
sns.distplot(temp_150[temp_150.G == 400]["B_C/A"],  color="blue", label="400")
plt.legend(title="G")

## ---(Wed May  6 14:15:25 2020)---
import numpy as np
def exponential_cov(x,y,parmas):
    return params[0] * np.exp( -0.5 * params[1] * np.subtract.outer(x,y) ** 2)

def conditional(x_new, x, y, params):
    
    B = exponential_cov(x_new, x, params)
    C = exponential_cov(x, x, params)
    A = exponential_cov(x_new, x_new, params)
    
    mu = np.linalg.inv(C).dot(B.T).T.dot(y)
    sigma = A - B.dot(np.linalg.inv(C).dot(B.T))
    
    return(mu.squeeze(), sigma.squeeze())

import matplotlib.pylab as plt

θ = [1, 10]
σ_0 = exponential_cov(0, 0, θ)
xpts = np.arange(-3, 3, step=0.01)
plt.errorbar(xpts, np.zeros(len(xpts)), yerr=σ_0, capsize=0)
def exponential_cov(x,y,parmas):
    return params[0] * np.exp( -0.5 * params[1] * np.subtract.outer(x,y) ** 2)


def conditional(x_new, x, y, params):
    
    B = exponential_cov(x_new, x, params)
    C = exponential_cov(x, x, params)
    A = exponential_cov(x_new, x_new, params)
    
    mu = np.linalg.inv(C).dot(B.T).T.dot(y)
    sigma = A - B.dot(np.linalg.inv(C).dot(B.T))
    
    return(mu.squeeze(), sigma.squeeze())

import matplotlib.pylab as plt

θ = [1, 10]
σ_0 = exponential_cov(0, 0, θ)
xpts = np.arange(-3, 3, step=0.01)
plt.errorbar(xpts, np.zeros(len(xpts)), yerr=σ_0, capsize=0)
def exponential_cov(x,y,params):
    return params[0] * np.exp( -0.5 * params[1] * np.subtract.outer(x,y) ** 2)


def conditional(x_new, x, y, params):
    
    B = exponential_cov(x_new, x, params)
    C = exponential_cov(x, x, params)
    A = exponential_cov(x_new, x_new, params)
    
    mu = np.linalg.inv(C).dot(B.T).T.dot(y)
    sigma = A - B.dot(np.linalg.inv(C).dot(B.T))
    
    return(mu.squeeze(), sigma.squeeze())


import matplotlib.pylab as plt
θ = [1, 10]
σ_0 = exponential_cov(0, 0, θ)
xpts = np.arange(-3, 3, step=0.01)
plt.errorbar(xpts, np.zeros(len(xpts)), yerr=σ_0, capsize=0)
x=[1.]
x
y = [np.random.normal(scale=σ_0)]
y
def predict(x, data, kernel, params, sigma, t):
    k = [kernel(x, y, params) for y in data]
    Sinv = np.linalg.inv(sigma)
    y_pred = np.dot(k, Sinv).dot(t)
    sigma_new = kernel(x, x, params) - np.dot(k, Sinv).dot(k)

return y_pred, sigma_new

x_pred = np.linspace(-3, 3, 1000)
predictions = [predict(i, x, exponential_cov, θ, σ_1, y) for i in x_pred]
def predict(x, data, kernel, params, sigma, t):
    k = [kernel(x, y, params) for y in data]
    Sinv = np.linalg.inv(sigma)
    y_pred = np.dot(k, Sinv).dot(t)
    sigma_new = kernel(x, x, params) - np.dot(k, Sinv).dot(k)
    return y_pred, sigma_new


x_pred = np.linspace(-3, 3, 1000)
predictions = [predict(i, x, exponential_cov, θ, σ_1, y) for i in x_pred]
σ_1 = exponential_cov(x, x, θ)
σ_1
def predict(x, data, kernel, params, sigma, t):
    k = [kernel(x, y, params) for y in data]
    Sinv = np.linalg.inv(sigma)
    y_pred = np.dot(k, Sinv).dot(t)
    sigma_new = kernel(x, x, params) - np.dot(k, Sinv).dot(k)
    return y_pred, sigma_new


x_pred = np.linspace(-3, 3, 1000)
predictions = [predict(i, x, exponential_cov, θ, σ_1, y) for i in x_pred]
y_pred, sigmas = np.transpose(predictions)
plt.errorbar(x_pred, y_pred, yerr=sigmas, capsize=0)
plt.plot(x, y, "ro")
m, s = conditional([-0.7], x, y, θ)
y2 = np.random.normal(m, s)
y2
x.append(-0.7)
y.append(y2)

σ_2 = exponential_cov(x, x, θ)
predictions = [predict(i, x, exponential_cov, θ, σ_2, y) for i in x_pred]
y_pred, sigmas = np.transpose(predictions)
plt.errorbar(x_pred, y_pred, yerr=sigmas, capsize=0)
plt.plot(x, y, "ro")
x_more = [-2.1, -1.5, 0.3, 1.8, 2.5]
mu, s = conditional(x_more, x, y, θ)
y_more = np.random.multivariate_normal(mu, s)
y_more
x += x_more
y += y_more.tolist()

σ_new = exponential_cov(x, x, θ)
predictions = [predict(i, x, exponential_cov, θ, σ_new, y) for i in x_pred]

y_pred, sigmas = np.transpose(predictions)
plt.errorbar(x_pred, y_pred, yerr=sigmas, capsize=0)
plt.plot(x, y, "ro")

## ---(Mon May 18 15:52:55 2020)---
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()
f = open(path_dir +  '\\' +  file_list[0]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)
file_list[0])
file_list[0]
file_list
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[1]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp

del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None


import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_x, grid_y = np.mgrid[minx:maxx:0.1, miny:maxy:0.1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_y, grid_x) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((1470-i)**2 + (1470-j)**2) > 1470**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  

# Look at it!
#plt.imshow(z_, origin="lower", extent=extent)
#plt.scatter(x, y, s=2, c='w')

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')

cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')

cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[10]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
625_df = pd.read_excel(r'C:\Users\wtjang\Documents\work\625.xlsx')
df_625 = pd.read_excel(r'C:\Users\wtjang\Documents\work\625.xlsx')
data = {}

for i in range(0, len(df_625)):
    
    data[int(df_625.iloc[i,0]),int(df_625.iloc[i,1])] = df_625.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
file_list
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None


import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[21]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[21]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')

cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')

cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
file_list
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[1]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]



df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None


file_list
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[2]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[17]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[18]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[1]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[10]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[11]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[18]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
file_list
import os
import pandas as pd
import numpy as np
import matplotlib.pylab as plt 

path_dir = r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일'
file_list = os.listdir(path_dir)
file_list.sort()

f = open(path_dir +  '\\' +  file_list[3]) # 25p 가져오기

lines = f.readlines()
labels = lines[0].split(',') # line 0 : Factor  
df = pd.DataFrame(columns = labels)

for i in range(2, len(lines)):
    temp = lines[i]
    temp = temp.split(',')
    
    df.loc[i-2] = temp


del df[df.iloc[:,-1].name] # 제일 마지막 빈 열 삭제
df_Meta = df.loc[:, ['SLOT', 'LOT ID', 'COLLECTION DATE/TIME', 'RECIPE', 'MATERIAL']]
df_Stat = df.loc[:, ['SLOT','RESULT TYPE', 'MEAN', 'MIN', 'MAX', '% STDDEV', 'STDDEV', '3 % STDDEV', '3 STDDEV', 'RANGE']]
df_Point = df.loc[:, 'DATA[1]':(df.iloc[:,-1]).name]

num_first_Wafer = int(df_Meta.loc[0,'SLOT']) 
num_last_Wafer = int(df_Meta.loc[len(df_Meta)-1,'SLOT'])

num_Wafer =num_last_Wafer - num_first_Wafer + 1
num_Feature = len(df_Meta) / num_Wafer #1st Thickness, 1st RI @ 633.0nm, GOF 등의 개수

df_Meta_final = pd.DataFrame(columns = df_Meta.columns)
for k in range(0, num_Wafer):
    df_Meta_final.loc[k] = df_Meta.loc[k*num_Feature]

df_Point_dict={}
for i in range(num_first_Wafer, num_last_Wafer+1):
    df_Point_dict[i] = df_Point.loc[num_Feature*(i-num_first_Wafer):(num_Feature*(i-num_first_Wafer+1))-1,]





'''
dict에 최종형태로 들어감 x,y,feature col 형태로 삽입
df_Point_finial_dict에 접근하면 됨. df_Point_finail_dict[10] : 10번 Wafer로 접근해서 Dataframe 가져온다

Series to list : values.tolist())

df_10_final = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist())
df_10_T = df_10.T

for point_num in range(0,int(len(df_Point.columns)/3)):
    df_10_final.loc[point_num,'X'] = df_10_T.iloc[3*point_num+1,0]
    df_10_final.loc[point_num,'Y'] = df_10_T.iloc[3*point_num+2,0]
    df_10_final.loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = df_10_T.iloc[3*point_num,].values.tolist()

'''
df_Point_finial_dict = {}

for i in range(num_first_Wafer, num_last_Wafer+1):
    
    df_Point_finial_dict[i] = pd.DataFrame(columns = ['X','Y'] + (df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()) 
    temp = df_Point_dict[i].T
    
    for point_num in range(0,int(len(df_Point.columns)/3)):
        df_Point_finial_dict[i].loc[point_num,'X'] = temp.iloc[3*point_num+1,0]
        df_Point_finial_dict[i].loc[point_num,'Y'] = temp.iloc[3*point_num+2,0]
        df_Point_finial_dict[i].loc[point_num,(df_Stat.loc[0:num_Feature-1,'RESULT TYPE']).values.tolist()] = temp.iloc[3*point_num,].values.tolist()
    
    temp = None

import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
temp_25point = df_Point_finial_dict[24]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[24]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')

#temp_25point = temp_25point.loc[0:48,]

data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]



x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
data = {}
'''
for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

'''
for i in range(0, 48):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

data = {}
'''
for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

'''
for i in range(0, 49):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]


'''
for i in range(0, 49):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

'''    

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
import numpy as np
from scipy.interpolate import Rbf
%matplotlib inline
import matplotlib.pyplot as plt

temp_25point = df_Point_finial_dict[20]
temp_25point = temp_25point.loc[:,'X':(temp_25point.iloc[:,-1]).name].apply(pd.to_numeric, errors = 'coerce')
data = {}

for i in range(0, len(temp_25point)):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]


'''
for i in range(0, 49):
    
    data[int(temp_25point.iloc[i,0]),int(temp_25point.iloc[i,1])] = temp_25point.iloc[i,2]

'''    

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
point_109 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx', header = 1)
point_109 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx', header = 0)
point_109 = point_109[['X','Y','THK']]
data = {}

for i in range(0, len(point_109)):
    
    data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

for i in range(0,z_.shape[0]):
    for j in range(0,z_.shape[1]):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) > max(z_.shape[0]/2,z_.shape[1]/2)**2:
            z_[i,j] = 0


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((z_.shape[0]/2-i)**2 + (z_.shape[1]/2-j)**2) < edge_s**2:
            z_[i,j] = 0   


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
z_ = rbfi(grid_x, grid_y) #뒤집어!


for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')


cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
data = {}

for i in range(0, len(point_109)):
    
    data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]




x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]
data = {}

for i in range(0, len(point_109)):
    
    data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]




x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan   
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
len(z_)
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0

for i in range(0,len(z_)-3):
    for j in range(0,len(z_)-3):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan  
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
kk = z_.iloc[1:286,]
numpy.delete(z_, 288)
kk = z_[0:285,]
kk = z_[0:286,]
z_ = z_[0:286,]
len(z_)
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
point_109 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx', header = 0)

point_109 = point_109[['X','Y','THK']]
data = {}

for i in range(0, len(point_109)):
    
    data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]


x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
z_ = z_[0:286,]
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:0.5, minx:maxx:0.5]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)
grid_y
data = {}

for i in range(0, len(point_109)):
    
    data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]




x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:0.5, minx:maxx:0.5]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
z_ = z_[0:572,]
z_ = z_[0:572,]

for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((286-i)**2 + (286-j)**2) > 286**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan    
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
data = {}

for i in range(0, len(point_109)):
    
    data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]




x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!

z_ = z_[0:286,]
'''
z_ = z_[0:572,]
'''
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 1)
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 1)
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)
matching = matching[,0:1]
matching = matching.loc[,0:1]
matching = matching.loc[:,0:1]
matching = matching[:,0:1]
matching = matching[:,[0:1]]
matching = matching[:,['X':'Y']]
matching = matching[,0:1]
matching = matching[:,0:1]
matching = matching.iloc[:,0:1]
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]
len(matching)
matching[1,1]
matching(1,1)
matching.loc(1,1)
matching.loc[1,1]
matching.iloc[1,1]
matching.iloc[0,0]
matching.iloc[0,1]
matching.iloc[1,1]
matching.iloc[1,0]
143 - matching.iloc[1,0]
143 - matching.iloc[3,0]
for i in range(0, len(matching)):
    matching.iloc[i,0] = 143 - matching.iloc[i,1]
    matching.iloc[i,1] = 143 + matching.iloc[i,0]

matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]


test_matching = matching
for i in range(0, len(matching)):
    test_matching.iloc[i,0] = 143 - matching.iloc[i,1]
    test_matching.iloc[i,1] = 143 + matching.iloc[i,0]

matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]
i=1
143 - matching.iloc[i,1]
i=0
143 - matching.iloc[i,1]
143 + matching.iloc[i,0]
i=1
143 - matching.iloc[i,1]
143 + matching.iloc[i,0]
matching[i,1]
for i in range(0, len(matching)):
    test_matching[i,0] = 143 - matching.iloc[i,1]
    test_matching[i,1] = 143 + matching.iloc[i,0]

matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]


test_matching = matching

for i in range(0, len(matching)):
    test_matching.iloc[i,0] = 143 - matching.iloc[i,1]
    test_matching.iloc[i,1] = 143 + matching.iloc[i,0]

test_matching <- matching
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]


test_matching <- matching
test_matching <- matching
test_matching = matching.copy()
i=0
test_matching.iloc[i,0]
test_matching.iloc[i,1]
143 - matching.iloc[i,1]
143 + matching.iloc[i,0]
i=1
test_matching.iloc[i,0]
i=0
test_matching.iloc[i,0] = 143 - matching.iloc[i,1]
test_matching.iloc[i,1] = 143 + matching.iloc[i,0]
for i in range(0, len(matching)):
    test_matching.iloc[i,0] = 143 - matching.iloc[i,1]
    test_matching.iloc[i,1] = 143 + matching.iloc[i,0]

len(test_matching)
len(z_)
z_[1,1]
for i in range(0, len(test_matching)):
    for x in range(0, len(z_)):
        for y in range(0, len(z_)):
            if (test_matching.iloc[i,0] == x) & (test_matching.iloc[i,1] == y):
                test_matching.iloc[i,2] = z_[x,y]

i=0
test_matching.iloc[i,0]
test_matching.iloc[i,1]
test_matching.iloc[i,0]
z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]
for i in range(0, len(test_matching)):
    test_matching.iloc[i,2] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]

for i in range(0, len(test_matching)):
    test_matching.iloc[i,2] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]

i
test_matching.iloc[i,2]
test_matching.iloc[i,1]
test_matching[i,2]
test_matching.loc[i,2]
for i in range(0, len(test_matching)):
    test_matching[i,'value'] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]

test_matching = pd.concat([test_matching, value], axis = 1) 
test_matching = pd.concat([test_matching, 'value'], axis = 1) 
test_matching["value"] = 0
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]


test_matching = matching.copy()
test_matching["value"] = 0
for i in range(0, len(matching)):
    test_matching.iloc[i,0] = 143 - matching.iloc[i,1]
    test_matching.iloc[i,1] = 143 + matching.iloc[i,0]

for i in range(0, len(test_matching)):
    test_matching[i,'value'] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]

i=0
test_matching[i,'value'] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]


test_matching = matching.copy()
test_matching["value"] = 0

for i in range(0, len(matching)):
    test_matching.iloc[i,0] = 143 - matching.iloc[i,1]
    test_matching.iloc[i,1] = 143 + matching.iloc[i,0]

i=0
test_matching[i,'value'] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]
test_matching[i,3] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]
test_matching.loc[i,3] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]


test_matching = matching.copy()
test_matching["value"] = 0

for i in range(0, len(matching)):
    test_matching.iloc[i,0] = 143 - matching.iloc[i,1]
    test_matching.iloc[i,1] = 143 + matching.iloc[i,0]

test_matching.loc[i,3] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]


test_matching = matching.copy()
test_matching["value"] = 0

for i in range(0, len(matching)):
    test_matching.iloc[i,0] = 143 - matching.iloc[i,1]
    test_matching.iloc[i,1] = 143 + matching.iloc[i,0]

i=0
test_matching.loc[i,3] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]


test_matching = matching.copy()
test_matching["value"] = 0

for i in range(0, len(matching)):
    test_matching.iloc[i,0] = 143 - matching.iloc[i,1]
    test_matching.iloc[i,1] = 143 + matching.iloc[i,0]

i=0
test_matching.loc[i,'value'] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]
for i in range(0, len(test_matching)):
    test_matching.loc[i,'value'] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]

matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]


test_matching = matching.copy()
test_matching["value"] = 0

for i in range(0, len(matching)):
    test_matching.iloc[i,0] = 143 - matching.iloc[i,1]
    test_matching.iloc[i,1] = 143 + matching.iloc[i,0]

for i in range(0, len(test_matching)):
    if (test_matching.iloc[i,0] >= 0 ) & (test_matching.iloc[i,1] >= 0 ):
        test_matching.loc[i,'value'] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]

z_[272,79]
z_[0,124]
z_[23,223]
point_625 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\625pt.xlsx', header = 0)

point_625 = point_109[['X','Y','THK']]
point_625 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\625pt.xlsx', header = 1)

point_625 = point_109[['X','Y','THK']]
point_625 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\625pt.xlsx', header = 1)

point_625 = point_625[['X','Y','THK']]
point_625 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\625pt.xlsx', header = 0)

point_625 = point_625[['X','Y','THK']]
for i in range(0, len(point_625)):
    
    data[int(point_625.iloc[i,0]),int(point_625.iloc[i,1])] = point_625.iloc[i,2]

point_625 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\625pt.xlsx', header = 0)

point_625 = point_625[['X','Y','THK']]

data = {}

for i in range(0, len(point_625)):
    
    data[int(point_625.iloc[i,0]),int(point_625.iloc[i,1])] = point_625.iloc[i,2]

x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((147-i)**2 + (147-j)**2) > 147**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan   
plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
point_625 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx', header = 0)
point_109 = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\109pt.xlsx', header = 0)
point_109 = point_109[['X','Y','THK']]
data = {}

for i in range(0, len(point_109)):
    
    data[int(point_109.iloc[i,0]),int(point_109.iloc[i,1])] = point_109.iloc[i,2]


x = np.array([k[0] for k in data.keys()])
y = np.array([k[1] for k in data.keys()])
z = np.array([v for v in data.values()])

# Make the grid.
minx, maxx = np.amin(x), np.amax(x)
miny, maxy = np.amin(y), np.amax(y)
extent = (minx, maxx, miny, maxy)
grid_y, grid_x = np.mgrid[miny:maxy:1, minx:maxx:1]

# Make an n-dimensional interpolator.
rbfi = Rbf(x, y, z)

# Predict on the regular grid.
z_ = rbfi(grid_x, grid_y) #뒤집어!
z_ = z_[0:286,]
'''
z_ = z_[0:572,]
'''
for i in range(0,len(z_)):
    for j in range(0,len(z_)):
        if ((143-i)**2 + (143-j)**2) > 143**2:
            z_[i,j] = 0


z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
cmap = plt.get_cmap('jet', 10)
plt.imshow(z_, origin="lower", extent=extent,cmap = cmap)
plt.colorbar() 
z_[z_ == 0] = np.nan      

plt.imshow(z_, origin="lower", extent=extent,cmap = 'gist_rainbow_r')
plt.colorbar() 
plt.scatter(x, y, s=20, c='black')
matching = pd.read_excel(r'C:\Users\wtjang\Desktop\프로젝트\20200207 Wafer map\계측 파일\matching.xlsx', header = 0)

matching = matching.iloc[:,0:2]
test_matching = matching.copy()
test_matching["value"] = 0
for i in range(0, len(matching)):
    test_matching.iloc[i,0] = 143 - matching.iloc[i,1]
    test_matching.iloc[i,1] = 143 + matching.iloc[i,0]

for i in range(0, len(test_matching)):
    if (test_matching.iloc[i,0] >= 0 ) & (test_matching.iloc[i,1] >= 0 ):
        test_matching.loc[i,'value'] = z_[test_matching.iloc[i,0],test_matching.iloc[i,1]]

z_[143,0]
z_[143,:]